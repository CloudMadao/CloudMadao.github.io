<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo+NexT搭建个人博客</title>
    <url>/2020/05/07/Hexo-NexT%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>安装 Hexo 前要先安装：</p>
<ul>
<li>Node.js</li>
<li>Git<a id="more"></a>


</li>
</ul>
<h2 id="在GitHub-上搭建个人博客"><a href="#在GitHub-上搭建个人博客" class="headerlink" title="在GitHub 上搭建个人博客"></a>在GitHub 上搭建个人博客</h2><h3 id="GitHub创建仓库"><a href="#GitHub创建仓库" class="headerlink" title="GitHub创建仓库"></a>GitHub创建仓库</h3><p>新建一个名为<code>用户名.github.io</code>的仓库，如<code>CloudMadao.github.io</code>,以后可以通过<a href="https://CloudMadao.github.io" target="_blank" rel="noopener">https://CloudMadao.github.io</a> 访问自己的个人博客。</p>
<p>注意：仓库中的用户名对大小写敏感</p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>

<h3 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h3><p>进入博客文件夹(CloudMadao)，执行如下命令进行初始化：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd D:/CloudMadao</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<p>执行初始化命令之后Hexo会下载一些文件到这个文件夹下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-rw-r--r-- 1 admin 197121  2468  5月  7 13:59 _config.yml</span><br><span class="line">drwxr-xr-x 1 admin 197121     0  5月  7 14:01 node_modules/</span><br><span class="line">-rw-r--r-- 1 admin 197121   602  5月  7 13:59 package.json</span><br><span class="line">-rw-r--r-- 1 admin 197121 75419  5月  7 14:01 package-lock.json</span><br><span class="line">drwxr-xr-x 1 admin 197121     0  5月  7 13:59 scaffolds/</span><br><span class="line">drwxr-xr-x 1 admin 197121     0  5月  7 13:59 source/</span><br><span class="line">drwxr-xr-x 1 admin 197121     0  5月  7 13:59 themes/</span><br></pre></td></tr></table></figure>

<p>注意：hexo中存在两个<code>_config.yml</code>文件，一个存在于根目录CloudMadao下，称为<code>站点配置文件</code>，另一个存在于theme下，称为<code>主题配置文件</code></p>
<p>初始化Hexo之后即可以生成博客和预览博客</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g #生成</span><br><span class="line">hexo s #启动Hexo服务</span><br></pre></td></tr></table></figure>

<p>在本地启动Hexo服务之后，访问<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 可以看到初始化的博客内容。</p>
<h3 id="将博客部署到GitHub"><a href="#将博客部署到GitHub" class="headerlink" title="将博客部署到GitHub"></a>将博客部署到GitHub</h3><p>在站点配置文件<code>_config.yml</code>,中修改deploy部分：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">'git'</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">https://github.com/CloudMadao/CloudMadao.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p>注意：配置文件为yaml格式，需要注意缩进</p>
<p>执行 <code>hexo d</code>将博客部署到GitHub，若是出现如下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Deployer not found: git</span><br></pre></td></tr></table></figure>

<p>需要安装相关插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>将博客部署到GitHub上之后，访问<a href="https://cloudmadao.github.io/即可访问" target="_blank" rel="noopener">https://cloudmadao.github.io/即可访问</a></p>
<hr>
<h2 id="NexT主题配置"><a href="#NexT主题配置" class="headerlink" title="NexT主题配置"></a>NexT主题配置</h2><h3 id="设置hexo的next主题"><a href="#设置hexo的next主题" class="headerlink" title="设置hexo的next主题"></a>设置hexo的next主题</h3><p>将站点配置文件_config.xml中的theme: landscape改为theme: NexT</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">NexT</span> <span class="comment">#NexT为下载的next主题位置</span></span><br></pre></td></tr></table></figure>

<h3 id="配置网站相关信息"><a href="#配置网站相关信息" class="headerlink" title="配置网站相关信息"></a>配置网站相关信息</h3><p>修改站点配置文件<code>_config.yml</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Madao's</span> <span class="string">Personal</span> <span class="string">Website</span>       <span class="comment"># 网站标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">'今天 &lt;s&gt;摸鱼&lt;/s&gt; 学习了吗'</span>  <span class="comment"># 网站副标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">'Constant dropping wears the stone'</span>  <span class="comment"># 描述，介绍网站的</span></span><br><span class="line"><span class="attr">keywords:</span>       <span class="comment"># 网站的关键字</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">摸鱼选手Madao</span>  <span class="comment"># 博主姓名</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-Hans</span> <span class="comment"># 语言：zh-CN 是简体中文</span></span><br><span class="line"><span class="attr">timezone:</span>   <span class="comment"># 时区</span></span><br></pre></td></tr></table></figure>

<p>修改主题配置文件<code>_config.yml</code>,使用nexT的Pisces主题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure>

<h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><h4 id="开启标签和分类页面："><a href="#开启标签和分类页面：" class="headerlink" title="开启标签和分类页面："></a>开启标签和分类页面：</h4><p>标签：</p>
<p>创建tags和页面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<p>修改tags中的<code>index.md</code>文件(categories类似)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2020-05-07 16:00:51</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h4 id="配置hexo本地搜索"><a href="#配置hexo本地搜索" class="headerlink" title="配置hexo本地搜索"></a>配置hexo本地搜索</h4><p>安装<code>hexo-generator-searchdb</code>插件</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install hexo<span class="literal">-generator</span><span class="literal">-searchdb</span> -<span class="literal">-save</span></span><br></pre></td></tr></table></figure>

<p>修改站点配置文件<code>_config.yml</code>,添加如下内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本地搜索</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>修改主题配置文件<code>_config.yml</code>,开启<code>local_search</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local Search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">#开启本地搜索</span></span><br></pre></td></tr></table></figure>

<h4 id="配置头像"><a href="#配置头像" class="headerlink" title="配置头像"></a>配置头像</h4><p>编辑主题配置文件<code>_config.yml</code>,修改其中的<code>avatar</code>字段</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将头像文件 Sakai Izumi2.png 放置在主题目录的source/images目录下</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/Sakai</span> <span class="string">Izumi2.png</span></span><br></pre></td></tr></table></figure>

<h4 id="配置社交链接"><a href="#配置社交链接" class="headerlink" title="配置社交链接"></a>配置社交链接</h4><p>修改主题配置文件中的Social字段，显示相关社交账号</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/example</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">mailto:example@hotmail.com</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-envelope</span></span><br></pre></td></tr></table></figure>

<h4 id="首页博客显示摘要"><a href="#首页博客显示摘要" class="headerlink" title="首页博客显示摘要"></a>首页博客显示摘要</h4><p>NexT7.6之后移除了截断文章作为的摘要功能，现在我们可以通过<code>&lt;!--more--&gt;</code>来精确控制摘要的内容:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 2020.5.4 奇怪的知识增加了</span><br><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure>

<p>添加<!--more-->之后，将会以该标签之前的文本作为摘要内容。</p>
<h4 id="页面阅读统计"><a href="#页面阅读统计" class="headerlink" title="页面阅读统计"></a>页面阅读统计</h4><p>修改主题配置文件<code>_config.yml</code>中的<code>busuanzi_count</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span>              <span class="comment"># 设true 开启</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span>       <span class="comment"># 总阅读人数（uv数）</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">user</span>  <span class="comment"># 阅读总人数的图标</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span>          <span class="comment"># 总阅读次数（pv数）</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">eye</span>      <span class="comment"># 阅读总次数的图标</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span>           <span class="comment"># 开启内容阅读次数</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">eye</span>       <span class="comment"># 内容页阅读数的图标</span></span><br></pre></td></tr></table></figure>

<h4 id="背景动画设置"><a href="#背景动画设置" class="headerlink" title="背景动画设置"></a>背景动画设置</h4><p><strong>Canvas-nest</strong></p>
<p>在站点目录下CloudMadao/source/_data创建一个<code>footer.swig</code>文件,若是<code>_data</code>目录不存在先创建目录.</p>
<p>在<code>footer.swig</code>文件下添加如下内容</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;script color=<span class="string">"0,0,255"</span> opacity=<span class="string">"0.5"</span> zIndex=<span class="string">"-1"</span> count=<span class="string">"99"</span> </span><br><span class="line">        src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在主题配置文件中启用该文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="attr">footer:</span> <span class="string">source/_data/footer.swig</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java基础]-ArrayList结构</title>
    <url>/2020/05/11/Java%E5%9F%BA%E7%A1%80-ArrayList%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="ArrayList的特性"><a href="#ArrayList的特性" class="headerlink" title="ArrayList的特性"></a>ArrayList的特性</h2><p><code>ArrayList</code>是基于数组形式实现的集合，存在着数组的特性：</p>
<ul>
<li>添加和删除元素涉及到一次元素复制，比较耗费性能(除在数组后面直接添加元素外)</li>
<li>数组是一种随机访问模式，其中的元素获取非常快<a id="more"></a>


</li>
</ul>
<table>
<thead>
<tr>
<th align="center">问题</th>
<th align="center">结论</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ArrayList是否允许为空</td>
<td align="center">允许</td>
</tr>
<tr>
<td align="center">ArrayList是否允许重复数据</td>
<td align="center">允许</td>
</tr>
<tr>
<td align="center">ArrayList是否有序</td>
<td align="center">有序</td>
</tr>
<tr>
<td align="center">ArrayList是否线程安全</td>
<td align="center">不安全</td>
</tr>
</tbody></table>
<h2 id="ArrayList添加元素的过程"><a href="#ArrayList添加元素的过程" class="headerlink" title="ArrayList添加元素的过程"></a>ArrayList添加元素的过程</h2><p>添加元素的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">"000"</span>);</span><br><span class="line">        list.add(<span class="string">"111"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入ArrayList的add方法，可以看到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>; <span class="comment">//Default initial capacity.</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">       elementData[size++] = e;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>发现在调用<code>add</code>方法时只是在<code>elementData</code>的某个位置添加一个元素而已。</p>
<blockquote>
<p>那么当ArrayList底层数组大小不够时要如何处理呢？答案是对底层数组进行扩容处理</p>
</blockquote>
<h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>查看<code>add</code>方法的<code>ensureCapacityInternal</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>进一步查看<code>ensureExplicitCapacity</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++; <span class="comment">//在父类ArrayList中定义了modCount的值初始为0，其含义为结构的扩容次数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)  <span class="comment">//如果最小需要容量大于数组长度，将数组扩容</span></span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，调用了<code>grow</code>方法进行了扩容操作，其源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// overflow-conscious code</span></span><br><span class="line">      <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">      <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">          newCapacity = minCapacity;</span><br><span class="line">      <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">          newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">      <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">      elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>看到新容器的容量为原容器容量右移一位（<code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code>）即相当于原容量的<strong>1.5</strong>倍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<p>根据右移运算符的性质不难发现扩容后的新容器的容量<code>newCapacity</code>可能会导致其值为负数，因此需要判断扩容后的容量是否为负<code>if（newCapacity - MAX_ARRAY_SIZE &gt; 0）</code>若是负数时抛出<code>内存溢出异常</code>，否则将内存最大值开放到<em>Integer.MAX_VALUE</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">       <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">           Integer.MAX_VALUE :</span><br><span class="line">           MAX_ARRAY_SIZE;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>最后<code>grow</code>调用<code>Arrays</code>工具类的<code>copyOf</code>方法将数据复制到<code>新数组</code>中,即添加元素可能会导致扩容操作，此时数组已经换成一个更大容量的数组了。</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>即在ArrayList数组的指定位置插入指定元素，此时，调用了<code>add</code>带两个参数的重载方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>rangeCheckForAdd(index)</code>函数检查了index的范围，不能大于size，也不能小于0，然后就是确认容量，然后是复制的过程，把index之后的元素都往后移一个单位，然后再index插入需要插入的元素</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>ArrayList删除元素有两种方式，一种是按照下标删除，一种是按照匹配的第一个元素值来删除</p>
<h3 id="按下标删除："><a href="#按下标删除：" class="headerlink" title="按下标删除："></a>按下标删除：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>rangeCheck(index)</code>函数检查index范围是否合法，当<em>index&gt;=size</em>时，抛出下标越界异常。</p>
<p>然后将下标后部元素全部向前复制一位，然后把最后的一个数据设置为null，如果数组只有一个对象那就直接赋值为null.</p>
<h2 id="ArrayList与Vector"><a href="#ArrayList与Vector" class="headerlink" title="ArrayList与Vector"></a>ArrayList与Vector</h2><p>ArrayList是线程非安全的，这很明显，因为ArrayList中所有的方法都不是同步的，在<code>并发下一定会出现线程安全问题</code>。</p>
<p><em>Vector</em>，它是ArrayList的线程安全版本，其实现90%和ArrayList都完全一样，区别在于：</p>
<ul>
<li>Vector是线程安全的，ArrayList是线程非安全的</li>
<li>Vector可以指定增长因子，如果该增长因子指定了，那么扩容的时候会每次新的数组大小会在原数组的大小基础上加上增长因子；如果不指定增长因子，那么就给原数组大小*2，源代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If the capacity increment is less than or equal to zero, the capacity of the vector is doubled each time it needs to grow</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> capacityIncrement;</span><br></pre></td></tr></table></figure>

<p><code>grow中:</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                         capacityIncrement : oldCapacity);</span><br></pre></td></tr></table></figure>

<h2 id="elementData的transient修饰符"><a href="#elementData的transient修饰符" class="headerlink" title="elementData的transient修饰符"></a>elementData的transient修饰符</h2><p>可以看到<code>elementData</code>是被<code>transient</code>修饰的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></table></figure>

<p>那么<strong>为什么要使用transient修饰呢?</strong></p>
<p>ArrayList实现了Serializable接口，这意味着ArrayList是可以被序列化的，用<em>transient</em>修饰elementData意味着我们不希望elementData数组被序列化，因为序列化ArrayList的时候，ArrayList里面的elementData未必是满的，比方说elementData有10的大小，但是我只用了其中的3个，那么是否有必要序列化整个elementData呢？显然没有这个必要，因此ArrayList中重写了writeObject方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">        <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">        s.writeInt(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            s.writeObject(elementData[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>每次序列化的时候调用这个方法，先调用defaultWriteObject()方法序列化ArrayList中的非transient元素，elementData不去序列化，然后遍历elementData，只序列化那些有的元素，这样：</p>
<ol>
<li>加快了序列化速度</li>
<li>减少文件大小</li>
</ol>
<blockquote>
<p><strong>如果以后开发过程中有遇到这种情况，也是值得学习、借鉴的一种思路。</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
