<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="Zfds7O_oYzbVPUTriZY6nqorXSh6sLoYR_zd0WKwBzQ" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Comic Sans MS:300,300italic,400,400italic,700,700italic|Lato:300,300italic,400,400italic,700,700italic|Consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/horse.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/horse.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/horse.png?v=5.1.4">


  <link rel="mask-icon" href="/images/horse.png?v=5.1.4" color="#222">





  <meta name="keywords" content="多线程,计算机网络,redis,Java,MySQL," />










<meta name="description" content="Java面试八股 希望HR知道我的邮箱除了用来收感谢信也是可以用来收offer的">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面试八股">
<meta property="og:url" content="https://cloudmadao.github.io/2021/10/18/Java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/index.html">
<meta property="og:site_name" content="Madao&#39;s Personal Website">
<meta property="og:description" content="Java面试八股 希望HR知道我的邮箱除了用来收感谢信也是可以用来收offer的">
<meta property="og:image" content="https://img.php.cn/upload/article/000/000/028/5c73a16ef1c04585.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210911092310.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20211018110930.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20211018164548.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20211018170740.png">
<meta property="og:image" content="https://camo.githubusercontent.com/02e863f3d5de3c34484f6162c1d0b3bf8912dbd70ac0a672bb99724f1f47f2d8/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f4a6176612532302545372541382538422545352542412538462545352539312539382545352542462538352545352541342538372545462542432539412545352542392542362545352538462539312545372539462541352545382541462538362545372542332542422545372542422539462545362538302542422545372542422539332f434c482e706e67">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20200409195521.jfif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20200409212059.jfif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909091033.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909091602.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909103101.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909103156.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909151522.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909152412.png">
<meta property="og:image" content="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/01d330d8-2710-4fad-a91c-7bbbfaaefc0e.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909213741.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909213810.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20211019091958.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210910143806.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210911100540.png">
<meta property="og:image" content="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/6eb9b856.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210910164815.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210910165114.png">
<meta property="article:published_time" content="2021-10-18T14:49:05.000Z">
<meta property="article:modified_time" content="2021-10-19T10:03:08.486Z">
<meta property="article:author" content="摸鱼选手Wei">
<meta property="article:tag" content="多线程">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="redis">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.php.cn/upload/article/000/000/028/5c73a16ef1c04585.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://CloudMadao.github.io/2021/10/18/Java面试八股/"/>





  <title>Java面试八股 | Madao's Personal Website</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Madao's Personal Website</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">今天 <s>摸鱼</s> 学习了吗</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://CloudMadao.github.io/2021/10/18/Java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="摸鱼选手Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/bear.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Madao's Personal Website">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Java面试八股</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-10-18T22:49:05+08:00">
                2021-10-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Java面试八股"><a href="#Java面试八股" class="headerlink" title="Java面试八股"></a>Java面试八股</h2><blockquote>
<p>希望HR知道我的邮箱除了用来收感谢信也是可以用来收offer的</p>
</blockquote>
<a id="more"></a>

<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p><img src="https://img.php.cn/upload/article/000/000/028/5c73a16ef1c04585.jpg" alt="img"></p>
<h3 id="HashMap-1"><a href="#HashMap-1" class="headerlink" title="HashMap"></a>HashMap</h3><ul>
<li><p>HashMap实现了Map接口，线程非安全，其线程安全版本为ConcurrentHashMap</p>
</li>
<li><p>HashMap可以存储<code>null</code>的key和value，但是null作为键的时候只能存在一个，作为值的时候可以有多个null。</p>
</li>
<li><p>HashMap默认初始化大小为<code>16</code>，每次扩容会扩容为原来的2倍</p>
<blockquote>
<p>如果给定HashMap的初始容量，HashMap会将其扩充为2的幂次方。</p>
</blockquote>
</li>
<li><p>HashMap在1.8之后使用<code>链表+红黑树</code>的结构， 当链表⻓度⼤于阈值（默认为 8)时，将链表转化为红⿊树，当树的节点数小于等于6时，转为链表，以 减少搜索时间。</p>
<p><strong>解决Hash冲突的办法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开放地址</span><br><span class="line">建立公共溢出区</span><br><span class="line">再哈希：发生Hash冲突的时候再进行一次Hash，缺点是每次冲突都要再Hash，时间成本增加</span><br><span class="line">拉链法：将Hash冲突的同义词存储在同一个线性链表中 缺点是需要额外的空间</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="HashMap的长度为什么是2的幂次"><a href="#HashMap的长度为什么是2的幂次" class="headerlink" title="HashMap的长度为什么是2的幂次"></a>HashMap的长度为什么是2的幂次</h3><p>为了能让 HashMap 存取⾼效，尽量较少碰撞，也就是要尽量把数据分配均匀。在使用散列值之前要先做对数组的⻓度取模运算，得到的余数才能⽤来要存放的位置，也就是对应的数组下标。这个数组下标的计算⽅法是“ (n - 1) &amp; hash ”。</p>
<p><strong>这个算法应该如何设计呢？</strong><br>我们⾸先可能会想到采⽤%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减⼀的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的n 次⽅；）。” 并且 采⽤⼆进制位操作 &amp;，相对于%能够提⾼运算效率，这就解释了 HashMap 的⻓度为什么是2的幂次⽅。</p>
<h3 id="HashMap线程不安全在哪"><a href="#HashMap线程不安全在哪" class="headerlink" title="HashMap线程不安全在哪"></a>HashMap线程不安全在哪</h3><ol>
<li><strong>数据丢失：</strong></li>
<li><strong>数据重复：</strong></li>
<li><strong>扩容时可能死循环(JDK1.7)：</strong>Hashmap 在多线程的情况下扩容由于链表的数据转换采用的是头插法所以会造成死循环的问题。而在jdk1.8中则进行了优化直接将原链表数据放到新数组中，不会造成死循环。</li>
</ol>
<h3 id="HashMap和TreeMap"><a href="#HashMap和TreeMap" class="headerlink" title="HashMap和TreeMap"></a>HashMap和TreeMap</h3><p>TreeMap底层使用红黑树实现，线程非安全，<strong>不允许null，key不可以重复，value允许重复</strong>，存入TreeMap的元素应当实现Comparable接口或者实现Comparator接口，会按照排序后的顺序迭代元素。<strong>主要用于存入元素的时候对元素进行自动排序</strong>，迭代输出的时候就按排序顺序输出。</p>
<h3 id="HashMap和HashSet"><a href="#HashMap和HashSet" class="headerlink" title="HashMap和HashSet"></a>HashMap和HashSet</h3><p>HashSet底层基于HashMap实现</p>
<table>
<thead>
<tr>
<th align="center">HashMap</th>
<th align="center">HashSet</th>
</tr>
</thead>
<tbody><tr>
<td align="center">实现Map接口</td>
<td align="center">实现Set接口</td>
</tr>
<tr>
<td align="center">存储键值对</td>
<td align="center">仅存储对象</td>
</tr>
<tr>
<td align="center">put()向Map中添加元素</td>
<td align="center">add()向Set中添加元素</td>
</tr>
<tr>
<td align="center">HashMap使用键(Key)计算hashcode</td>
<td align="center">HashSet使用成员对象来计算hashcode，对于两个对象来说先比较hashcode，相同时再使用<code>equals()</code>方法判断两个对象是否相等</td>
</tr>
</tbody></table>
<h3 id="集合的选用"><a href="#集合的选用" class="headerlink" title="集合的选用"></a>集合的选用</h3><p>主要根据集合的特点来选用集合，比如我们需要根据键值获取到元素值时就选⽤<code>Map</code>接口下的集合，需要排序时选用<code>TreeMap</code>,不需要排序时就选择<code>HashMap</code>,需要保证线程安全就选⽤<code>ConcurrentHashMap</code>。</p>
<p>当我们只需要存放元素值时，就选择实现<code>Collection</code>接口下的集合，需要保证元素唯⼀时选择实现<code>Set</code>接口的集合，不需要时就选择实现<code>List</code>接口的集合，然后再根据实现这些接⼝的集合的特点来选⽤。</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210911092310.png" style="zoom:80%;" />

<p>⼀个进程中可以有多个线程，多个线程共享进程的<strong>堆和方法区资源</strong>，但是每个线程有⾃⼰的<strong>程序计数器</strong>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p>
<p><strong>总结：</strong> 线程 是 进程 划分成的更⼩的运⾏单位。线程和进程最⼤的不同在于基本上各进程是独⽴的，⽽各线程则不⼀定，因为同⼀进程中的线程极有可能会相互影响。线程执⾏开销小，但不利于资源的管理和保护；而进程则相反。</p>
<h4 id="程序计数器为什么私有"><a href="#程序计数器为什么私有" class="headerlink" title="程序计数器为什么私有"></a>程序计数器为什么私有</h4><p>程序计数器主要有下面两个作用：</p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执⾏的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<h4 id="虚拟机栈和本地方法栈为什么私有"><a href="#虚拟机栈和本地方法栈为什么私有" class="headerlink" title="虚拟机栈和本地方法栈为什么私有"></a>虚拟机栈和本地方法栈为什么私有</h4><ul>
<li><p><strong>虚拟机栈：</strong>每个 Java ⽅法在执⾏的同时会创建⼀个栈帧⽤于存储局部变量表、操作数栈、常量池引⽤等信息。从⽅法调⽤直⾄执⾏完成的过程，就对应着⼀个栈帧在 Java 虚拟机栈中⼊栈和出栈的过程。</p>
</li>
<li><p><strong>本地方法栈：</strong>和虚拟机栈所发挥的作⽤⾮常相似，区别是： <strong>虚拟机栈为虚拟机执⾏ Java⽅法 （也就是字节码）服务，⽽本地⽅法栈则为虚拟机使⽤到的 Native ⽅法服务</strong>。 在HotSpot 虚拟机中和 Java 虚拟机栈合⼆为⼀。</p>
<blockquote>
<p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地⽅法栈是线程私有的。</p>
</blockquote>
</li>
</ul>
<h4 id="堆和方法区"><a href="#堆和方法区" class="headerlink" title="堆和方法区"></a>堆和方法区</h4><p>堆和⽅法区是所有线程共享的资源，其中堆是进程中最⼤的⼀块内存，主要⽤于存放新创建的对象 (所有对象都在这⾥分配内存)，⽅法区主要⽤于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p>线程的生命周期包含5个阶段，包括：<strong>新建、就绪、运行、阻塞、销毁</strong>。</p>
<ul>
<li>新建：就是刚使用new方法，new出来的线程；</li>
<li>就绪：就是调用的线程的start()方法后，这时候线程处于等待CPU分配资源阶段，谁先抢的CPU资源，谁开始执行;</li>
<li>运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run方法定义了线程的操作和功能;</li>
<li>阻塞：在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态，比如sleep()、wait()之后线程就处于了阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用notify或者notifyAll()方法。唤醒的线程不会立刻执行run方法，它们要再次等待CPU分配资源进入运行状态;</li>
<li>销毁：如果线程正常执行完毕后或线程被提前强制性的终止或出现异常导致结束，那么线程就要被销毁，释放资源;</li>
</ul>
<h3 id="多线程中的上下文切换"><a href="#多线程中的上下文切换" class="headerlink" title="多线程中的上下文切换"></a>多线程中的上下文切换</h3><p>多线程编程中⼀般线程的个数都⼤于 CPU 核⼼的个数，⽽⼀个 CPU 核⼼在任意时刻只能被⼀个线程使⽤，为了让这些线程都能得到有效执⾏，CPU 采取的策略是为每个线程分配时间⽚并轮转的形式。当⼀个线程的时间⽚⽤完的时候就会重新处于就绪状态让给其他线程使⽤，这个过程就 属于⼀次上下⽂切换。</p>
<p>概括来说就是：当前任务在执⾏完 CPU 时间⽚切换到另⼀个任务之前会先保存⾃⼰的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是⼀次上下文切换</strong>。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>线程死锁描述的是这样⼀种情况：多个线程同时被阻塞，它们中的⼀个或者全部都在等待某个资源被释放。由于线程被⽆限期地阻塞，因此程序不可能正常终⽌。</p>
<p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对⽅的资源，所以这两个线程就会互相等待⽽进⼊死锁状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20211018110930.png" alt=""></p>
<p><strong>死锁产生的条件必须具备以下四个条件：</strong></p>
<ol>
<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h4 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h4><p>为了避免死锁，我们只要破坏产⽣死锁的四个条件中的其中⼀个就可以了。现在我们来挨个分析⼀下：</p>
<ol>
<li><strong>破坏互斥条件</strong> ：这个条件我们没有办法破坏，因为我们⽤锁本来就是想让他们互斥的（临界资源需要互斥访问）。</li>
<li><strong>破坏请求与保持条件</strong> ：⼀次性申请所有的资源。</li>
<li><strong>破坏不剥夺条件</strong>：占⽤部分资源的线程进⼀步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某⼀顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>
</ol>
<blockquote>
<p>想要避免死锁，可以<strong>使用无锁函数</strong>（cas）<strong>或者使用重入锁（ReentrantLock），通过重入锁使线程中断或限时等待可以有效的规避死锁问题</strong>。</p>
</blockquote>
<h3 id="sleep-方法和wait-方法区别和共同点"><a href="#sleep-方法和wait-方法区别和共同点" class="headerlink" title="sleep()方法和wait()方法区别和共同点"></a>sleep()方法和wait()方法区别和共同点</h3><p><strong>共同点：</strong>两者都可以暂停线程的执行，都会让线程进入等待状态。</p>
<p><strong>不同点：</strong></p>
<ul>
<li><strong>sleep()方法没有释放锁，而 wait()方法释放了锁。(主要)</strong></li>
<li>sleep()方法属于Thread类的静态方法，作用于当前线程；而wait()方法是Object类的实例方法，作用于对象本身。</li>
<li>执行sleep()方法后，可以通过超时或者调用interrupt()方法唤醒休眠中的线程；执行wait()方法后，通过调用notify()或notifyAll()方法唤醒等待线程。</li>
</ul>
<h3 id="调用start-时会执行run-为什么不直接执行run"><a href="#调用start-时会执行run-为什么不直接执行run" class="headerlink" title="调用start()时会执行run(),为什么不直接执行run()"></a>调用start()时会执行run(),为什么不直接执行run()</h3><p>new 一个 Thread，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p><strong>总结： 调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p>
<h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h3><h4 id="synchronized关键字的使用"><a href="#synchronized关键字的使用" class="headerlink" title="synchronized关键字的使用"></a>synchronized关键字的使用</h4><ol>
<li><p><strong>修饰实例方法:</strong> 作⽤于当前对象实例加锁，进⼊同步代码前要获得 <strong>当前对象实例的锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>修饰静态方法</strong>： 也就是给当前类加锁，会作⽤于类的所有对象实例 ，进⼊同步代码前要获得 当前<code>class</code>的锁。因为静态成员不属于任何⼀个实例对象，是类成员。所以，如果⼀个线程 A 调⽤⼀个实例对象的⾮静态<code>synchronized</code> ⽅法，⽽线程 B 需要调⽤这个实例对象所属类的静态<code>synchronized</code> ⽅法，是允许的，不会发⽣互斥现象，<strong>因为访问静态<code>synchronized</code>⽅法占⽤的锁是当前类的锁，⽽访问⾮静态⽅法占⽤的锁是当前实例对象锁。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> staic <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>修饰代码块：</strong>指定加锁对象，对给定对象/类加锁。<code>synchronized(this|object)</code>表示进⼊同步代码块前要获得<strong>给定对象的锁</strong>。<code>synchronized(.class)</code>表示进⼊同步代码前要获得 <strong>当前</strong> <strong>class 的锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="synchronized关键字和volatile关键字的区别"><a href="#synchronized关键字和volatile关键字的区别" class="headerlink" title="synchronized关键字和volatile关键字的区别"></a>synchronized关键字和volatile关键字的区别</h4><p><strong>synchronized和volatile</strong>关键字是两个互补的存在，⽽不是对⽴的存在！</p>
<ul>
<li><strong>volatile关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以<strong>volatile性能肯定比synchronized关键字要更好</strong>。但是<strong>volatile关键字只能作用于变量</strong>，而synchronized关键字可以修饰方法和代码。</li>
<li>volatile关键字能保证数据的可见性，但<strong>不能保证数据的原子性</strong>。synchronized关键字两者都能保证。</li>
<li><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而<code>synchronized</code>关键字解决的是多个线程之间访问资源的同步性。</li>
</ul>
<h4 id="synchronized关键字和Lock的区别"><a href="#synchronized关键字和Lock的区别" class="headerlink" title="synchronized关键字和Lock的区别"></a>synchronized关键字和Lock的区别</h4><ol>
<li><code>synchronized</code>是<code>Java</code>中的关键字，而<code>Lock</code>是一个接口；</li>
<li>在发生异常时，<code>synchronized</code>会自动释放线程占有的锁，<strong>因此不会导致死锁现象发生</strong>；而<code>Lock</code>在发生异常时，如果没有主动通过<code>unLock()</code>去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</li>
<li><code>Lock</code>可以让等待锁的线程响应中断，而<code>synchronized</code>却不行，使用<code>synchronized</code>时，等待的线程会一直等待下去，不能够响应中断；</li>
<li>通过<code>Lock</code>可以知道有没有成功获取锁（<code>tryLock()</code>方法：如果获取锁成功，则返回true），而<code>synchronized</code>却无法办到。</li>
</ol>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="使用线程池的好处："><a href="#使用线程池的好处：" class="headerlink" title="使用线程池的好处："></a>使用线程池的好处：</h4><ol>
<li>降低资源消耗。通过重复利用已创建的线程，降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控</li>
</ol>
<h4 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h4><p><strong>通过Executor框架的工具类Executors实现</strong>，可以创建三种类型的<code>ThreadPoolExecutor</code></p>
<ol>
<li><strong>FixedThreadPool</strong>：可重用固定线程数的线程池（<strong>适用于负载比较重的服务器</strong>），该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li><strong>SingleThreadExecutor：</strong>⽅法返回⼀个只有⼀个线程的线程池。若多余⼀个任务被提交到该线程池，任务会被保存在⼀个任务队列中，待线程空闲，按先⼊先出的顺序执⾏队列中的任务。</li>
<li><strong>CachedThreadPool：</strong> <strong>是一个会根据需要调整线程数量的线程池</strong>。（大小无界，适用于执行很多的短期异步任务的小程序，或负载较轻的服务器）。线程池的线程数量不确定，但若有空闲线程可以复⽤，则会优先使⽤可复⽤的线程。若所有线程均在⼯作，⼜有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执⾏完毕后， 将返回线程池进⾏复⽤。</li>
</ol>
<p>对应 Executors ⼯具类中的⽅法如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20211018164548.png" alt=""></p>
<h4 id="ThreadPoolExecutor构造函数参数"><a href="#ThreadPoolExecutor构造函数参数" class="headerlink" title="ThreadPoolExecutor构造函数参数"></a>ThreadPoolExecutor构造函数参数</h4><p><strong>最重要的三个参数：</strong></p>
<ol>
<li><strong>corePoolSize</strong>：<strong>核心线程数线程数</strong>定义了最小可以同时运⾏的线程数量</li>
<li><strong>maximumPoolSize:</strong>当队列中存放的任务达到队列容量的时候，当前可以同时运⾏的线程数量变为最⼤线程数。</li>
<li><strong>workQueue：</strong>当新任务来的时候会先判断当前运⾏的线程数量是否达到核⼼线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ol>
<p><strong>其他参数：</strong></p>
<ol>
<li><strong>keepAliveTime</strong>：当线程池中的线程数量⼤于<code>corePoolSize</code>的时候， 如果这时没有新的任务提交，核⼼线程外的线程不会⽴即销毁，⽽是会等待，直到等待的时间超过了<code>keepAliveTime</code>才会回收。</li>
<li><strong>handle：</strong>饱和策略</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20211018170740.png" alt=""></p>
<blockquote>
<p>饱和策略：</p>
<ol>
<li>丢弃最早未处理的任务请求</li>
<li>不处理新任务，直接丢弃</li>
<li>拒绝新任务的处理</li>
</ol>
</blockquote>
<h3 id="多线程开发带来的问题与解决办法"><a href="#多线程开发带来的问题与解决办法" class="headerlink" title="多线程开发带来的问题与解决办法"></a>多线程开发带来的问题与解决办法</h3><h4 id="线程安全问题："><a href="#线程安全问题：" class="headerlink" title="线程安全问题："></a>线程安全问题：</h4><p>线程安全问题指的是在某一线程从开始访问到结束<strong>访问某一数据期间，该数据被其他的线程所修改</strong>，那么对于当前线程而言，该线程就发生了线程安全问题，表现形式为数据的缺失，数据不一致等。</p>
<p><strong>线程安全问题发生的条件</strong></p>
<p>1）多线程环境下，即存在包括自己在内存在有多个线程。</p>
<p>2）多线程环境下<strong>存在共享资源</strong>，且<strong>多线程操作该共享资源。</strong></p>
<p>3）多个线程必须对该共享资源有非原子性操作</p>
<p><strong>线程安全的解决思路：</strong></p>
<p>1）<strong>尽量不使用共享变量</strong>，将不必要的共享变量变成局部变量来使用。</p>
<p>2）<strong>使用synchronized关键字同步代码块</strong>，或者使用jdk包中提供的Lock为操作进行<strong>加锁</strong>。</p>
<p>3）<strong>使用ThreadLocal为每一个线程建立一个变量的副本，各个线程间独立操作，互不影响。</strong></p>
<h4 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h4><p>线程的生命周期开销是非常大的，<strong>一个线程的创建到销毁都会占用大量的内存</strong>。同时如果不合理的创建了多个线程，cup的处理器数量小于了线程数量，那么将会有很多的线程被闲置，闲置的线程将会占用大量的内存，为垃圾回收带来很大压力，同时cup在分配线程时还会消耗其性能。</p>
<p><strong>解决思路：</strong>利用线程池<strong>，模拟一个池，预先创建有限合理个数的线程放入池中，当需要执行任务时从池中取出空闲的先去执行任务，执行完成后将线程归还到池中，这样就</strong>减少了线程的频繁创建和销毁，节省内存开销和减小了垃圾回收的压力。同时因为任务到来时本身线程已经存在，减少了创建线程时间，提高了执行效率，而且合理的创建线程池数量还会使各个线程都处于忙碌状态，提高任务执行效率，线程池还提供了拒绝策略，当任务数量到达某一临界区时，线程池将拒绝任务的进入，保持现有任务的顺利执行，减少池的压力。</p>
<h3 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h3><p><strong>重进入：重进入是指任意线程在获取到锁之后，再次获取该锁而不会被该锁所阻塞</strong>。关联一个线程持有者+计数器，重入意味着锁操作的颗粒度为“线程”。</p>
<p><strong>重入锁实现重入性：</strong>每个锁<strong>关联一个线程持有者和计数器</strong>，当计数器为0时表示该锁没有被任何线程持有，那么任何线程都可能获得该锁而调用相应的方法；当某一线程请求成功后，JVM会记下锁的持有线程，并且将计数器置为1；此时其它线程请求该锁，则必须等待；而<strong>该持有锁的线程</strong>如果<strong>再次</strong>请求这个锁，就可以再次拿到这个锁，同时计数器会递增；当线程退出同步代码块时，计数器会递减，如果计数器为0，则释放该锁</p>
<h3 id="AQS-AbstractQueuedSynchronizer"><a href="#AQS-AbstractQueuedSynchronizer" class="headerlink" title="AQS(AbstractQueuedSynchronizer)"></a>AQS(AbstractQueuedSynchronizer)</h3><p><strong>AQS 定义两种资源共享⽅式：</strong></p>
<ul>
<li><p><strong>Exclusive（独占）</strong>：只有⼀个线程能执⾏，如<code>ReentrantLock</code>。又可以分为公平锁和非公平锁</p>
<ul>
<li><strong>公平锁：</strong>按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li><strong>非公平锁：</strong>当线程要获取锁时，⽆视队列顺序直接去抢锁，谁抢到就是谁的</li>
</ul>
<p><strong>公平锁和非公平锁只有两处不同：</strong></p>
<ol>
<li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li>
<li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 <code>tryAcquire</code> 方法，在 <code>tryAcquire</code> 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li>
</ol>
<p>公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。</p>
<blockquote>
<p>非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p>
</blockquote>
</li>
<li><p><strong>Share(共享)：</strong>多个线程可同时执⾏，如<code>CountDownLatch</code>。</p>
</li>
</ul>
<h4 id="AQS原理概览"><a href="#AQS原理概览" class="headerlink" title="AQS原理概览"></a>AQS原理概览</h4><p>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 <strong>CLH 队列锁</strong>实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<blockquote>
<p>CLH队列是一个虚拟的双向队列，即不存在队列实例，仅存在结点之间的关联关系</p>
</blockquote>
<p><img src="https://camo.githubusercontent.com/02e863f3d5de3c34484f6162c1d0b3bf8912dbd70ac0a672bb99724f1f47f2d8/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f4a6176612532302545372541382538422545352542412538462545352539312539382545352542462538352545352541342538372545462542432539412545352542392542362545352538462539312545372539462541352545382541462538362545372542332542422545372542422539462545362538302542422545372542422539332f434c482e706e67" alt="enter image description here"></p>
<p>AQS 使⽤⼀个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队⼯作。</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><h3 id="三次握手的过程"><a href="#三次握手的过程" class="headerlink" title="三次握手的过程"></a>三次握手的过程</h3><p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20200409195521.jfif" alt=""></p>
<ol>
<li><p>TCP服务器进程先创建<code>传输控制块TCB</code>，时刻准备接受客户进程的连接请求，此时服务器进入<code>LISTEN</code>状态。</p>
</li>
<li><p><strong>第一次握手</strong>： TCP客户进程也是先创建<code>TCB</code>,然后向服务器发出请求报文，此时报文中的<code>同部位SYN=1</code>（SYN，同步序列编号），同时选择一个初始序列号<code>seq=x</code>，此时TCP客户端进入<code>SYN-SENT(同步已发送)</code>状态。</p>
</li>
<li><p><strong>第二次握手：</strong> TCP服务器收到请求后，如果同意连接，则发出确认报文。<code>确认报文中应该ACK=1，SYN=1,确认号是ack=x+1</code>,同时为自己初始化一个序列号seq=y，此时TCP服务器进程进入<code>SYN-RCVD(同步收到)</code>状态。</p>
</li>
<li><p><strong>第三次握手：</strong> TCP客户进程收到确认后，还要向服务器给出确认。确认报文的<code>ACK=1,确认号ack=y+1</code>，自己序列号为：seq=x+1,此时，TCP连接已经建立，<strong>客户端</strong> 进入<code>ESTABLISHED(已建立连接)</code>状态，当 <strong>服务器</strong>收到客户端的确认后也进入**<code>ESTABLISHED</code>状态，双方可以开始通信。</p>
</li>
</ol>
<h4 id="为什么TCP客户端最后还要发送一次确认呢"><a href="#为什么TCP客户端最后还要发送一次确认呢" class="headerlink" title="为什么TCP客户端最后还要发送一次确认呢?"></a>为什么TCP客户端最后还要发送一次确认呢?</h4><p> 一句话，<strong>主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误</strong>。<br> 如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p>
<p> 如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p>
<h3 id="四次挥手的过程"><a href="#四次挥手的过程" class="headerlink" title="四次挥手的过程"></a>四次挥手的过程</h3><p>   <img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20200409212059.jfif" alt=""></p>
<ol>
<li><p>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部<code>FIN=1,序列号seq=u</code>(其值为之前传过来的数据最后一个字节的序号+1)，此时，<strong>客户端</strong>进入<code>FIN-WATI=1(终止等待1)</code>状态。</p>
</li>
<li><p>服务器收到连接释放报文，发出确认报文，<code>ACK=1,ack=u+1</code>,并且带上自身序列号<code>seq=v</code> ,此时，<strong>服务端</strong>进入<code>CLOSE-WATI(等待关闭)</code>状态。</p>
<blockquote>
<p>此时处于半关闭状态,即客户端已无数据需要发送，但服务器若是发送数据，客户端依然需要接收</p>
</blockquote>
</li>
<li><p>客户端收到服务器的确认请求，此时，客户端进入<code>FIN-WAIT-2(终止等待2)</code>状态，等待服务器发送连接释放报文。</p>
</li>
<li><p>服务器将最后的数据发送完毕之后，向客户端发送连接释放报文,<code>FIN=1,ack=u+1</code>，由于在半关闭状态，服务 器可能又发送了一些数据，因此假定此时的<code>序列号seq=w</code>,此时，服务器进入<code>LAST-ACK(最后确认)</code>状态。</p>
</li>
<li><p>客户端收到服务器的连接释放报文之后，必须发出确认<code>ACK=1,ack=w+1，seq=u+1</code>，此时客户端进入<code>TIME-WAIT(时间等待)</code>状态。</p>
<p>服务器只要收到了客户端发出的确认，立即进入<code>CLOSE</code>状态，同样，撤掉TCB后结束的此次连接(<code>可见，服务器结束TCP要早于客户端</code>)。</p>
<blockquote>
<p>此时TCP连接还未释放，必须经过2*MSL(<em>最长报文段寿命</em>)时间，客户端撤销相应TCB后，才进入<em>CLOSED</em>状态</p>
</blockquote>
</li>
</ol>
<h4 id="为什么建立连接是三次握手，释放连接确实四次挥手？"><a href="#为什么建立连接是三次握手，释放连接确实四次挥手？" class="headerlink" title="为什么建立连接是三次握手，释放连接确实四次挥手？"></a>为什么建立连接是三次握手，释放连接确实四次挥手？</h4><p>   建立连接时，服务器在LISTEN状态下，收到建立连接请求的 <em>SYN</em> 报文之后，把ACK和SYN放在一个报文发送给客户端。</p>
<p>   而在关闭连接时，服务器收到 <em>FIN</em>报文时，仅仅表示客户端不在发送数据但任能接收数据，因此客户端既可以立即关闭，也可以在发送一些数据给客户端之后，此时会先发送确认报文告知客户端已经准备关闭连接，当服务器数据发送完成之后，再发送 <em>FIN报文</em>给客户端。因此，服务端的ACK和FIN会分开发送，从而导致了四次挥手。</p>
<h3 id="三次握手过程中可以携带数据嘛"><a href="#三次握手过程中可以携带数据嘛" class="headerlink" title="三次握手过程中可以携带数据嘛"></a>三次握手过程中可以携带数据嘛</h3><p><strong>在第三次握手的时候可以携带数据</strong>，但是第一次、第二次握手不可以携带数据一个简单的原因就是会让服务器更加容易受到攻击，对于第三次的话，此时客户端已经处于ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据。</p>
<blockquote>
<p>假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。</p>
</blockquote>
<h3 id="如果已经建立连接，但是客户端出现故障-TCP的保活机制-keapalive长连接"><a href="#如果已经建立连接，但是客户端出现故障-TCP的保活机制-keapalive长连接" class="headerlink" title="如果已经建立连接，但是客户端出现故障(TCP的保活机制)(keapalive长连接)"></a>如果已经建立连接，但是客户端出现故障(TCP的保活机制)(keapalive长连接)</h3><p>TCP有一个机制是保活机制，工作原理为：当一个TCP 连接建立之后，启用TCP Keepalive 的一端便会启动一个计时器，当这个计时器数值到达0 内（7200s)，连接没有任何动作,，一个TCP 探测包便会被发出。这个TCP 探测包是一个纯ACK 包，客户主机必须处于以下4 个状态之一：</p>
<ol>
<li>客户主机依然正常运行，并从服务器可达。客户的TCP 响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。</li>
<li>客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP 都没有响应。服务端将不能收到对探测的响应，并在75 秒后超时。服务器总共发送9 个这样的探测，每个间隔75 秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。</li>
<li>客户主机崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，但是由于没有该连接的有效信息，会产生一个RST报文，这样很快就发现TCP连接已经被重置。</li>
</ol>
<blockquote>
<p>保活机制需要消耗额外的宽带和流量。</p>
</blockquote>
<h3 id="TCP的重传机制"><a href="#TCP的重传机制" class="headerlink" title="TCP的重传机制"></a>TCP的重传机制</h3><p>TCP实现可靠传输的方式之一，是通过序列号与确认应答。</p>
<p>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。万一数据在传输过程中丢失了呢？所以 TCP 针对数据包丢失的情况，会用<strong>重传机制</strong>解决。</p>
<p><strong>超时重传</strong></p>
<p>在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据，也就是我们常说的<strong>超时重传</strong>。</p>
<p><strong>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值,每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。</strong></p>
<blockquote>
<p>TCP 会在以下两种情况发生超时重传：</p>
<ul>
<li>数据包丢失</li>
<li>确认应答丢失</li>
</ul>
</blockquote>
<p><strong>快速重传</strong></p>
<p>快速重传机制<strong>不以时间为驱动，而是以数据驱动重传</strong>。快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</p>
<img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909091033.png" style="zoom: 80%;" />

<p>在上图，发送方发出了 1，2，3，4，5 份数据：</p>
<ul>
<li>第一份 Seq1 先送到了，于是就 Ack 回 2；</li>
<li>结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；</li>
<li>后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；</li>
<li><strong>发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。</strong></li>
<li>最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。</li>
</ul>
<blockquote>
<p>因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的,所以快速重传临着另外一个问题。就是<strong>重传的时候，是重传之前的一个，还是重传所有的问题。</strong></p>
</blockquote>
<p><strong>SACK方法(选择性确认)</strong></p>
<p>这种方式需要在 TCP 头部「选项」字段里加一个 <code>SACK</code> 的东西，它<strong>可以将缓存的地图发送给发送方</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong></p>
<p>如下图，发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 <code>SACK</code> 信息发现只有 <code>200~299</code> 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909091602.png" alt=""></p>
<p><strong>Duplicate SACK</strong></p>
<p>Duplicate SACK 又称 <code>D-SACK</code>，其主要<strong>使用了 SACK 来告诉「发送方」有哪些数据被重复接收了</strong></p>
<blockquote>
<ol>
<li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li>
<li>可以知道是不是「发送方」的数据包被网络延迟了;</li>
<li>可以知道网络中是不是把「发送方」的数据包给复制了;</li>
</ol>
</blockquote>
<h3 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h3><p>流量控制是为了控制发送方发送速率，让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。<br>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为0，则发送方不能发送数据。</p>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p><strong>为什么需要滑动窗口：</strong>按数据包进行确认应答的传输方式有一个缺点：数据包的<strong>往返时间越长，通信的效率就越低</strong>。</p>
<p>为解决这个问题，TCP 引入了<strong>窗口</strong>这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。</p>
<p>那么有了窗口，就可以指定窗口大小，窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。</p>
<p>TCP 头里有一个字段叫 <code>Window</code>，也就是窗口大小。</p>
<p><strong>这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来</strong></p>
<p>发送方的滑动窗口</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909103101.png" alt=""></p>
<blockquote>
<ul>
<li>#1 是已发送并收到 ACK确认的数据：1~31 字节</li>
<li>#2 是已发送但未收到 ACK确认的数据：32~45 字节</li>
<li>#3 是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51字节</li>
<li>#4 是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后</li>
</ul>
</blockquote>
<p>接收方的滑动窗口</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909103156.png" alt=""></p>
<blockquote>
<ul>
<li>#1 + #2 是已成功接收并确认的数据（等待应用进程读取）；</li>
<li>#3 是未收到数据但可以接收的数据；</li>
<li>#4 未收到数据并不可以接收的数据</li>
</ul>
</blockquote>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大…</p>
<p>于是，就有了<strong>拥塞控制</strong>，控制的目的就是<strong>避免「发送方」的数据填满整个网络。</strong></p>
<blockquote>
<p><strong>此处引入一个拥塞窗口：</strong><br><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</p>
<p>加入了拥塞窗口的概念后，此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。</p>
</blockquote>
<p><strong>如何判断当前网络是否出现了拥塞</strong></p>
<p>其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是<strong>发生了超时重传，就会认为网络出现了用拥塞。</strong></p>
<p><strong>拥塞控制有哪些控制算法：</strong></p>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>拥塞发生</li>
<li>快速恢复</li>
</ul>
<p><strong>慢启动</strong></p>
<p>慢启动的意思就是一点一点的提高发送数据包的数量，</p>
<p>慢启动的算法记住一个规则就行：<strong>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。</strong></p>
<p>这里假定拥塞窗口 <code>cwnd</code> 和发送窗口 <code>swnd</code> 相等，下面举个栗子：</p>
<ul>
<li>连接建立完成后，一开始初始化 <code>cwnd = 1</code>，表示可以传一个 <code>MSS</code> 大小的数据。</li>
<li>当收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2 个</li>
<li>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以比之前多发2 个，所以这一次能够发送 4 个</li>
<li>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以比之前多发 4 个，所以这一次能够发送 8 个。</li>
</ul>
<blockquote>
<p>慢启动算法，发包的个数是<strong>指数性的增长</strong></p>
</blockquote>
<p>存在一个慢启动门限(ssthresh)状态变量(一般是65535字节)</p>
<ul>
<li>当 <code>cwnd</code> &lt; <code>ssthresh</code> 时，使用慢启动算法。</li>
<li>当 <code>cwnd</code> &gt;= <code>ssthresh</code> 时，就会使用「拥塞避免算法」。</li>
</ul>
<p><strong>拥塞避免</strong></p>
<p>进入拥塞避免算法后，它的规则是：<strong>每当收到一个 ACK 时，cwnd 增加 1/cwnd。</strong></p>
<blockquote>
<ul>
<li>当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 <code>MSS</code> 大小的数据，变成了<strong>线性增长。</strong></li>
</ul>
</blockquote>
<p><strong>拥塞发生</strong></p>
<p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：超时重传；快速重传</p>
<p><strong>超时重传的拥塞发生算法：</strong>当发生了超时重传，则就会使用拥塞发生算法。</p>
<p>这个时候，ssthresh 和 cwnd 的值会发生变化：</p>
<ul>
<li><code>ssthresh</code> 设为 <code>cwnd/2</code>，</li>
<li><code>cwnd</code> 重置为 <code>1</code></li>
</ul>
<blockquote>
<p>接着，就重新开始慢启动，慢启动是会突然减少数据流的。这种方式太激进了，反应也很强烈，会造成网络卡顿。</p>
</blockquote>
<p><strong>快速重传的拥塞发生算法：</strong>当发生快速重传的时候，则使用快速重传的拥塞发生算法</p>
<ul>
<li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li>
<li><code>ssthresh = cwnd</code>;</li>
<li>进入快速恢复算法</li>
</ul>
<p><strong>快速恢复算法</strong></p>
<p>快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 <code>RTO</code> 超时那么强烈。</p>
<ul>
<li>拥塞窗口 <code>cwnd = ssthresh + 3</code> （ 3 的意思是确认有 3 个数据包被收到了）；</li>
<li>重传丢失的数据包；</li>
<li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li>
<li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909151522.png" alt=""></p>
<h3 id="TCP的可靠性"><a href="#TCP的可靠性" class="headerlink" title="TCP的可靠性"></a>TCP的可靠性</h3><p><strong>1. 校验和</strong></p>
<p><strong>计算方式：</strong>检验和是存在于各种报文中的一个字段，它存在的目的是验证报文在网络传输过程中的完整性。因此，在报文的发送端，会根据报文中的首部或数据来计算一个检验和，然后一旦接收端接受到相应报文，接收端也会对报文的首部或数据进行一次检验和计算，如果接收端算出来的检验和和发送端发送的不一样，那么接收端认为报文在传输过程中出了错，于是就丢掉该报文。</p>
<blockquote>
<p>在数据传输的过程中，将发送的数据段都当做一个16 位的整数。将这些整数加起来。并且前面的进位不能丢弃，补在后面，最后取反，得到校验和</p>
</blockquote>
<blockquote>
<p>接收方和发送方校验和比对一致，数据也不一定传输成功。</p>
</blockquote>
<p><strong>2.序列号和确认应答</strong></p>
<p><strong>序列号</strong>：TCP 传输时<strong>将每个字节的数据都进行了编号</strong>，这就是序列号。序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是TCP 传输可靠性的保证之一。</p>
<p><strong>确认应答：</strong>TCP 传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK 报文。这个<strong>ACK 报文当中带有对应的确认序列号</strong>，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。</p>
<p><strong>3. 连接管理：</strong>即TCP建立连接时的三次握手与四次挥手</p>
<p><strong>4. 重传机制</strong>；<strong>5. 流量控制</strong>；<strong>6.拥塞控制</strong></p>
<h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><ol>
<li>TCP 面向连接（如打电话要先拨号建立连接）;UDP 是无连接的，即发送数据之前不需要建立连接</li>
<li>TCP 提供可靠的服务。也就是说，通过TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP 尽最大努力交付，即不保证可靠交付</li>
<li>TCP 面向字节流，实际上是TCP 把数据看成一连串无结构的字节流;UDP 是面向报文的，UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP 电话，实时视频会议等），并且UDP 速度更快</li>
<li>每一条TCP 连接只能是点到点的;UDP 支持一对一，一对多，多对一和多对多的交互通信</li>
<li>TCP 首部开销20 字节;UDP 的首部开销小，只有8 个字节</li>
<li>TCP 的逻辑通信信道是全双工的可靠信道，UDP 则是不可靠信道</li>
</ol>
<h4 id="TCP和UDP的应用"><a href="#TCP和UDP的应用" class="headerlink" title="TCP和UDP的应用"></a>TCP和UDP的应用</h4><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909152412.png" style="zoom:50%;" />

<h3 id="在浏览器输入url地址到显示主页的过程"><a href="#在浏览器输入url地址到显示主页的过程" class="headerlink" title="在浏览器输入url地址到显示主页的过程"></a>在浏览器输入url地址到显示主页的过程</h3><ol>
<li>DNS解析：获取域名对应IP</li>
<li>建立TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>结束连接</li>
</ol>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="HTTP是无状态的协议-如何保存用户状态"><a href="#HTTP是无状态的协议-如何保存用户状态" class="headerlink" title="HTTP是无状态的协议,如何保存用户状态?"></a>HTTP是无状态的协议,如何保存用户状态?</h3><p><code>HTTP</code> 是⼀种不保存状态，即<strong>⽆状态（stateless）协议</strong>。也就是说 HTTP 协议⾃身不对请求和响应之间的通信状态进⾏保存。那么我们保存⽤户状态呢？</p>
<p><code>Session</code>机制的存在就是为了解决这个问题，Session 的主要作⽤就是<strong>通过服务端</strong>记录⽤户的状态。典型的场景是购物⻋，当你要添加商品到购物⻋的时候，系统不知道是哪个⽤户操作的，因为 HTTP 协议是⽆状态的。服务端给特定的⽤户创建特定的 Session 之后就可以标识这个⽤户并且跟踪这个⽤户了（⼀般情况下，服务器会在⼀定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。</p>
<h3 id="Cookie的作用是什么-和Session有什么区别？"><a href="#Cookie的作用是什么-和Session有什么区别？" class="headerlink" title="Cookie的作用是什么?和Session有什么区别？"></a>Cookie的作用是什么?和Session有什么区别？</h3><p>Cookie 和 Session都是⽤来跟踪浏览器⽤户身份的会话⽅式，但是两者的应⽤场景不太⼀样。</p>
<p><strong>Cookie ⼀般⽤来保存⽤户信息，比如：</strong></p>
<ol>
<li>我们在 Cookie 中保存已经登录过得⽤户信息，下次访问⽹站的时候⻚⾯可以⾃动帮你登录的⼀些基本信息给填了；</li>
<li>⼀般的⽹站都会有保持登录也就是 说下次你再访问⽹站的时候就不需要重新登录了，这是因为⽤户登录的时候我们<strong>可以存放了⼀个<code>Token</code> 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找⽤户即可</strong>(为了安全考虑，重新登录⼀般要将 Token 重写)；</li>
<li>登录⼀次⽹站后访问⽹站其他⻚⾯不需要重新登录。</li>
</ol>
<p><strong>Session 的主要作⽤就是通过服务端记录⽤户的状态：</strong>因为 HTTP 协议是⽆状态的。服务端给特定的⽤户创建特定的 Session 之后就可以<strong>标识这个⽤户并且跟踪这个⽤户了。</strong></p>
<blockquote>
<p><code>Cookie</code>保存在客户端，<code>Session</code>数据保存在服务器端</p>
</blockquote>
<h3 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h3><ol>
<li><strong>端口：</strong>HTTP的URL由“http://”起始且默认使⽤端⼝80，⽽HTTPS的URL由“https://”起始且默认使⽤端⼝443。</li>
<li><strong>安全性和资源消耗：</strong> HTTP协议运⾏在TCP之上，所有传输的内容都是明⽂，客户端和服务器端都⽆法验证对⽅的身份。HTTPS是运⾏在SSL/TLS之上的HTTP协议，SSL/TLS 运⾏在TCP之上。所有传输的内容都经过加密，加密采⽤对称加密，但对称加密的密钥⽤服务器⽅的证书进⾏了⾮对称加密。所以说，HTTP 安全性没有 HTTPS⾼，但是 HTTPS ⽐HTTP耗费更多服务器资源。</li>
</ol>
<h3 id="在浏览器输入url地址到显示主页的过程-1"><a href="#在浏览器输入url地址到显示主页的过程-1" class="headerlink" title="在浏览器输入url地址到显示主页的过程"></a>在浏览器输入url地址到显示主页的过程</h3><ol>
<li>DNS解析：获取域名对应IP</li>
<li>建立TCP连接</li>
<li>发生HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>结束连接</li>
</ol>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="JVM-新生代和老年代都使用什么GC算法"><a href="#JVM-新生代和老年代都使用什么GC算法" class="headerlink" title="JVM 新生代和老年代都使用什么GC算法"></a>JVM 新生代和老年代都使用什么GC算法</h3><h4 id="新生代和老年代的区别"><a href="#新生代和老年代的区别" class="headerlink" title="新生代和老年代的区别"></a>新生代和老年代的区别</h4><p><img src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/01d330d8-2710-4fad-a91c-7bbbfaaefc0e.png" alt="img">新生代和老年代是针对于分代收集算法来定义的，新生代又分为Eden 和Survivor 两个区。加上老年代就这三个区。数据会首先分配到Eden 区当中（当然也有特殊情况，<strong>如果是大对象那么会直接放入到老年代</strong>（大对象是指需要大量连续内存空间的java 对象）。），<strong>当Eden没有足够空间的时候就会触发jvm 发起一次Minor GC</strong>。如果对象经过一次Minor GC 还存活，并且又能被Survivor 空间接受，那么将被移动到Survivor 空间当中。并将其年龄设为1，对象在Survivor 每熬过一次Minor GC，年龄就加1，当年龄达到一定的程度（默认为15）时，就会被晋升到老年代中了，当然晋升老年代的年龄是可以设置的。如果老年代满了就执行：Full GC 因为不经常执行，因此采用了Mark-Compact 算法清理。</p>
<p><strong>新生代回收</strong>的判断条件是新生代内存不足时候。新生代主要是用来存放新生的对象，会频繁创建对象，所有垃圾收集会频繁进行回收。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。</p>
<p><strong>新生代使用的算法：复制（Copy）算法</strong><br>将可用内存容量划分为大小相等的两块，每次只用其中一块。当这块内存用完了，就将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。(From到to；to到from)</p>
<blockquote>
<p>优点：不会产生大量不连续的内存空间</p>
<p>缺点：效率也不是很高，需要占用双倍内存空间</p>
</blockquote>
<p><strong>老年代回收的判断条件</strong></p>
<ol>
<li><p><strong>System.gc()方法的调用</strong>，在代码中调用System.gc()方法会<strong>建议</strong>JVM 进行Full GC，在大多数情况下会增加Full GC的次数，导致系统性能下降，一般不建议手动进行此方法的调用。</p>
</li>
<li><p><strong>老年代空间不足</strong>：在Survivor 区域的对象满足晋升到老年代的条件时，晋升进入老年代的对象大小大于老年代的可用内存，这个时候会触发Full GC。</p>
</li>
<li><p><strong>Metaspace 区内存达到阈值：</strong>Metaspace 使用的是本地内存，而不是堆内存，也就是说在默认情况下Metaspace<br>的大小只与本地内存大小有关（约为20.8MB），超过这个值就会引发Full GC，这个值不是固定的，是会随着JVM 的运行进行动态调整的。</p>
</li>
<li><p><strong>堆中产生大对象超过阈值：</strong>大对象或者长期存活的对象进入老年代，典型的大对象就是很长的字符串或者数组，它们在被创建后会直接进入老年代，在要放置的时候JVM 如果发现老年代的空间不足时，会触发GC。</p>
</li>
<li><p><strong>老年代连续空间不足：</strong>JVM 如果判断老年代没有做足够的连续空间来放置大对象，那么就会引起Full GC</p>
</li>
<li><p><strong>统计得到的Minor GC 晋升到旧生代的平均大小大于老年代的剩余空间</strong></p>
<blockquote>
<p>新生代晋升的另外一种情况是如果JVM 发现Survivor 区域中的相同年龄的对象占到所有对象的一半以上时，就会将大于这个年龄的对象移动到老年代，在这批对象在统计后发现可以晋升到老年代，但是发现老年代没有足够的空间来放置这些对象，这就会引起Full GC</p>
</blockquote>
</li>
</ol>
<p><strong>老年代使用的算法</strong></p>
<p><strong>标记清除：</strong></p>
<p>标记清除算法是最基础的回收算法，分为标记和清除两个部分：首先标记出所有需要回收的对象，这一过程<strong>在可达性分析过程中进行</strong>。在标记完之后统一回收所有被标记的对象。</p>
<img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909213741.png" style="zoom:80%;" />

<blockquote>
<p><strong>优点</strong>：速度较快</p>
<p><strong>缺点：</strong>会造成内存碎片，导致在程序运行过程中需要分配较大对象的时候，无法找到足够的连续内存而不得不提前触发一次垃圾收集动作。</p>
</blockquote>
<p><strong>标记整理：</strong></p>
<p>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909213810.png" style="zoom:80%;" />

<blockquote>
<p><strong>优点：</strong>没有内存碎片<br><strong>缺点：</strong>速度慢</p>
</blockquote>
<p><strong>分代垃圾回收：</strong>根据各个年代的特点采取最适当的收集算法</p>
<p>在新生代中，每次垃圾收集时候都发现有大批对象死去，只有少量存活，那就选用复制算法。只需要付出少量存活对象的复制成本就可以完成收集。<br> 老年代中因为对象存活率高、没有额外空间对他进行分配担保，就必须用标记-清除或者标记-整理。</p>
<h4 id="可达性算法分析"><a href="#可达性算法分析" class="headerlink" title="可达性算法分析"></a>可达性算法分析</h4><p>这个算法的基本思想就是通过⼀系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所⾛过的路径称为引⽤链，当⼀个对象到 GC Roots 没有任何引⽤链相连的话，则证明此对象是不可⽤的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20211019091958.png" alt=""></p>
<h3 id="强引用、软引用、弱引用、虚引用"><a href="#强引用、软引用、弱引用、虚引用" class="headerlink" title="强引用、软引用、弱引用、虚引用"></a>强引用、软引用、弱引用、虚引用</h3><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>以前我们使⽤的⼤部分引⽤实际上都是强引⽤，这是使⽤最普遍的引⽤。如果⼀个对象具有强引⽤，那就类似于<strong>必不可少的⽣活⽤品</strong>，垃圾回收器绝不会回收它。当内存空 间不⾜，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终⽌，也不会靠随意回收具有强引⽤的对象来解 决内存不⾜问题</p>
<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>如果⼀个对象只具有软引⽤，那就类似于<strong>可有可⽆的⽣活⽤品</strong>。如果内存空间⾜够，垃圾回收器就不会回收它，如果内存空间不⾜了，就会回收这些对象的内存。只要垃圾回收器没有回收它， 该对象就可以被程序使⽤。软引⽤可⽤来实现内存敏感的⾼速缓存。</p>
<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>如果⼀个对象只具有弱引⽤，那就类似于<strong>可有可⽆的⽣活⽤品</strong>。弱引⽤与软引⽤的区别在于：<strong>只具有弱引⽤的对象拥有更短暂的⽣命周期</strong>。在垃圾回收器线程扫描它所管辖的内存区域的过程  中，<strong>⼀旦发现了只具有弱引⽤的对象，不管当前内存空间⾜够与否，都会回收它的内存</strong>。不过， 由于垃圾回收器是⼀个优先级很低的线程， 因此不⼀定会很快发现那些只具有弱引⽤的对象。</p>
<h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>“虚引⽤”顾名思义，就是形同虚设，与其他⼏种引⽤都不同，虚引⽤并不会决定对象的⽣命周 期。如果⼀个对象仅持有虚引⽤，那么它就和没有任何引⽤⼀样，在任何时候都可能被垃圾回收。</p>
<h3 id="JVM垃圾收集器"><a href="#JVM垃圾收集器" class="headerlink" title="JVM垃圾收集器"></a>JVM垃圾收集器</h3><h4 id="CMS-Concurrent-Mark-Sweep-回收器："><a href="#CMS-Concurrent-Mark-Sweep-回收器：" class="headerlink" title="CMS(Concurrent Mark Sweep)回收器："></a>CMS(Concurrent Mark Sweep)回收器：</h4><p>CMS收集器是一种<strong>以获取最短回收停顿时间为目标的收集器</strong>，是HotSpot虚拟机第一款真正意义上的并发收集器，第一次实现了垃圾收集线程和用户线程基本上同时工作</p>
<p>CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，整个过程分为四个步骤：</p>
<ol>
<li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li>
<li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>
<li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li>
<li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210910143806.png" alt=""></p>
<blockquote>
<p><strong>缺点：</strong></p>
<ol>
<li><p>对 CPU 资源敏感；</p>
</li>
<li><p>无法处理浮动垃圾，CMS 在并发清理阶段线程还在运行， 伴随着程序的运行自然也会产生新的垃圾，这一部分垃圾产生在标记过程之后，CMS 无法再当次过程中处理，所以只有等到下次gc 时候在清理掉。</p>
</li>
<li><p>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</p>
</li>
</ol>
</blockquote>
<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p><strong>G1 (Garbage-First)</strong> 是一款<strong>面向服务器的垃圾收集器</strong>,主要针对配备多颗处理器及大容量内存的机器. 以<strong>极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p>
<p>G1 可面向<strong>堆任何部分</strong>来组成回收集进行回收，<strong>衡量标准不再是分代</strong>，而是哪块内存中存放的垃圾数量最多，回收受益最大。</p>
<p><strong>G1的特点：</strong></p>
<ol>
<li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li>
<li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li>
<li><strong>空间整合</strong>：与 CMS 的“标记-清理”算法不同，G1 从<strong>整体来看是基于“标记-整理”算法</strong>实现的收集器；从<strong>局部上来看是基于“标记-复制”</strong>算法实现的。</li>
<li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li>
</ol>
<p><strong>G1运作步骤：</strong></p>
<ol>
<li><strong>初始标记：</strong>标记GC Roots 能直接关联到的对象</li>
<li><strong>并发标记：</strong>从GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆的对象图</li>
<li><strong>最终标记：</strong>对用户线程做短暂暂停，处理并发阶段结束后仍遗留下来的少量SATB 记录</li>
<li><strong>筛选回收：</strong>对各Region 的回收价值排序，根据用户期望停顿时间制定回收计划。必须暂停用户线程，由多条收集线程并行完成。</li>
</ol>
<blockquote>
<p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>
</blockquote>
<h4 id="其他收集器"><a href="#其他收集器" class="headerlink" title="其他收集器"></a>其他收集器</h4><p><strong>Serial收集器:</strong> 单线程收集器，收集垃圾时，<strong>必须暂停其他所有的工作线程</strong>（stop the world），<strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p>
<p><strong>ParNew 收集器：</strong>其实就<strong>是 Serial 收集器的多线程版本</strong>，除了使用多线程进行垃圾收集外，其余行为和 Serial 收集器完全一样。(只有Serial和ParNew可以和CMS配合工作)</p>
<p><strong>Parallel Scavenge收集器：</strong>新生代收集器，基于复制算法，是可并行的多线程收集器，与ParNew 类似。特点是它的<br>关注点与其他收集器不同，Parallel Scavenge 的目标是达到一个可控制的吞吐量，所谓吞吐量就是处理器用于运行用户代码的时间与处理器消耗总时间的比值</p>
<p><strong>Serial Old</strong>:Serial 收集器的老年代版本，它同样是一个单线程收集器,采用标记-整理算法</p>
<p><strong>Parnew Old:</strong>Parallel Scavenge 收集器的老年代版本**。使用多线程和“标记-整理”算法</p>
<h3 id="JVM-GC调优"><a href="#JVM-GC调优" class="headerlink" title="JVM GC调优"></a>JVM GC调优</h3><p><strong>参数基本策略：</strong></p>
<p>各分区的大小对GC的性能影响很大。如何将各分区调整到合适的大小，分析活跃数据的大小是很好的切入点。</p>
<p><strong>活跃数据的大小</strong>是指，应用程序稳定运行时长期存活对象在堆中占用的空间大小，也就是Full GC后堆中老年代占用空间的大小。可以通过GC日志中Full GC之后老年代数据大小得出</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210911100540.png" alt=""></p>
<p>例如，根据GC日志获得老年代的活跃数据大小为300M，那么各分区大小可以设为：</p>
<blockquote>
<p>总堆：1200MB = 300MB × 4* 新生代：450MB = 300MB × 1.5* 老年代： 750MB = 1200MB - 450MB*</p>
</blockquote>
<p><strong>这部分设置仅仅是堆大小的初始值，后面的优化中，可能会调整这些值，具体情况取决于应用程序的特性和需求。</strong></p>
<p>GC优化一般步骤可以概括为：确定目标、优化参数、验收结果。</p>
<p><strong>确定目标：</strong>低延迟还是高吞吐量</p>
<p><strong>优化参数：</strong>结合需求选用合适的GC回收器、重新设置内存比例、调整JVM参数</p>
<h4 id="Minor-GC和Major-GC频繁"><a href="#Minor-GC和Major-GC频繁" class="headerlink" title="Minor GC和Major GC频繁"></a>Minor GC和Major GC频繁</h4><p><strong>优化</strong></p>
<p>首先优化Minor GC频繁问题。通常情况下，由于新生代空间较小，Eden区很快被填满，就会导致频繁Minor GC，因此可以通过增大新生代空间来降低Minor GC的频率。例如在相同的内存分配率的前提下，新生代中的Eden区增加一倍，Minor GC的次数就会减少一半。</p>
<p><strong>扩容Eden区虽然可以减少Minor GC的次数，但会增加单次Minor GC时间么</strong>？我们结合下面情况来分析，单次Minor GC时间主要受哪些因素影响？是否和新生代大小存在线性关系？ 首先，单次Minor GC时间由以下两部分组成：T1（扫描新生代）和 T2（复制存活对象到Survivor区）如下图。（注：这里为了简化问题，我们认为T1只扫描新生代判断对象是否存活的时间，其实该阶段还需要扫描部分老年代）</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/6eb9b856.png" alt="img"></p>
<ul>
<li>扩容前：新生代容量为R ，假设对象A的存活时间为750ms，Minor GC间隔500ms，那么本次Minor GC时间= T1（扫描新生代R）+T2（复制对象A到S）。</li>
<li>扩容后：新生代容量为2R ，对象A的生命周期为750ms，那么Minor GC间隔增加为1000ms，此时Minor GC对象A已不再存活，不需要把它复制到Survivor区，那么本次GC时间 = 2 × T1（扫描新生代R），没有T2复制时间。</li>
</ul>
<p>可见，扩容后，Minor GC时增加了T1（扫描时间），但省去T2（复制对象）的时间，更重要的是对于虚拟机来说，复制对象的成本要远高于扫描成本，所以，单次<strong>Minor GC时间更多取决于GC后存活对象的数量，而非Eden区的大小</strong>。因此<strong>如果堆中短期对象很多，那么扩容新生代，单次Minor GC时间不会显著增加</strong>。下面需要确认下服务中对象的生命周期分布情况：<strong>对象生命周期的分布情况：如果应用存在大量的短期对象，应该选择较大的年轻代；如果存在相对较多的持久对象，老年代应该适当增大。</strong></p>
<h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210910164815.png" alt=""></p>
<p><strong>加载：</strong>类加载过程的第一步，主要完成下面 3 件事情：</p>
<ol>
<li>通过全类名获取定义此类的二进制字节流</li>
<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口</li>
</ol>
<p><strong>连接：</strong></p>
<ol>
<li><strong>验证：</strong>验证加载进来的数据是否符合虚拟机的规范，并且不会危害JVM虚拟机的安全。验证包括文件格式验证，元数据验证，字节码验证，符号引用验证。</li>
<li><strong>准备：</strong>给<strong>静态变量</strong>分配内存空间，并设置默认值；给<strong>静态常量</strong>直接赋初值。</li>
<li><strong>解析：</strong>解析过程是将常量池内的符号引用替换成直接引用。主要包括四种类型引用的解析。类或接口的解析、字段解析、方法解析、接口方法解析.</li>
</ol>
<p><strong>初始化：</strong>执行给类变量赋值和执行静态代码块里面的内容，<strong>如果这个类继承了父类，那么先执行父类的类变量赋值和静态代码块的内容</strong></p>
<blockquote>
<p><strong>数组类型不通过类加载器创建，它由 Java 虚拟机直接创建</strong></p>
</blockquote>
<h4 id="知道哪些类加载器"><a href="#知道哪些类加载器" class="headerlink" title="知道哪些类加载器"></a>知道哪些类加载器</h4><p>JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>：</p>
<ol>
<li><strong>BootstrapClassLoader(启动类加载器)</strong> ：最顶层的加载类，由 C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的 jar 包和类或者被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</li>
<li><strong>ExtensionClassLoader(扩展类加载器)</strong> ：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的 jar 包。</li>
<li><strong>AppClassLoader(应用程序类加载器)</strong> ：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</li>
</ol>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>每一个类都有一个对应它的类加载器。系统中的 ClassLoader 在协同工作的时候会默认使用 <strong>双亲委派模型</strong> 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派给父类加载器的 <code>loadClass()</code> 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器。</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210910165114.png" alt=""></p>
<blockquote>
<p><code>AppClassLoader</code>的父类加载器为<code>ExtClassLoader</code>， <code>ExtClassLoader</code>的父类加载器为 null，<strong>null 并不代表<code>ExtClassLoader</code>没有父类加载器，而是 <code>BootstrapClassLoader</code></strong> </p>
</blockquote>
<p><strong>双亲委派模型的好处</strong></p>
<p>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现多个不同的 <code>Object</code> 类。</p>
<p><strong>如果不想使用双亲委派模型</strong></p>
<p>为了避免双亲委派模型，可以自定义一个类加载器，然后重载loadClass()</p>
<p><strong>如何自定义类加载器</strong></p>
<p>除了BootStrapClassLoader,其他类加载器均由Java实现，且全部继承自Java.lang.ClassLoader，如果要自定义类加载器，需要继承ClassLoader。</p>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag"># 多线程</a>
          
            <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag"># 计算机网络</a>
          
            <a href="/tags/redis/" rel="tag"># redis</a>
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/MySQL/" rel="tag"># MySQL</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/10/14/DiskGenius%E7%A3%81%E7%9B%98%E5%88%92%E5%88%86/" rel="next" title="DiskGenius磁盘划分">
                <i class="fa fa-chevron-left"></i> DiskGenius磁盘划分
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
     <div id="gitalk-container"></div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/bear.png"
                alt="摸鱼选手Wei" />
            
              <p class="site-author-name" itemprop="name">摸鱼选手Wei</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/CloudMadao" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          
		  
		  

  <div class="links-of-blogroll motion-element links-of-blogroll-block">
   <div class="links-of-blogroll-title">
     <!-- modify icon to fire by szw -->
     <i class="fa fa-history fa-" aria-hidden="true"></i>
     近期文章
   </div>
   <ul class="links-of-blogroll-list">
     
     
       <li>
         <a href="/2021/10/18/Java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/" title="Java面试八股" target="_blank">Java面试八股</a>
       </li>
     
       <li>
         <a href="/2021/10/14/DiskGenius%E7%A3%81%E7%9B%98%E5%88%92%E5%88%86/" title="DiskGenius磁盘划分" target="_blank">DiskGenius磁盘划分</a>
       </li>
     
       <li>
         <a href="/2021/10/13/EndNote%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/" title="EndNote使用指北" target="_blank">EndNote使用指北</a>
       </li>
     
       <li>
         <a href="/2021/09/10/java%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/" title="java面试笔记" target="_blank">java面试笔记</a>
       </li>
     
       <li>
         <a href="/2020/05/29/%E8%AE%B0%E4%B8%80%E6%AC%A1CentOs7%E4%B8%8A%E5%AE%89%E8%A3%85Oracle%E7%9A%84%E8%B8%A9%E5%9D%91%E8%BF%87%E7%A8%8B/" title="记一次CentOs7上安装Oracle的踩坑过程" target="_blank">记一次CentOs7上安装Oracle的踩坑过程</a>
       </li>
     
   </ul>
  </div>
 
  
           
         
         
<div style="">
  <canvas id="canvas" style="width:60%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
</div>
<script>
(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();
</script>
        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java面试八股"><span class="nav-number">1.</span> <span class="nav-text">Java面试八股</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap"><span class="nav-number">2.</span> <span class="nav-text">HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-1"><span class="nav-number">2.1.</span> <span class="nav-text">HashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap的长度为什么是2的幂次"><span class="nav-number">2.2.</span> <span class="nav-text">HashMap的长度为什么是2的幂次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap线程不安全在哪"><span class="nav-number">2.3.</span> <span class="nav-text">HashMap线程不安全在哪</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap和TreeMap"><span class="nav-number">2.4.</span> <span class="nav-text">HashMap和TreeMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap和HashSet"><span class="nav-number">2.5.</span> <span class="nav-text">HashMap和HashSet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合的选用"><span class="nav-number">2.6.</span> <span class="nav-text">集合的选用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程"><span class="nav-number">3.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程与进程"><span class="nav-number">3.1.</span> <span class="nav-text">线程与进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#程序计数器为什么私有"><span class="nav-number">3.1.1.</span> <span class="nav-text">程序计数器为什么私有</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟机栈和本地方法栈为什么私有"><span class="nav-number">3.1.2.</span> <span class="nav-text">虚拟机栈和本地方法栈为什么私有</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆和方法区"><span class="nav-number">3.1.3.</span> <span class="nav-text">堆和方法区</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程的生命周期"><span class="nav-number">3.2.</span> <span class="nav-text">线程的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多线程中的上下文切换"><span class="nav-number">3.3.</span> <span class="nav-text">多线程中的上下文切换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁"><span class="nav-number">3.4.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#如何避免死锁"><span class="nav-number">3.4.1.</span> <span class="nav-text">如何避免死锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep-方法和wait-方法区别和共同点"><span class="nav-number">3.5.</span> <span class="nav-text">sleep()方法和wait()方法区别和共同点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调用start-时会执行run-为什么不直接执行run"><span class="nav-number">3.6.</span> <span class="nav-text">调用start()时会执行run(),为什么不直接执行run()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized关键字"><span class="nav-number">3.7.</span> <span class="nav-text">synchronized关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized关键字的使用"><span class="nav-number">3.7.1.</span> <span class="nav-text">synchronized关键字的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized关键字和volatile关键字的区别"><span class="nav-number">3.7.2.</span> <span class="nav-text">synchronized关键字和volatile关键字的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized关键字和Lock的区别"><span class="nav-number">3.7.3.</span> <span class="nav-text">synchronized关键字和Lock的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池"><span class="nav-number">3.8.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用线程池的好处："><span class="nav-number">3.8.1.</span> <span class="nav-text">使用线程池的好处：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何创建线程池"><span class="nav-number">3.8.2.</span> <span class="nav-text">如何创建线程池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadPoolExecutor构造函数参数"><span class="nav-number">3.8.3.</span> <span class="nav-text">ThreadPoolExecutor构造函数参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多线程开发带来的问题与解决办法"><span class="nav-number">3.9.</span> <span class="nav-text">多线程开发带来的问题与解决办法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程安全问题："><span class="nav-number">3.9.1.</span> <span class="nav-text">线程安全问题：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#性能问题"><span class="nav-number">3.9.2.</span> <span class="nav-text">性能问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重入锁"><span class="nav-number">3.10.</span> <span class="nav-text">重入锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS-AbstractQueuedSynchronizer"><span class="nav-number">3.11.</span> <span class="nav-text">AQS(AbstractQueuedSynchronizer)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AQS原理概览"><span class="nav-number">3.11.1.</span> <span class="nav-text">AQS原理概览</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单例模式"><span class="nav-number">3.12.</span> <span class="nav-text">单例模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-IP"><span class="nav-number">4.</span> <span class="nav-text">TCP&#x2F;IP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#三次握手的过程"><span class="nav-number">4.1.</span> <span class="nav-text">三次握手的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么TCP客户端最后还要发送一次确认呢"><span class="nav-number">4.1.1.</span> <span class="nav-text">为什么TCP客户端最后还要发送一次确认呢?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四次挥手的过程"><span class="nav-number">4.2.</span> <span class="nav-text">四次挥手的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么建立连接是三次握手，释放连接确实四次挥手？"><span class="nav-number">4.2.1.</span> <span class="nav-text">为什么建立连接是三次握手，释放连接确实四次挥手？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三次握手过程中可以携带数据嘛"><span class="nav-number">4.3.</span> <span class="nav-text">三次握手过程中可以携带数据嘛</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如果已经建立连接，但是客户端出现故障-TCP的保活机制-keapalive长连接"><span class="nav-number">4.4.</span> <span class="nav-text">如果已经建立连接，但是客户端出现故障(TCP的保活机制)(keapalive长连接)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP的重传机制"><span class="nav-number">4.5.</span> <span class="nav-text">TCP的重传机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP的流量控制"><span class="nav-number">4.6.</span> <span class="nav-text">TCP的流量控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#滑动窗口"><span class="nav-number">4.6.1.</span> <span class="nav-text">滑动窗口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拥塞控制"><span class="nav-number">4.7.</span> <span class="nav-text">拥塞控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP的可靠性"><span class="nav-number">4.8.</span> <span class="nav-text">TCP的可靠性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP和UDP的区别"><span class="nav-number">4.9.</span> <span class="nav-text">TCP和UDP的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP和UDP的应用"><span class="nav-number">4.9.1.</span> <span class="nav-text">TCP和UDP的应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在浏览器输入url地址到显示主页的过程"><span class="nav-number">4.10.</span> <span class="nav-text">在浏览器输入url地址到显示主页的过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP"><span class="nav-number">5.</span> <span class="nav-text">HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP是无状态的协议-如何保存用户状态"><span class="nav-number">5.1.</span> <span class="nav-text">HTTP是无状态的协议,如何保存用户状态?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cookie的作用是什么-和Session有什么区别？"><span class="nav-number">5.2.</span> <span class="nav-text">Cookie的作用是什么?和Session有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP和HTTPS的区别"><span class="nav-number">5.3.</span> <span class="nav-text">HTTP和HTTPS的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在浏览器输入url地址到显示主页的过程-1"><span class="nav-number">5.4.</span> <span class="nav-text">在浏览器输入url地址到显示主页的过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM"><span class="nav-number">6.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM-新生代和老年代都使用什么GC算法"><span class="nav-number">6.1.</span> <span class="nav-text">JVM 新生代和老年代都使用什么GC算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#新生代和老年代的区别"><span class="nav-number">6.1.1.</span> <span class="nav-text">新生代和老年代的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可达性算法分析"><span class="nav-number">6.1.2.</span> <span class="nav-text">可达性算法分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#强引用、软引用、弱引用、虚引用"><span class="nav-number">6.2.</span> <span class="nav-text">强引用、软引用、弱引用、虚引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#强引用"><span class="nav-number">6.2.1.</span> <span class="nav-text">强引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#软引用"><span class="nav-number">6.2.2.</span> <span class="nav-text">软引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#弱引用"><span class="nav-number">6.2.3.</span> <span class="nav-text">弱引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚引用"><span class="nav-number">6.2.4.</span> <span class="nav-text">虚引用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM垃圾收集器"><span class="nav-number">6.3.</span> <span class="nav-text">JVM垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CMS-Concurrent-Mark-Sweep-回收器："><span class="nav-number">6.3.1.</span> <span class="nav-text">CMS(Concurrent Mark Sweep)回收器：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#G1收集器"><span class="nav-number">6.3.2.</span> <span class="nav-text">G1收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他收集器"><span class="nav-number">6.3.3.</span> <span class="nav-text">其他收集器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM-GC调优"><span class="nav-number">6.4.</span> <span class="nav-text">JVM GC调优</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Minor-GC和Major-GC频繁"><span class="nav-number">6.4.1.</span> <span class="nav-text">Minor GC和Major GC频繁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类加载机制"><span class="nav-number">6.5.</span> <span class="nav-text">类加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#知道哪些类加载器"><span class="nav-number">6.5.1.</span> <span class="nav-text">知道哪些类加载器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#双亲委派模型"><span class="nav-number">6.5.2.</span> <span class="nav-text">双亲委派模型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring"><span class="nav-number">7.</span> <span class="nav-text">Spring</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis"><span class="nav-number">8.</span> <span class="nav-text">Redis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL"><span class="nav-number">9.</span> <span class="nav-text">MySQL</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
          


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">摸鱼选手Wei</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        
<div class="busuanzi-count">
 <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
	<script src="/js/md5.min.js"></script>
    <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: '189bc28497572ad87947',
          clientSecret: '084a899efcea3646e7ee9ba066db2f077b3b403a',
          repo: 'Blog-Comments',
          owner: 'CloudMadao',
          admin: ['CloudMadao'],
          id: decodeURI(location.pathname),
          distractionFreeMode: 'false'
        })
        gitalk.render('gitalk-container')           
    </script>

  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
