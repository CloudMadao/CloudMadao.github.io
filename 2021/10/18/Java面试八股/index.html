<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="Zfds7O_oYzbVPUTriZY6nqorXSh6sLoYR_zd0WKwBzQ" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Comic Sans MS:300,300italic,400,400italic,700,700italic|Lato:300,300italic,400,400italic,700,700italic|Consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/horse.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/horse.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/horse.png?v=5.1.4">


  <link rel="mask-icon" href="/images/horse.png?v=5.1.4" color="#222">





  <meta name="keywords" content="多线程,计算机网络,redis,Java,MySQL," />










<meta name="description" content="Java面试八股 希望HR知道我的邮箱除了用来收感谢信也是可以用来收offer的">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面试八股">
<meta property="og:url" content="https://cloudmadao.github.io/2021/10/18/Java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/index.html">
<meta property="og:site_name" content="Madao&#39;s Personal Website">
<meta property="og:description" content="Java面试八股 希望HR知道我的邮箱除了用来收感谢信也是可以用来收offer的">
<meta property="og:image" content="https://img.php.cn/upload/article/000/000/028/5c73a16ef1c04585.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210911092310.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20211018110930.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20211018164548.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20211018170740.png">
<meta property="og:image" content="https://camo.githubusercontent.com/02e863f3d5de3c34484f6162c1d0b3bf8912dbd70ac0a672bb99724f1f47f2d8/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f4a6176612532302545372541382538422545352542412538462545352539312539382545352542462538352545352541342538372545462542432539412545352542392542362545352538462539312545372539462541352545382541462538362545372542332542422545372542422539462545362538302542422545372542422539332f434c482e706e67">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20200409195521.jfif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20200409212059.jfif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909091033.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909091602.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909103101.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909103156.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909151522.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909152412.png">
<meta property="og:image" content="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/01d330d8-2710-4fad-a91c-7bbbfaaefc0e.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909213741.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909213810.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20211019091958.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210910143806.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210911100540.png">
<meta property="og:image" content="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/6eb9b856.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210910164815.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210910165114.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20211020170241.png">
<meta property="og:image" content="https://camo.githubusercontent.com/0fd35900c32b252a18ff38855ae52192f90f8884f1622bb5f92578fe68c6cb2f/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f64653664326232313366313132323937323938663365323233626630386632382e706e67">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20211020193524.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210914095535.png">
<meta property="og:image" content="https://camo.githubusercontent.com/d9c8448f21fb27f4565e846dc1b63077c01f3e27e03764940f4e1b8ec4731514/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f323032302d31322f3634302d32303230313230373136303535343637372e706e67">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20211020203359.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210908191952.png">
<meta property="article:published_time" content="2021-10-18T14:49:05.000Z">
<meta property="article:modified_time" content="2021-10-20T14:04:31.881Z">
<meta property="article:author" content="摸鱼选手Wei">
<meta property="article:tag" content="多线程">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="redis">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.php.cn/upload/article/000/000/028/5c73a16ef1c04585.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://CloudMadao.github.io/2021/10/18/Java面试八股/"/>





  <title>Java面试八股 | Madao's Personal Website</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Madao's Personal Website</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">今天 <s>摸鱼</s> 学习了吗</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://CloudMadao.github.io/2021/10/18/Java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="摸鱼选手Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/bear.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Madao's Personal Website">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Java面试八股</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-10-18T22:49:05+08:00">
                2021-10-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Java面试八股"><a href="#Java面试八股" class="headerlink" title="Java面试八股"></a>Java面试八股</h2><blockquote>
<p>希望HR知道我的邮箱除了用来收感谢信也是可以用来收offer的</p>
</blockquote>
<a id="more"></a>

<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p><img src="https://img.php.cn/upload/article/000/000/028/5c73a16ef1c04585.jpg" alt="img"></p>
<h3 id="HashMap-1"><a href="#HashMap-1" class="headerlink" title="HashMap"></a>HashMap</h3><ul>
<li><p>HashMap实现了Map接口，线程非安全，其线程安全版本为ConcurrentHashMap</p>
</li>
<li><p>HashMap可以存储<code>null</code>的key和value，但是null作为键的时候只能存在一个，作为值的时候可以有多个null。</p>
</li>
<li><p>HashMap默认初始化大小为<code>16</code>，每次扩容会扩容为原来的2倍</p>
<blockquote>
<p>如果给定HashMap的初始容量，HashMap会将其扩充为2的幂次方。</p>
</blockquote>
</li>
<li><p>HashMap在1.8之后使用<code>链表+红黑树</code>的结构， 当链表⻓度⼤于阈值（默认为 8)时，将链表转化为红⿊树，当树的节点数小于等于6时，转为链表，以 减少搜索时间。</p>
<p><strong>解决Hash冲突的办法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开放地址</span><br><span class="line">建立公共溢出区</span><br><span class="line">再哈希：发生Hash冲突的时候再进行一次Hash，缺点是每次冲突都要再Hash，时间成本增加</span><br><span class="line">拉链法：将Hash冲突的同义词存储在同一个线性链表中 缺点是需要额外的空间</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="HashMap的长度为什么是2的幂次"><a href="#HashMap的长度为什么是2的幂次" class="headerlink" title="HashMap的长度为什么是2的幂次"></a>HashMap的长度为什么是2的幂次</h3><p>为了能让 HashMap 存取⾼效，尽量较少碰撞，也就是要尽量把数据分配均匀。在使用散列值之前要先做对数组的⻓度取模运算，得到的余数才能⽤来要存放的位置，也就是对应的数组下标。这个数组下标的计算⽅法是“ (n - 1) &amp; hash ”。</p>
<p><strong>这个算法应该如何设计呢？</strong><br>我们⾸先可能会想到采⽤%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减⼀的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的n 次⽅；）。” 并且 采⽤⼆进制位操作 &amp;，相对于%能够提⾼运算效率，这就解释了 HashMap 的⻓度为什么是2的幂次⽅。</p>
<h3 id="HashMap线程不安全在哪"><a href="#HashMap线程不安全在哪" class="headerlink" title="HashMap线程不安全在哪"></a>HashMap线程不安全在哪</h3><ol>
<li><strong>数据丢失：</strong></li>
<li><strong>数据重复：</strong></li>
<li><strong>扩容时可能死循环(JDK1.7)：</strong>Hashmap 在多线程的情况下扩容由于链表的数据转换采用的是头插法所以会造成死循环的问题。而在jdk1.8中则进行了优化直接将原链表数据放到新数组中，不会造成死循环。</li>
</ol>
<h3 id="HashMap和TreeMap"><a href="#HashMap和TreeMap" class="headerlink" title="HashMap和TreeMap"></a>HashMap和TreeMap</h3><p>TreeMap底层使用红黑树实现，线程非安全，<strong>不允许null，key不可以重复，value允许重复</strong>，存入TreeMap的元素应当实现Comparable接口或者实现Comparator接口，会按照排序后的顺序迭代元素。<strong>主要用于存入元素的时候对元素进行自动排序</strong>，迭代输出的时候就按排序顺序输出。</p>
<h3 id="HashMap和HashSet"><a href="#HashMap和HashSet" class="headerlink" title="HashMap和HashSet"></a>HashMap和HashSet</h3><p>HashSet底层基于HashMap实现</p>
<table>
<thead>
<tr>
<th align="center">HashMap</th>
<th align="center">HashSet</th>
</tr>
</thead>
<tbody><tr>
<td align="center">实现Map接口</td>
<td align="center">实现Set接口</td>
</tr>
<tr>
<td align="center">存储键值对</td>
<td align="center">仅存储对象</td>
</tr>
<tr>
<td align="center">put()向Map中添加元素</td>
<td align="center">add()向Set中添加元素</td>
</tr>
<tr>
<td align="center">HashMap使用键(Key)计算hashcode</td>
<td align="center">HashSet使用成员对象来计算hashcode，对于两个对象来说先比较hashcode，相同时再使用<code>equals()</code>方法判断两个对象是否相等</td>
</tr>
</tbody></table>
<h3 id="集合的选用"><a href="#集合的选用" class="headerlink" title="集合的选用"></a>集合的选用</h3><p>主要根据集合的特点来选用集合，比如我们需要根据键值获取到元素值时就选⽤<code>Map</code>接口下的集合，需要排序时选用<code>TreeMap</code>,不需要排序时就选择<code>HashMap</code>,需要保证线程安全就选⽤<code>ConcurrentHashMap</code>。</p>
<p>当我们只需要存放元素值时，就选择实现<code>Collection</code>接口下的集合，需要保证元素唯⼀时选择实现<code>Set</code>接口的集合，不需要时就选择实现<code>List</code>接口的集合，然后再根据实现这些接⼝的集合的特点来选⽤。</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210911092310.png" style="zoom:80%;" />

<p>⼀个进程中可以有多个线程，多个线程共享进程的<strong>堆和方法区资源</strong>，但是每个线程有⾃⼰的<strong>程序计数器</strong>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p>
<p><strong>总结：</strong> 线程 是 进程 划分成的更⼩的运⾏单位。线程和进程最⼤的不同在于基本上各进程是独⽴的，⽽各线程则不⼀定，因为同⼀进程中的线程极有可能会相互影响。线程执⾏开销小，但不利于资源的管理和保护；而进程则相反。</p>
<h4 id="程序计数器为什么私有"><a href="#程序计数器为什么私有" class="headerlink" title="程序计数器为什么私有"></a>程序计数器为什么私有</h4><p>程序计数器主要有下面两个作用：</p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执⾏的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<h4 id="虚拟机栈和本地方法栈为什么私有"><a href="#虚拟机栈和本地方法栈为什么私有" class="headerlink" title="虚拟机栈和本地方法栈为什么私有"></a>虚拟机栈和本地方法栈为什么私有</h4><ul>
<li><p><strong>虚拟机栈：</strong>每个 Java ⽅法在执⾏的同时会创建⼀个栈帧⽤于存储局部变量表、操作数栈、常量池引⽤等信息。从⽅法调⽤直⾄执⾏完成的过程，就对应着⼀个栈帧在 Java 虚拟机栈中⼊栈和出栈的过程。</p>
</li>
<li><p><strong>本地方法栈：</strong>和虚拟机栈所发挥的作⽤⾮常相似，区别是： <strong>虚拟机栈为虚拟机执⾏ Java⽅法 （也就是字节码）服务，⽽本地⽅法栈则为虚拟机使⽤到的 Native ⽅法服务</strong>。 在HotSpot 虚拟机中和 Java 虚拟机栈合⼆为⼀。</p>
<blockquote>
<p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地⽅法栈是线程私有的。</p>
</blockquote>
</li>
</ul>
<h4 id="堆和方法区"><a href="#堆和方法区" class="headerlink" title="堆和方法区"></a>堆和方法区</h4><p>堆和⽅法区是所有线程共享的资源，其中堆是进程中最⼤的⼀块内存，主要⽤于存放新创建的对象 (所有对象都在这⾥分配内存)，⽅法区主要⽤于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p>线程的生命周期包含5个阶段，包括：<strong>新建、就绪、运行、阻塞、销毁</strong>。</p>
<ul>
<li>新建：就是刚使用new方法，new出来的线程；</li>
<li>就绪：就是调用的线程的start()方法后，这时候线程处于等待CPU分配资源阶段，谁先抢的CPU资源，谁开始执行;</li>
<li>运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run方法定义了线程的操作和功能;</li>
<li>阻塞：在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态，比如sleep()、wait()之后线程就处于了阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用notify或者notifyAll()方法。唤醒的线程不会立刻执行run方法，它们要再次等待CPU分配资源进入运行状态;</li>
<li>销毁：如果线程正常执行完毕后或线程被提前强制性的终止或出现异常导致结束，那么线程就要被销毁，释放资源;</li>
</ul>
<h3 id="多线程中的上下文切换"><a href="#多线程中的上下文切换" class="headerlink" title="多线程中的上下文切换"></a>多线程中的上下文切换</h3><p>多线程编程中⼀般线程的个数都⼤于 CPU 核⼼的个数，⽽⼀个 CPU 核⼼在任意时刻只能被⼀个线程使⽤，为了让这些线程都能得到有效执⾏，CPU 采取的策略是为每个线程分配时间⽚并轮转的形式。当⼀个线程的时间⽚⽤完的时候就会重新处于就绪状态让给其他线程使⽤，这个过程就 属于⼀次上下⽂切换。</p>
<p>概括来说就是：当前任务在执⾏完 CPU 时间⽚切换到另⼀个任务之前会先保存⾃⼰的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是⼀次上下文切换</strong>。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>线程死锁描述的是这样⼀种情况：多个线程同时被阻塞，它们中的⼀个或者全部都在等待某个资源被释放。由于线程被⽆限期地阻塞，因此程序不可能正常终⽌。</p>
<p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对⽅的资源，所以这两个线程就会互相等待⽽进⼊死锁状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20211018110930.png" alt=""></p>
<p><strong>死锁产生的条件必须具备以下四个条件：</strong></p>
<ol>
<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h4 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h4><p>为了避免死锁，我们只要破坏产⽣死锁的四个条件中的其中⼀个就可以了。现在我们来挨个分析⼀下：</p>
<ol>
<li><strong>破坏互斥条件</strong> ：这个条件我们没有办法破坏，因为我们⽤锁本来就是想让他们互斥的（临界资源需要互斥访问）。</li>
<li><strong>破坏请求与保持条件</strong> ：⼀次性申请所有的资源。</li>
<li><strong>破坏不剥夺条件</strong>：占⽤部分资源的线程进⼀步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某⼀顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>
</ol>
<blockquote>
<p>想要避免死锁，可以<strong>使用无锁函数</strong>（cas）<strong>或者使用重入锁（ReentrantLock），通过重入锁使线程中断或限时等待可以有效的规避死锁问题</strong>。</p>
</blockquote>
<h3 id="sleep-方法和wait-方法区别和共同点"><a href="#sleep-方法和wait-方法区别和共同点" class="headerlink" title="sleep()方法和wait()方法区别和共同点"></a>sleep()方法和wait()方法区别和共同点</h3><p><strong>共同点：</strong>两者都可以暂停线程的执行，都会让线程进入等待状态。</p>
<p><strong>不同点：</strong></p>
<ul>
<li><strong>sleep()方法没有释放锁，而 wait()方法释放了锁。(主要)</strong></li>
<li>sleep()方法属于Thread类的静态方法，作用于当前线程；而wait()方法是Object类的实例方法，作用于对象本身。</li>
<li>执行sleep()方法后，可以通过超时或者调用interrupt()方法唤醒休眠中的线程；执行wait()方法后，通过调用notify()或notifyAll()方法唤醒等待线程。</li>
</ul>
<h3 id="调用start-时会执行run-为什么不直接执行run"><a href="#调用start-时会执行run-为什么不直接执行run" class="headerlink" title="调用start()时会执行run(),为什么不直接执行run()"></a>调用start()时会执行run(),为什么不直接执行run()</h3><p>new 一个 Thread，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p><strong>总结： 调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p>
<h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h3><h4 id="synchronized关键字的使用"><a href="#synchronized关键字的使用" class="headerlink" title="synchronized关键字的使用"></a>synchronized关键字的使用</h4><ol>
<li><p><strong>修饰实例方法:</strong> 作⽤于当前对象实例加锁，进⼊同步代码前要获得 <strong>当前对象实例的锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>修饰静态方法</strong>： 也就是给当前类加锁，会作⽤于类的所有对象实例 ，进⼊同步代码前要获得 当前<code>class</code>的锁。因为静态成员不属于任何⼀个实例对象，是类成员。所以，如果⼀个线程 A 调⽤⼀个实例对象的⾮静态<code>synchronized</code> ⽅法，⽽线程 B 需要调⽤这个实例对象所属类的静态<code>synchronized</code> ⽅法，是允许的，不会发⽣互斥现象，<strong>因为访问静态<code>synchronized</code>⽅法占⽤的锁是当前类的锁，⽽访问⾮静态⽅法占⽤的锁是当前实例对象锁。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> staic <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>修饰代码块：</strong>指定加锁对象，对给定对象/类加锁。<code>synchronized(this|object)</code>表示进⼊同步代码块前要获得<strong>给定对象的锁</strong>。<code>synchronized(.class)</code>表示进⼊同步代码前要获得 <strong>当前</strong> <strong>class 的锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="synchronized关键字和volatile关键字的区别"><a href="#synchronized关键字和volatile关键字的区别" class="headerlink" title="synchronized关键字和volatile关键字的区别"></a>synchronized关键字和volatile关键字的区别</h4><p><strong>synchronized和volatile</strong>关键字是两个互补的存在，⽽不是对⽴的存在！</p>
<ul>
<li><strong>volatile关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以<strong>volatile性能肯定比synchronized关键字要更好</strong>。但是<strong>volatile关键字只能作用于变量</strong>，而synchronized关键字可以修饰方法和代码。</li>
<li>volatile关键字能保证数据的可见性，但<strong>不能保证数据的原子性</strong>。synchronized关键字两者都能保证。</li>
<li><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而<code>synchronized</code>关键字解决的是多个线程之间访问资源的同步性。</li>
</ul>
<h4 id="synchronized关键字和Lock的区别"><a href="#synchronized关键字和Lock的区别" class="headerlink" title="synchronized关键字和Lock的区别"></a>synchronized关键字和Lock的区别</h4><ol>
<li><code>synchronized</code>是<code>Java</code>中的关键字，而<code>Lock</code>是一个接口；</li>
<li>在发生异常时，<code>synchronized</code>会自动释放线程占有的锁，<strong>因此不会导致死锁现象发生</strong>；而<code>Lock</code>在发生异常时，如果没有主动通过<code>unLock()</code>去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</li>
<li><code>Lock</code>可以让等待锁的线程响应中断，而<code>synchronized</code>却不行，使用<code>synchronized</code>时，等待的线程会一直等待下去，不能够响应中断；</li>
<li>通过<code>Lock</code>可以知道有没有成功获取锁（<code>tryLock()</code>方法：如果获取锁成功，则返回true），而<code>synchronized</code>却无法办到。</li>
</ol>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="使用线程池的好处："><a href="#使用线程池的好处：" class="headerlink" title="使用线程池的好处："></a>使用线程池的好处：</h4><ol>
<li>降低资源消耗。通过重复利用已创建的线程，降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控</li>
</ol>
<h4 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h4><p><strong>通过Executor框架的工具类Executors实现</strong>，可以创建三种类型的<code>ThreadPoolExecutor</code></p>
<ol>
<li><strong>FixedThreadPool</strong>：可重用固定线程数的线程池（<strong>适用于负载比较重的服务器</strong>），该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。<strong>[<code>LinkedBlockingQueue</code>]</strong></li>
<li><strong>SingleThreadExecutor：</strong>⽅法返回⼀个只有⼀个线程的线程池。若多余⼀个任务被提交到该线程池，任务会被保存在⼀个任务队列中，待线程空闲，按先⼊先出的顺序执⾏队列中的任务。<strong>[<code>LinkedBlockingQueue</code>]</strong></li>
<li><strong>CachedThreadPool：</strong> <strong>是一个会根据需要调整线程数量的线程池</strong>。（大小无界，适用于执行很多的短期异步任务的小程序，或负载较轻的服务器）。线程池的线程数量不确定，但若有空闲线程可以复⽤，则会优先使⽤可复⽤的线程。若所有线程均在⼯作，⼜有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执⾏完毕后， 将返回线程池进⾏复⽤。<strong>[<code>SynchronousQueue</code>]</strong></li>
</ol>
<p>对应 Executors ⼯具类中的⽅法如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20211018164548.png" alt=""></p>
<h4 id="线程池都有哪些工作队列"><a href="#线程池都有哪些工作队列" class="headerlink" title="线程池都有哪些工作队列"></a>线程池都有哪些工作队列</h4><ul>
<li><strong>ArrayBlockingQueue</strong>：是一个<strong>基于数组结构的有界阻塞队列</strong>，此队列按FIFO（先进先出）原则对元素进行排序。</li>
<li><strong>LinkedBlockingQueue</strong>：是一个<strong>基于链表结构的阻塞队列</strong>，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</li>
<li><strong>SynchronousQueue</strong>：是一个<strong>不存储元素的阻塞队列</strong>。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</li>
<li><strong>PriorityBlockingQueue</strong>：一个<strong>具有优先级的无限阻塞队列</strong>。</li>
</ul>
<h4 id="ThreadPoolExecutor构造函数参数"><a href="#ThreadPoolExecutor构造函数参数" class="headerlink" title="ThreadPoolExecutor构造函数参数"></a>ThreadPoolExecutor构造函数参数</h4><p><strong>最重要的三个参数：</strong></p>
<ol>
<li><strong>corePoolSize</strong>：<strong>核心线程数线程数</strong>定义了最小可以同时运⾏的线程数量</li>
<li><strong>maximumPoolSize:</strong>当队列中存放的任务达到队列容量的时候，当前可以同时运⾏的线程数量变为最⼤线程数。</li>
<li><strong>workQueue：</strong>当新任务来的时候会先判断当前运⾏的线程数量是否达到核⼼线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ol>
<p><strong>其他参数：</strong></p>
<ol>
<li><strong>keepAliveTime</strong>：当线程池中的线程数量⼤于<code>corePoolSize</code>的时候， 如果这时没有新的任务提交，核⼼线程外的线程不会⽴即销毁，⽽是会等待，直到等待的时间超过了<code>keepAliveTime</code>才会回收。</li>
<li><strong>handle：</strong>饱和策略</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20211018170740.png" alt=""></p>
<blockquote>
<p>饱和策略：</p>
<ol>
<li>丢弃最早未处理的任务请求</li>
<li>不处理新任务，直接丢弃</li>
<li>拒绝新任务的处理</li>
</ol>
</blockquote>
<h3 id="多线程开发带来的问题与解决办法"><a href="#多线程开发带来的问题与解决办法" class="headerlink" title="多线程开发带来的问题与解决办法"></a>多线程开发带来的问题与解决办法</h3><h4 id="线程安全问题："><a href="#线程安全问题：" class="headerlink" title="线程安全问题："></a>线程安全问题：</h4><p>线程安全问题指的是在某一线程从开始访问到结束<strong>访问某一数据期间，该数据被其他的线程所修改</strong>，那么对于当前线程而言，该线程就发生了线程安全问题，表现形式为数据的缺失，数据不一致等。</p>
<p><strong>线程安全问题发生的条件</strong></p>
<p>1）多线程环境下，即存在包括自己在内存在有多个线程。</p>
<p>2）多线程环境下<strong>存在共享资源</strong>，且<strong>多线程操作该共享资源。</strong></p>
<p>3）多个线程必须对该共享资源有非原子性操作</p>
<p><strong>线程安全的解决思路：</strong></p>
<p>1）<strong>尽量不使用共享变量</strong>，将不必要的共享变量变成局部变量来使用。</p>
<p>2）<strong>使用synchronized关键字同步代码块</strong>，或者使用jdk包中提供的Lock为操作进行<strong>加锁</strong>。</p>
<p>3）<strong>使用ThreadLocal为每一个线程建立一个变量的副本，各个线程间独立操作，互不影响。</strong></p>
<h4 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h4><p>线程的生命周期开销是非常大的，<strong>一个线程的创建到销毁都会占用大量的内存</strong>。同时如果不合理的创建了多个线程，cup的处理器数量小于了线程数量，那么将会有很多的线程被闲置，闲置的线程将会占用大量的内存，为垃圾回收带来很大压力，同时cup在分配线程时还会消耗其性能。</p>
<p><strong>解决思路：</strong>利用线程池<strong>，模拟一个池，预先创建有限合理个数的线程放入池中，当需要执行任务时从池中取出空闲的先去执行任务，执行完成后将线程归还到池中，这样就</strong>减少了线程的频繁创建和销毁，节省内存开销和减小了垃圾回收的压力。同时因为任务到来时本身线程已经存在，减少了创建线程时间，提高了执行效率，而且合理的创建线程池数量还会使各个线程都处于忙碌状态，提高任务执行效率，线程池还提供了拒绝策略，当任务数量到达某一临界区时，线程池将拒绝任务的进入，保持现有任务的顺利执行，减少池的压力。</p>
<h3 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h3><p><strong>重进入：重进入是指任意线程在获取到锁之后，再次获取该锁而不会被该锁所阻塞</strong>。关联一个线程持有者+计数器，重入意味着锁操作的颗粒度为“线程”。</p>
<p><strong>重入锁实现重入性：</strong>每个锁<strong>关联一个线程持有者和计数器</strong>，当计数器为0时表示该锁没有被任何线程持有，那么任何线程都可能获得该锁而调用相应的方法；当某一线程请求成功后，JVM会记下锁的持有线程，并且将计数器置为1；此时其它线程请求该锁，则必须等待；而<strong>该持有锁的线程</strong>如果<strong>再次</strong>请求这个锁，就可以再次拿到这个锁，同时计数器会递增；当线程退出同步代码块时，计数器会递减，如果计数器为0，则释放该锁</p>
<h3 id="AQS-AbstractQueuedSynchronizer"><a href="#AQS-AbstractQueuedSynchronizer" class="headerlink" title="AQS(AbstractQueuedSynchronizer)"></a>AQS(AbstractQueuedSynchronizer)</h3><p><strong>AQS 定义两种资源共享⽅式：</strong></p>
<ul>
<li><p><strong>Exclusive（独占）</strong>：只有⼀个线程能执⾏，如<code>ReentrantLock</code>。又可以分为公平锁和非公平锁</p>
<ul>
<li><strong>公平锁：</strong>按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li><strong>非公平锁：</strong>当线程要获取锁时，⽆视队列顺序直接去抢锁，谁抢到就是谁的</li>
</ul>
<p><strong>公平锁和非公平锁只有两处不同：</strong></p>
<ol>
<li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li>
<li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 <code>tryAcquire</code> 方法，在 <code>tryAcquire</code> 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li>
</ol>
<p>公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。</p>
<blockquote>
<p>非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p>
</blockquote>
</li>
<li><p><strong>Share(共享)：</strong>多个线程可同时执⾏，如<code>CountDownLatch</code>。</p>
</li>
</ul>
<h4 id="AQS原理概览"><a href="#AQS原理概览" class="headerlink" title="AQS原理概览"></a>AQS原理概览</h4><p>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 <strong>CLH 队列锁</strong>实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<blockquote>
<p>CLH队列是一个虚拟的双向队列，即不存在队列实例，仅存在结点之间的关联关系</p>
</blockquote>
<p><img src="https://camo.githubusercontent.com/02e863f3d5de3c34484f6162c1d0b3bf8912dbd70ac0a672bb99724f1f47f2d8/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f4a6176612532302545372541382538422545352542412538462545352539312539382545352542462538352545352541342538372545462542432539412545352542392542362545352538462539312545372539462541352545382541462538362545372542332542422545372542422539462545362538302542422545372542422539332f434c482e706e67" alt="enter image description here"></p>
<p>AQS 使⽤⼀个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队⼯作。</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p><strong>为什么要有单例模式：</strong></p>
<p>实际编程应用场景中，<strong>有一些对象其实我们只需要一个，比如线程池对象、缓存、系统全局配置对象等</strong>。这样可以就保证一个在全局使用的类不被频繁地创建与销毁，节省系统资源。</p>
<p><strong>单例模式的实现思路：</strong></p>
<ol>
<li><strong>将该类的构造方法定义为私有方法</strong>，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例；</li>
<li><strong>在该类内提供一个可见的静态方法</strong>，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。</li>
</ol>
<h4 id="双重检查锁实现单例：-使用了synchronized和volatile关键字-线程安全"><a href="#双重检查锁实现单例：-使用了synchronized和volatile关键字-线程安全" class="headerlink" title="双重检查锁实现单例：(使用了synchronized和volatile关键字)-线程安全"></a>双重检查锁实现单例：(使用了synchronized和volatile关键字)-线程安全</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//先判断对象是否已经实例过，没有实例化进入加锁代码</span></span><br><span class="line">      <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="comment">//类对象加锁</span></span><br><span class="line">          <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">              <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">                  singleton=<span class="keyword">new</span> Singleton();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> singleton;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意volatile关键字的使用，保证了各线程对singleton静态实例域修改的可见性。</p>
</blockquote>
<h4 id="静态内部类实现单例-懒加载-线程安全"><a href="#静态内部类实现单例-懒加载-线程安全" class="headerlink" title="静态内部类实现单例(懒加载)-线程安全"></a>静态内部类实现单例(懒加载)-线程安全</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE=<span class="keyword">new</span> Singleton();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span>  Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>这种方式下 Singleton 类被装载了，instance 不一定被初始化。</strong>因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。注意内部类SingletonHolder要用static修饰且其中的静态变量INSTANCE必须是final的。</p>
</blockquote>
<h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><h3 id="三次握手的过程"><a href="#三次握手的过程" class="headerlink" title="三次握手的过程"></a>三次握手的过程</h3><p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20200409195521.jfif" alt=""></p>
<ol>
<li><p>TCP服务器进程先创建<code>传输控制块TCB</code>，时刻准备接受客户进程的连接请求，此时服务器进入<code>LISTEN</code>状态。</p>
</li>
<li><p><strong>第一次握手</strong>： TCP客户进程也是先创建<code>TCB</code>,然后向服务器发出请求报文，此时报文中的<code>同部位SYN=1</code>（SYN，同步序列编号），同时选择一个初始序列号<code>seq=x</code>，此时TCP客户端进入<code>SYN-SENT(同步已发送)</code>状态。</p>
</li>
<li><p><strong>第二次握手：</strong> TCP服务器收到请求后，如果同意连接，则发出确认报文。<code>确认报文中应该ACK=1，SYN=1,确认号是ack=x+1</code>,同时为自己初始化一个序列号seq=y，此时TCP服务器进程进入<code>SYN-RCVD(同步收到)</code>状态。</p>
</li>
<li><p><strong>第三次握手：</strong> TCP客户进程收到确认后，还要向服务器给出确认。确认报文的<code>ACK=1,确认号ack=y+1</code>，自己序列号为：seq=x+1,此时，TCP连接已经建立，<strong>客户端</strong> 进入<code>ESTABLISHED(已建立连接)</code>状态，当 <strong>服务器</strong>收到客户端的确认后也进入**<code>ESTABLISHED</code>状态，双方可以开始通信。</p>
</li>
</ol>
<h4 id="为什么TCP客户端最后还要发送一次确认呢"><a href="#为什么TCP客户端最后还要发送一次确认呢" class="headerlink" title="为什么TCP客户端最后还要发送一次确认呢?"></a>为什么TCP客户端最后还要发送一次确认呢?</h4><p> 一句话，<strong>主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误</strong>。<br> 如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p>
<p> 如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p>
<h3 id="四次挥手的过程"><a href="#四次挥手的过程" class="headerlink" title="四次挥手的过程"></a>四次挥手的过程</h3><p>   <img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20200409212059.jfif" alt=""></p>
<ol>
<li><p>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部<code>FIN=1,序列号seq=u</code>(其值为之前传过来的数据最后一个字节的序号+1)，此时，<strong>客户端</strong>进入<code>FIN-WATI=1(终止等待1)</code>状态。</p>
</li>
<li><p>服务器收到连接释放报文，发出确认报文，<code>ACK=1,ack=u+1</code>,并且带上自身序列号<code>seq=v</code> ,此时，<strong>服务端</strong>进入<code>CLOSE-WATI(等待关闭)</code>状态。</p>
<blockquote>
<p>此时处于半关闭状态,即客户端已无数据需要发送，但服务器若是发送数据，客户端依然需要接收</p>
</blockquote>
</li>
<li><p>客户端收到服务器的确认请求，此时，客户端进入<code>FIN-WAIT-2(终止等待2)</code>状态，等待服务器发送连接释放报文。</p>
</li>
<li><p>服务器将最后的数据发送完毕之后，向客户端发送连接释放报文,<code>FIN=1,ack=u+1</code>，由于在半关闭状态，服务 器可能又发送了一些数据，因此假定此时的<code>序列号seq=w</code>,此时，服务器进入<code>LAST-ACK(最后确认)</code>状态。</p>
</li>
<li><p>客户端收到服务器的连接释放报文之后，必须发出确认<code>ACK=1,ack=w+1，seq=u+1</code>，此时客户端进入<code>TIME-WAIT(时间等待)</code>状态。</p>
<p>服务器只要收到了客户端发出的确认，立即进入<code>CLOSE</code>状态，同样，撤掉TCB后结束的此次连接(<code>可见，服务器结束TCP要早于客户端</code>)。</p>
<blockquote>
<p>此时TCP连接还未释放，必须经过2*MSL(<em>最长报文段寿命</em>)时间，客户端撤销相应TCB后，才进入<em>CLOSED</em>状态</p>
</blockquote>
</li>
</ol>
<h4 id="为什么建立连接是三次握手，释放连接确实四次挥手？"><a href="#为什么建立连接是三次握手，释放连接确实四次挥手？" class="headerlink" title="为什么建立连接是三次握手，释放连接确实四次挥手？"></a>为什么建立连接是三次握手，释放连接确实四次挥手？</h4><p>   建立连接时，服务器在LISTEN状态下，收到建立连接请求的 <em>SYN</em> 报文之后，把ACK和SYN放在一个报文发送给客户端。</p>
<p>   而在关闭连接时，服务器收到 <em>FIN</em>报文时，仅仅表示客户端不在发送数据但任能接收数据，因此客户端既可以立即关闭，也可以在发送一些数据给客户端之后，此时会先发送确认报文告知客户端已经准备关闭连接，当服务器数据发送完成之后，再发送 <em>FIN报文</em>给客户端。因此，服务端的ACK和FIN会分开发送，从而导致了四次挥手。</p>
<h3 id="三次握手过程中可以携带数据嘛"><a href="#三次握手过程中可以携带数据嘛" class="headerlink" title="三次握手过程中可以携带数据嘛"></a>三次握手过程中可以携带数据嘛</h3><p><strong>在第三次握手的时候可以携带数据</strong>，但是第一次、第二次握手不可以携带数据一个简单的原因就是会让服务器更加容易受到攻击，对于第三次的话，此时客户端已经处于ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据。</p>
<blockquote>
<p>假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。</p>
</blockquote>
<h3 id="如果已经建立连接，但是客户端出现故障-TCP的保活机制-keapalive长连接"><a href="#如果已经建立连接，但是客户端出现故障-TCP的保活机制-keapalive长连接" class="headerlink" title="如果已经建立连接，但是客户端出现故障(TCP的保活机制)(keapalive长连接)"></a>如果已经建立连接，但是客户端出现故障(TCP的保活机制)(keapalive长连接)</h3><p>TCP有一个机制是保活机制，工作原理为：当一个TCP 连接建立之后，启用TCP Keepalive 的一端便会启动一个计时器，当这个计时器数值到达0 内（7200s)，连接没有任何动作,，一个TCP 探测包便会被发出。这个TCP 探测包是一个纯ACK 包，客户主机必须处于以下4 个状态之一：</p>
<ol>
<li>客户主机依然正常运行，并从服务器可达。客户的TCP 响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。</li>
<li>客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP 都没有响应。服务端将不能收到对探测的响应，并在75 秒后超时。服务器总共发送9 个这样的探测，每个间隔75 秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。</li>
<li>客户主机崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，但是由于没有该连接的有效信息，会产生一个RST报文，这样很快就发现TCP连接已经被重置。</li>
</ol>
<blockquote>
<p>保活机制需要消耗额外的宽带和流量。</p>
</blockquote>
<h3 id="TCP的重传机制"><a href="#TCP的重传机制" class="headerlink" title="TCP的重传机制"></a>TCP的重传机制</h3><p>TCP实现可靠传输的方式之一，是通过序列号与确认应答。</p>
<p>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。万一数据在传输过程中丢失了呢？所以 TCP 针对数据包丢失的情况，会用<strong>重传机制</strong>解决。</p>
<p><strong>超时重传</strong></p>
<p>在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据，也就是我们常说的<strong>超时重传</strong>。</p>
<p><strong>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值,每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。</strong></p>
<blockquote>
<p>TCP 会在以下两种情况发生超时重传：</p>
<ul>
<li>数据包丢失</li>
<li>确认应答丢失</li>
</ul>
</blockquote>
<p><strong>快速重传</strong></p>
<p>快速重传机制<strong>不以时间为驱动，而是以数据驱动重传</strong>。快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</p>
<img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909091033.png" style="zoom: 80%;" />

<p>在上图，发送方发出了 1，2，3，4，5 份数据：</p>
<ul>
<li>第一份 Seq1 先送到了，于是就 Ack 回 2；</li>
<li>结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；</li>
<li>后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；</li>
<li><strong>发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。</strong></li>
<li>最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。</li>
</ul>
<blockquote>
<p>因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的,所以快速重传临着另外一个问题。就是<strong>重传的时候，是重传之前的一个，还是重传所有的问题。</strong></p>
</blockquote>
<p><strong>SACK方法(选择性确认)</strong></p>
<p>这种方式需要在 TCP 头部「选项」字段里加一个 <code>SACK</code> 的东西，它<strong>可以将缓存的地图发送给发送方</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong></p>
<p>如下图，发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 <code>SACK</code> 信息发现只有 <code>200~299</code> 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909091602.png" alt=""></p>
<p><strong>Duplicate SACK</strong></p>
<p>Duplicate SACK 又称 <code>D-SACK</code>，其主要<strong>使用了 SACK 来告诉「发送方」有哪些数据被重复接收了</strong></p>
<blockquote>
<ol>
<li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li>
<li>可以知道是不是「发送方」的数据包被网络延迟了;</li>
<li>可以知道网络中是不是把「发送方」的数据包给复制了;</li>
</ol>
</blockquote>
<h3 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h3><p>流量控制是为了控制发送方发送速率，让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。<br>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为0，则发送方不能发送数据。</p>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p><strong>为什么需要滑动窗口：</strong>按数据包进行确认应答的传输方式有一个缺点：数据包的<strong>往返时间越长，通信的效率就越低</strong>。</p>
<p>为解决这个问题，TCP 引入了<strong>窗口</strong>这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。</p>
<p>那么有了窗口，就可以指定窗口大小，窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。</p>
<p>TCP 头里有一个字段叫 <code>Window</code>，也就是窗口大小。</p>
<p><strong>这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来</strong></p>
<p>发送方的滑动窗口</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909103101.png" alt=""></p>
<blockquote>
<ul>
<li>#1 是已发送并收到 ACK确认的数据：1~31 字节</li>
<li>#2 是已发送但未收到 ACK确认的数据：32~45 字节</li>
<li>#3 是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51字节</li>
<li>#4 是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后</li>
</ul>
</blockquote>
<p>接收方的滑动窗口</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909103156.png" alt=""></p>
<blockquote>
<ul>
<li>#1 + #2 是已成功接收并确认的数据（等待应用进程读取）；</li>
<li>#3 是未收到数据但可以接收的数据；</li>
<li>#4 未收到数据并不可以接收的数据</li>
</ul>
</blockquote>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大…</p>
<p>于是，就有了<strong>拥塞控制</strong>，控制的目的就是<strong>避免「发送方」的数据填满整个网络。</strong></p>
<blockquote>
<p><strong>此处引入一个拥塞窗口：</strong><br><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</p>
<p>加入了拥塞窗口的概念后，此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。</p>
</blockquote>
<p><strong>如何判断当前网络是否出现了拥塞</strong></p>
<p>其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是<strong>发生了超时重传，就会认为网络出现了用拥塞。</strong></p>
<p><strong>拥塞控制有哪些控制算法：</strong></p>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>拥塞发生</li>
<li>快速恢复</li>
</ul>
<p><strong>慢启动</strong></p>
<p>慢启动的意思就是一点一点的提高发送数据包的数量，</p>
<p>慢启动的算法记住一个规则就行：<strong>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。</strong></p>
<p>这里假定拥塞窗口 <code>cwnd</code> 和发送窗口 <code>swnd</code> 相等，下面举个栗子：</p>
<ul>
<li>连接建立完成后，一开始初始化 <code>cwnd = 1</code>，表示可以传一个 <code>MSS</code> 大小的数据。</li>
<li>当收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2 个</li>
<li>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以比之前多发2 个，所以这一次能够发送 4 个</li>
<li>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以比之前多发 4 个，所以这一次能够发送 8 个。</li>
</ul>
<blockquote>
<p>慢启动算法，发包的个数是<strong>指数性的增长</strong></p>
</blockquote>
<p>存在一个慢启动门限(ssthresh)状态变量(一般是65535字节)</p>
<ul>
<li>当 <code>cwnd</code> &lt; <code>ssthresh</code> 时，使用慢启动算法。</li>
<li>当 <code>cwnd</code> &gt;= <code>ssthresh</code> 时，就会使用「拥塞避免算法」。</li>
</ul>
<p><strong>拥塞避免</strong></p>
<p>进入拥塞避免算法后，它的规则是：<strong>每当收到一个 ACK 时，cwnd 增加 1/cwnd。</strong></p>
<blockquote>
<ul>
<li>当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 <code>MSS</code> 大小的数据，变成了<strong>线性增长。</strong></li>
</ul>
</blockquote>
<p><strong>拥塞发生</strong></p>
<p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：超时重传；快速重传</p>
<p><strong>超时重传的拥塞发生算法：</strong>当发生了超时重传，则就会使用拥塞发生算法。</p>
<p>这个时候，ssthresh 和 cwnd 的值会发生变化：</p>
<ul>
<li><code>ssthresh</code> 设为 <code>cwnd/2</code>，</li>
<li><code>cwnd</code> 重置为 <code>1</code></li>
</ul>
<blockquote>
<p>接着，就重新开始慢启动，慢启动是会突然减少数据流的。这种方式太激进了，反应也很强烈，会造成网络卡顿。</p>
</blockquote>
<p><strong>快速重传的拥塞发生算法：</strong>当发生快速重传的时候，则使用快速重传的拥塞发生算法</p>
<ul>
<li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li>
<li><code>ssthresh = cwnd</code>;</li>
<li>进入快速恢复算法</li>
</ul>
<p><strong>快速恢复算法</strong></p>
<p>快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 <code>RTO</code> 超时那么强烈。</p>
<ul>
<li>拥塞窗口 <code>cwnd = ssthresh + 3</code> （ 3 的意思是确认有 3 个数据包被收到了）；</li>
<li>重传丢失的数据包；</li>
<li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li>
<li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909151522.png" alt=""></p>
<h3 id="TCP的可靠性"><a href="#TCP的可靠性" class="headerlink" title="TCP的可靠性"></a>TCP的可靠性</h3><p><strong>1. 校验和</strong></p>
<p><strong>计算方式：</strong>检验和是存在于各种报文中的一个字段，它存在的目的是验证报文在网络传输过程中的完整性。因此，在报文的发送端，会根据报文中的首部或数据来计算一个检验和，然后一旦接收端接受到相应报文，接收端也会对报文的首部或数据进行一次检验和计算，如果接收端算出来的检验和和发送端发送的不一样，那么接收端认为报文在传输过程中出了错，于是就丢掉该报文。</p>
<blockquote>
<p>在数据传输的过程中，将发送的数据段都当做一个16 位的整数。将这些整数加起来。并且前面的进位不能丢弃，补在后面，最后取反，得到校验和</p>
</blockquote>
<blockquote>
<p>接收方和发送方校验和比对一致，数据也不一定传输成功。</p>
</blockquote>
<p><strong>2.序列号和确认应答</strong></p>
<p><strong>序列号</strong>：TCP 传输时<strong>将每个字节的数据都进行了编号</strong>，这就是序列号。序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是TCP 传输可靠性的保证之一。</p>
<p><strong>确认应答：</strong>TCP 传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK 报文。这个<strong>ACK 报文当中带有对应的确认序列号</strong>，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。</p>
<p><strong>3. 连接管理：</strong>即TCP建立连接时的三次握手与四次挥手</p>
<p><strong>4. 重传机制</strong>；<strong>5. 流量控制</strong>；<strong>6.拥塞控制</strong></p>
<h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><ol>
<li>TCP 面向连接（如打电话要先拨号建立连接）;UDP 是无连接的，即发送数据之前不需要建立连接</li>
<li>TCP 提供可靠的服务。也就是说，通过TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP 尽最大努力交付，即不保证可靠交付</li>
<li>TCP 面向字节流，实际上是TCP 把数据看成一连串无结构的字节流;UDP 是面向报文的，UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP 电话，实时视频会议等），并且UDP 速度更快</li>
<li>每一条TCP 连接只能是点到点的;UDP 支持一对一，一对多，多对一和多对多的交互通信</li>
<li>TCP 首部开销20 字节;UDP 的首部开销小，只有8 个字节</li>
<li>TCP 的逻辑通信信道是全双工的可靠信道，UDP 则是不可靠信道</li>
</ol>
<h4 id="TCP和UDP的应用"><a href="#TCP和UDP的应用" class="headerlink" title="TCP和UDP的应用"></a>TCP和UDP的应用</h4><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909152412.png" style="zoom:50%;" />

<h3 id="在浏览器输入url地址到显示主页的过程"><a href="#在浏览器输入url地址到显示主页的过程" class="headerlink" title="在浏览器输入url地址到显示主页的过程"></a>在浏览器输入url地址到显示主页的过程</h3><ol>
<li>DNS解析：获取域名对应IP</li>
<li>建立TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>结束连接</li>
</ol>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="HTTP是无状态的协议-如何保存用户状态"><a href="#HTTP是无状态的协议-如何保存用户状态" class="headerlink" title="HTTP是无状态的协议,如何保存用户状态?"></a>HTTP是无状态的协议,如何保存用户状态?</h3><p><code>HTTP</code> 是⼀种不保存状态，即<strong>⽆状态（stateless）协议</strong>。也就是说 HTTP 协议⾃身不对请求和响应之间的通信状态进⾏保存。那么我们保存⽤户状态呢？</p>
<p><code>Session</code>机制的存在就是为了解决这个问题，Session 的主要作⽤就是<strong>通过服务端</strong>记录⽤户的状态。典型的场景是购物⻋，当你要添加商品到购物⻋的时候，系统不知道是哪个⽤户操作的，因为 HTTP 协议是⽆状态的。服务端给特定的⽤户创建特定的 Session 之后就可以标识这个⽤户并且跟踪这个⽤户了（⼀般情况下，服务器会在⼀定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。</p>
<h3 id="Cookie的作用是什么-和Session有什么区别？"><a href="#Cookie的作用是什么-和Session有什么区别？" class="headerlink" title="Cookie的作用是什么?和Session有什么区别？"></a>Cookie的作用是什么?和Session有什么区别？</h3><p>Cookie 和 Session都是⽤来跟踪浏览器⽤户身份的会话⽅式，但是两者的应⽤场景不太⼀样。</p>
<p><strong>Cookie ⼀般⽤来保存⽤户信息，比如：</strong></p>
<ol>
<li>我们在 Cookie 中保存已经登录过得⽤户信息，下次访问⽹站的时候⻚⾯可以⾃动帮你登录的⼀些基本信息给填了；</li>
<li>⼀般的⽹站都会有保持登录也就是 说下次你再访问⽹站的时候就不需要重新登录了，这是因为⽤户登录的时候我们<strong>可以存放了⼀个<code>Token</code> 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找⽤户即可</strong>(为了安全考虑，重新登录⼀般要将 Token 重写)；</li>
<li>登录⼀次⽹站后访问⽹站其他⻚⾯不需要重新登录。</li>
</ol>
<p><strong>Session 的主要作⽤就是通过服务端记录⽤户的状态：</strong>因为 HTTP 协议是⽆状态的。服务端给特定的⽤户创建特定的 Session 之后就可以<strong>标识这个⽤户并且跟踪这个⽤户了。</strong></p>
<blockquote>
<p><code>Cookie</code>保存在客户端，<code>Session</code>数据保存在服务器端</p>
</blockquote>
<h3 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h3><ol>
<li><strong>端口：</strong>HTTP的URL由“http://”起始且默认使⽤端⼝80，⽽HTTPS的URL由“https://”起始且默认使⽤端⼝443。</li>
<li><strong>安全性和资源消耗：</strong> HTTP协议运⾏在TCP之上，所有传输的内容都是明⽂，客户端和服务器端都⽆法验证对⽅的身份。HTTPS是运⾏在SSL/TLS之上的HTTP协议，SSL/TLS 运⾏在TCP之上。所有传输的内容都经过加密，加密采⽤对称加密，但对称加密的密钥⽤服务器⽅的证书进⾏了⾮对称加密。所以说，HTTP 安全性没有 HTTPS⾼，但是 HTTPS ⽐HTTP耗费更多服务器资源。</li>
</ol>
<h3 id="在浏览器输入url地址到显示主页的过程-1"><a href="#在浏览器输入url地址到显示主页的过程-1" class="headerlink" title="在浏览器输入url地址到显示主页的过程"></a>在浏览器输入url地址到显示主页的过程</h3><ol>
<li>DNS解析：获取域名对应IP</li>
<li>建立TCP连接</li>
<li>发生HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>结束连接</li>
</ol>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="JVM-新生代和老年代都使用什么GC算法"><a href="#JVM-新生代和老年代都使用什么GC算法" class="headerlink" title="JVM 新生代和老年代都使用什么GC算法"></a>JVM 新生代和老年代都使用什么GC算法</h3><h4 id="新生代和老年代的区别"><a href="#新生代和老年代的区别" class="headerlink" title="新生代和老年代的区别"></a>新生代和老年代的区别</h4><p><img src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/01d330d8-2710-4fad-a91c-7bbbfaaefc0e.png" alt="img">新生代和老年代是针对于分代收集算法来定义的，新生代又分为Eden 和Survivor 两个区。加上老年代就这三个区。数据会首先分配到Eden 区当中（当然也有特殊情况，<strong>如果是大对象那么会直接放入到老年代</strong>（大对象是指需要大量连续内存空间的java 对象）。），<strong>当Eden没有足够空间的时候就会触发jvm 发起一次Minor GC</strong>。如果对象经过一次Minor GC 还存活，并且又能被Survivor 空间接受，那么将被移动到Survivor 空间当中。并将其年龄设为1，对象在Survivor 每熬过一次Minor GC，年龄就加1，当年龄达到一定的程度（默认为15）时，就会被晋升到老年代中了，当然晋升老年代的年龄是可以设置的。如果老年代满了就执行：Full GC 因为不经常执行，因此采用了Mark-Compact 算法清理。</p>
<p><strong>新生代回收</strong>的判断条件是新生代内存不足时候。新生代主要是用来存放新生的对象，会频繁创建对象，所有垃圾收集会频繁进行回收。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。</p>
<p><strong>新生代使用的算法：复制（Copy）算法</strong><br>将可用内存容量划分为大小相等的两块，每次只用其中一块。当这块内存用完了，就将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。(From到to；to到from)</p>
<blockquote>
<p>优点：不会产生大量不连续的内存空间</p>
<p>缺点：效率也不是很高，需要占用双倍内存空间</p>
</blockquote>
<p><strong>老年代回收的判断条件</strong></p>
<ol>
<li><p><strong>System.gc()方法的调用</strong>，在代码中调用System.gc()方法会<strong>建议</strong>JVM 进行Full GC，在大多数情况下会增加Full GC的次数，导致系统性能下降，一般不建议手动进行此方法的调用。</p>
</li>
<li><p><strong>老年代空间不足</strong>：在Survivor 区域的对象满足晋升到老年代的条件时，晋升进入老年代的对象大小大于老年代的可用内存，这个时候会触发Full GC。</p>
</li>
<li><p><strong>Metaspace 区内存达到阈值：</strong>Metaspace 使用的是本地内存，而不是堆内存，也就是说在默认情况下Metaspace<br>的大小只与本地内存大小有关（约为20.8MB），超过这个值就会引发Full GC，这个值不是固定的，是会随着JVM 的运行进行动态调整的。</p>
</li>
<li><p><strong>堆中产生大对象超过阈值：</strong>大对象或者长期存活的对象进入老年代，典型的大对象就是很长的字符串或者数组，它们在被创建后会直接进入老年代，在要放置的时候JVM 如果发现老年代的空间不足时，会触发GC。</p>
</li>
<li><p><strong>老年代连续空间不足：</strong>JVM 如果判断老年代没有做足够的连续空间来放置大对象，那么就会引起Full GC</p>
</li>
<li><p><strong>统计得到的Minor GC 晋升到旧生代的平均大小大于老年代的剩余空间</strong></p>
<blockquote>
<p>新生代晋升的另外一种情况是如果JVM 发现Survivor 区域中的相同年龄的对象占到所有对象的一半以上时，就会将大于这个年龄的对象移动到老年代，在这批对象在统计后发现可以晋升到老年代，但是发现老年代没有足够的空间来放置这些对象，这就会引起Full GC</p>
</blockquote>
</li>
</ol>
<p><strong>老年代使用的算法</strong></p>
<p><strong>标记清除：</strong></p>
<p>标记清除算法是最基础的回收算法，分为标记和清除两个部分：首先标记出所有需要回收的对象，这一过程<strong>在可达性分析过程中进行</strong>。在标记完之后统一回收所有被标记的对象。</p>
<img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909213741.png" style="zoom:80%;" />

<blockquote>
<p><strong>优点</strong>：速度较快</p>
<p><strong>缺点：</strong>会造成内存碎片，导致在程序运行过程中需要分配较大对象的时候，无法找到足够的连续内存而不得不提前触发一次垃圾收集动作。</p>
</blockquote>
<p><strong>标记整理：</strong></p>
<p>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909213810.png" style="zoom:80%;" />

<blockquote>
<p><strong>优点：</strong>没有内存碎片<br><strong>缺点：</strong>速度慢</p>
</blockquote>
<p><strong>分代垃圾回收：</strong>根据各个年代的特点采取最适当的收集算法</p>
<p>在新生代中，每次垃圾收集时候都发现有大批对象死去，只有少量存活，那就选用复制算法。只需要付出少量存活对象的复制成本就可以完成收集。<br> 老年代中因为对象存活率高、没有额外空间对他进行分配担保，就必须用标记-清除或者标记-整理。</p>
<h4 id="可达性算法分析"><a href="#可达性算法分析" class="headerlink" title="可达性算法分析"></a>可达性算法分析</h4><p>这个算法的基本思想就是通过⼀系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所⾛过的路径称为引⽤链，当⼀个对象到 GC Roots 没有任何引⽤链相连的话，则证明此对象是不可⽤的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20211019091958.png" alt=""></p>
<h3 id="强引用、软引用、弱引用、虚引用"><a href="#强引用、软引用、弱引用、虚引用" class="headerlink" title="强引用、软引用、弱引用、虚引用"></a>强引用、软引用、弱引用、虚引用</h3><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>以前我们使⽤的⼤部分引⽤实际上都是强引⽤，这是使⽤最普遍的引⽤。如果⼀个对象具有强引⽤，那就类似于<strong>必不可少的⽣活⽤品</strong>，垃圾回收器绝不会回收它。当内存空 间不⾜，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终⽌，也不会靠随意回收具有强引⽤的对象来解 决内存不⾜问题</p>
<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>如果⼀个对象只具有软引⽤，那就类似于<strong>可有可⽆的⽣活⽤品</strong>。如果内存空间⾜够，垃圾回收器就不会回收它，如果内存空间不⾜了，就会回收这些对象的内存。只要垃圾回收器没有回收它， 该对象就可以被程序使⽤。软引⽤可⽤来实现内存敏感的⾼速缓存。</p>
<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>如果⼀个对象只具有弱引⽤，那就类似于<strong>可有可⽆的⽣活⽤品</strong>。弱引⽤与软引⽤的区别在于：<strong>只具有弱引⽤的对象拥有更短暂的⽣命周期</strong>。在垃圾回收器线程扫描它所管辖的内存区域的过程  中，<strong>⼀旦发现了只具有弱引⽤的对象，不管当前内存空间⾜够与否，都会回收它的内存</strong>。不过， 由于垃圾回收器是⼀个优先级很低的线程， 因此不⼀定会很快发现那些只具有弱引⽤的对象。</p>
<h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>“虚引⽤”顾名思义，就是形同虚设，与其他⼏种引⽤都不同，虚引⽤并不会决定对象的⽣命周 期。如果⼀个对象仅持有虚引⽤，那么它就和没有任何引⽤⼀样，在任何时候都可能被垃圾回收。</p>
<h3 id="JVM垃圾收集器"><a href="#JVM垃圾收集器" class="headerlink" title="JVM垃圾收集器"></a>JVM垃圾收集器</h3><h4 id="CMS-Concurrent-Mark-Sweep-回收器："><a href="#CMS-Concurrent-Mark-Sweep-回收器：" class="headerlink" title="CMS(Concurrent Mark Sweep)回收器："></a>CMS(Concurrent Mark Sweep)回收器：</h4><p>CMS收集器是一种<strong>以获取最短回收停顿时间为目标的收集器</strong>，是HotSpot虚拟机第一款真正意义上的并发收集器，第一次实现了垃圾收集线程和用户线程基本上同时工作</p>
<p>CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，整个过程分为四个步骤：</p>
<ol>
<li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li>
<li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>
<li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li>
<li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210910143806.png" alt=""></p>
<blockquote>
<p><strong>缺点：</strong></p>
<ol>
<li><p>对 CPU 资源敏感；</p>
</li>
<li><p>无法处理浮动垃圾，CMS 在并发清理阶段线程还在运行， 伴随着程序的运行自然也会产生新的垃圾，这一部分垃圾产生在标记过程之后，CMS 无法再当次过程中处理，所以只有等到下次gc 时候在清理掉。</p>
</li>
<li><p>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</p>
</li>
</ol>
</blockquote>
<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p><strong>G1 (Garbage-First)</strong> 是一款<strong>面向服务器的垃圾收集器</strong>,主要针对配备多颗处理器及大容量内存的机器. 以<strong>极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p>
<p>G1 可面向<strong>堆任何部分</strong>来组成回收集进行回收，<strong>衡量标准不再是分代</strong>，而是哪块内存中存放的垃圾数量最多，回收受益最大。</p>
<p><strong>G1的特点：</strong></p>
<ol>
<li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li>
<li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li>
<li><strong>空间整合</strong>：与 CMS 的“标记-清理”算法不同，G1 从<strong>整体来看是基于“标记-整理”算法</strong>实现的收集器；从<strong>局部上来看是基于“标记-复制”</strong>算法实现的。</li>
<li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li>
</ol>
<p><strong>G1运作步骤：</strong></p>
<ol>
<li><strong>初始标记：</strong>标记GC Roots 能直接关联到的对象</li>
<li><strong>并发标记：</strong>从GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆的对象图</li>
<li><strong>最终标记：</strong>对用户线程做短暂暂停，处理并发阶段结束后仍遗留下来的少量SATB 记录</li>
<li><strong>筛选回收：</strong>对各Region 的回收价值排序，根据用户期望停顿时间制定回收计划。必须暂停用户线程，由多条收集线程并行完成。</li>
</ol>
<blockquote>
<p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>
</blockquote>
<h4 id="其他收集器"><a href="#其他收集器" class="headerlink" title="其他收集器"></a>其他收集器</h4><p><strong>Serial收集器:</strong> 单线程收集器，收集垃圾时，<strong>必须暂停其他所有的工作线程</strong>（stop the world），<strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p>
<p><strong>ParNew 收集器：</strong>其实就<strong>是 Serial 收集器的多线程版本</strong>，除了使用多线程进行垃圾收集外，其余行为和 Serial 收集器完全一样。(只有Serial和ParNew可以和CMS配合工作)</p>
<p><strong>Parallel Scavenge收集器：</strong>新生代收集器，基于复制算法，是可并行的多线程收集器，与ParNew 类似。特点是它的<br>关注点与其他收集器不同，Parallel Scavenge 的目标是达到一个可控制的吞吐量，所谓吞吐量就是处理器用于运行用户代码的时间与处理器消耗总时间的比值</p>
<p><strong>Serial Old</strong>:Serial 收集器的老年代版本，它同样是一个单线程收集器,采用标记-整理算法</p>
<p><strong>Parnew Old:</strong>Parallel Scavenge 收集器的老年代版本**。使用多线程和“标记-整理”算法</p>
<h3 id="JVM-GC调优"><a href="#JVM-GC调优" class="headerlink" title="JVM GC调优"></a>JVM GC调优</h3><p><strong>参数基本策略：</strong></p>
<p>各分区的大小对GC的性能影响很大。如何将各分区调整到合适的大小，分析活跃数据的大小是很好的切入点。</p>
<p><strong>活跃数据的大小</strong>是指，应用程序稳定运行时长期存活对象在堆中占用的空间大小，也就是Full GC后堆中老年代占用空间的大小。可以通过GC日志中Full GC之后老年代数据大小得出</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210911100540.png" alt=""></p>
<p>例如，根据GC日志获得老年代的活跃数据大小为300M，那么各分区大小可以设为：</p>
<blockquote>
<p>总堆：1200MB = 300MB × 4* 新生代：450MB = 300MB × 1.5* 老年代： 750MB = 1200MB - 450MB*</p>
</blockquote>
<p><strong>这部分设置仅仅是堆大小的初始值，后面的优化中，可能会调整这些值，具体情况取决于应用程序的特性和需求。</strong></p>
<p>GC优化一般步骤可以概括为：确定目标、优化参数、验收结果。</p>
<p><strong>确定目标：</strong>低延迟还是高吞吐量</p>
<p><strong>优化参数：</strong>结合需求选用合适的GC回收器、重新设置内存比例、调整JVM参数</p>
<h4 id="Minor-GC和Major-GC频繁"><a href="#Minor-GC和Major-GC频繁" class="headerlink" title="Minor GC和Major GC频繁"></a>Minor GC和Major GC频繁</h4><p><strong>优化</strong></p>
<p>首先优化Minor GC频繁问题。通常情况下，由于新生代空间较小，Eden区很快被填满，就会导致频繁Minor GC，因此可以通过增大新生代空间来降低Minor GC的频率。例如在相同的内存分配率的前提下，新生代中的Eden区增加一倍，Minor GC的次数就会减少一半。</p>
<p><strong>扩容Eden区虽然可以减少Minor GC的次数，但会增加单次Minor GC时间么</strong>？我们结合下面情况来分析，单次Minor GC时间主要受哪些因素影响？是否和新生代大小存在线性关系？ 首先，单次Minor GC时间由以下两部分组成：T1（扫描新生代）和 T2（复制存活对象到Survivor区）如下图。（注：这里为了简化问题，我们认为T1只扫描新生代判断对象是否存活的时间，其实该阶段还需要扫描部分老年代）</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/6eb9b856.png" alt="img"></p>
<ul>
<li>扩容前：新生代容量为R ，假设对象A的存活时间为750ms，Minor GC间隔500ms，那么本次Minor GC时间= T1（扫描新生代R）+T2（复制对象A到S）。</li>
<li>扩容后：新生代容量为2R ，对象A的生命周期为750ms，那么Minor GC间隔增加为1000ms，此时Minor GC对象A已不再存活，不需要把它复制到Survivor区，那么本次GC时间 = 2 × T1（扫描新生代R），没有T2复制时间。</li>
</ul>
<p>可见，扩容后，Minor GC时增加了T1（扫描时间），但省去T2（复制对象）的时间，更重要的是对于虚拟机来说，复制对象的成本要远高于扫描成本，所以，单次<strong>Minor GC时间更多取决于GC后存活对象的数量，而非Eden区的大小</strong>。因此<strong>如果堆中短期对象很多，那么扩容新生代，单次Minor GC时间不会显著增加</strong>。下面需要确认下服务中对象的生命周期分布情况：<strong>对象生命周期的分布情况：如果应用存在大量的短期对象，应该选择较大的年轻代；如果存在相对较多的持久对象，老年代应该适当增大。</strong></p>
<h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210910164815.png" alt=""></p>
<p><strong>加载：</strong>类加载过程的第一步，主要完成下面 3 件事情：</p>
<ol>
<li>通过全类名获取定义此类的二进制字节流</li>
<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口</li>
</ol>
<p><strong>连接：</strong></p>
<ol>
<li><strong>验证：</strong>验证加载进来的数据是否符合虚拟机的规范，并且不会危害JVM虚拟机的安全。验证包括文件格式验证，元数据验证，字节码验证，符号引用验证。</li>
<li><strong>准备：</strong>给<strong>静态变量</strong>分配内存空间，并设置默认值；给<strong>静态常量</strong>直接赋初值。</li>
<li><strong>解析：</strong>解析过程是将常量池内的符号引用替换成直接引用。主要包括四种类型引用的解析。类或接口的解析、字段解析、方法解析、接口方法解析.</li>
</ol>
<p><strong>初始化：</strong>执行给类变量赋值和执行静态代码块里面的内容，<strong>如果这个类继承了父类，那么先执行父类的类变量赋值和静态代码块的内容</strong></p>
<blockquote>
<p><strong>数组类型不通过类加载器创建，它由 Java 虚拟机直接创建</strong></p>
</blockquote>
<h4 id="知道哪些类加载器"><a href="#知道哪些类加载器" class="headerlink" title="知道哪些类加载器"></a>知道哪些类加载器</h4><p>JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>：</p>
<ol>
<li><strong>BootstrapClassLoader(启动类加载器)</strong> ：最顶层的加载类，由 C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的 jar 包和类或者被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</li>
<li><strong>ExtensionClassLoader(扩展类加载器)</strong> ：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的 jar 包。</li>
<li><strong>AppClassLoader(应用程序类加载器)</strong> ：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</li>
</ol>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>每一个类都有一个对应它的类加载器。系统中的 ClassLoader 在协同工作的时候会默认使用 <strong>双亲委派模型</strong> 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派给父类加载器的 <code>loadClass()</code> 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器。</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210910165114.png" alt=""></p>
<blockquote>
<p><code>AppClassLoader</code>的父类加载器为<code>ExtClassLoader</code>， <code>ExtClassLoader</code>的父类加载器为 null，<strong>null 并不代表<code>ExtClassLoader</code>没有父类加载器，而是 <code>BootstrapClassLoader</code></strong> </p>
</blockquote>
<p><strong>双亲委派模型的好处</strong></p>
<p>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现多个不同的 <code>Object</code> 类。</p>
<p><strong>如果不想使用双亲委派模型</strong></p>
<p>为了避免双亲委派模型，可以自定义一个类加载器，然后重载loadClass()</p>
<p><strong>如何自定义类加载器</strong></p>
<p>除了BootStrapClassLoader,其他类加载器均由Java实现，且全部继承自Java.lang.ClassLoader，如果要自定义类加载器，需要继承ClassLoader。</p>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20211020170241.png" alt=""></p>
<ul>
<li><p><strong>Spring Core：</strong> 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注⼊功能。</p>
</li>
<li><p><strong>Spring Aspects</strong> ： 该模块为与AspectJ的集成提供⽀持。</p>
</li>
<li><p><strong>Spring AOP</strong> ：提供了⾯向切⾯的编程实现。</p>
</li>
<li><p><strong>Spring JDBC</strong> : Java数据库连接。</p>
</li>
<li><p><strong>Spring JMS</strong> ：Java消息服务。</p>
</li>
<li><p><strong>Spring ORM</strong> : ⽤于⽀持Hibernate等ORM⼯具。<strong>Spring Web</strong> : 为创建Web应⽤程序提供⽀持。<strong>Spring Test</strong> : 提供了对 JUnit 和 TestNG 测试的⽀持。</p>
</li>
</ul>
<h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>IOC指在程序开发过程中，对象实例的创建不再由调用者管理，而是由Spring容器创建，Spring容器会负责控制程序之间的关系，因此，控制权由程序代码转移到了Spring容器，控制权发生了反转，即控制反转。</p>
<blockquote>
<p>在没有使用Spring的时候，对象需要通过<code>new object()</code>来创建，这个对象是主动创建的，创建对象的主动权由自己把控，这样就会使得对象之间的耦合度高，A对象需要使用合作对象B来共同完成一件事，A要使用B，那么A就对B产生了依赖，也就是A和B之间存在一种耦合关系，并且是紧密耦合在一起，而使用了Spring之后就不一样了，创建合作对象B的工作是由Spring来做的，Spring创建好B对象，然后存储到一个容器里面，当A对象需要使用B对象时，Spring就从存放对象的那个容器里面取出A要使用的那个B对象，然后交给A对象使用，至于Spring是如何创建那个对象，以及什么时候创建好对象的，A对象不需要关心这些细节问题。</p>
</blockquote>
<p>IOC最基本的技术就是反射，通过给出的类名来动态的生成对象，可以让对象在生成时才被决定是哪一种对象，降低耦合。</p>
<p>IOC是工厂模式+反射机制，IOC中的工厂模式内部使用反射来创建对象，对象的实例化都交给工厂完成，通过工厂来获取对象。</p>
<h3 id="Spring-AOP和AspectJ-AOP的区别"><a href="#Spring-AOP和AspectJ-AOP的区别" class="headerlink" title="Spring AOP和AspectJ AOP的区别"></a>Spring AOP和AspectJ AOP的区别</h3><p><strong>Spring AOP 属于运⾏时增强，⽽</strong> <strong>AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，⽽ AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
<p>AspectJ 相⽐于 Spring AOP 功能更加强⼤，但是 Spring AOP 相对来说更简单，</p>
<blockquote>
<p>如果我们的切⾯⽐较少，那么两者性能差异不⼤。但是，当切⾯太多的话，最好选择 AspectJ ， 它⽐Spring AOP 快很多</p>
</blockquote>
<h3 id="Spring中Bean的作用域"><a href="#Spring中Bean的作用域" class="headerlink" title="Spring中Bean的作用域"></a>Spring中Bean的作用域</h3><ul>
<li><strong>Singleton :</strong> Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。</li>
<li><strong>Prototype：</strong>Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象</li>
<li><strong>Request：</strong>每个HTTP请求都会有各自的bean实例，该bean仅在当前HTTP request内有效。</li>
<li><strong>Session：</strong>每⼀次HTTP请求都会产⽣⼀个新的 bean，该bean仅在当前 HTTP session 内有效。</li>
</ul>
<h3 id="Component和-Bean的区别是什么"><a href="#Component和-Bean的区别是什么" class="headerlink" title="@Component和@Bean的区别是什么"></a>@Component和@Bean的区别是什么</h3><ol>
<li>作用对象不同：@Component注解作用于类，@Bean作用于方法</li>
<li>@Component通常是通过类路径扫描来⾃动侦测以及⾃动装配到Spring容器中（我们可以使@ComponentScan注解定义要扫描的路径；@Bean注解通常是我们在标有该注解的⽅法中定义产⽣这个Bean的方法。</li>
<li>@Bean注解比@Component注解的自定义性更强。</li>
</ol>
<h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><ol>
<li>实例化一个Bean</li>
<li>按照Spring上下文对实例化的Bean进行配置 （IOC注入）</li>
<li>如果Bean实现了BeanNameAware接口，则调用setBeanName(String)方法，传递的是配置文件中Bean的id</li>
<li>如果实现了BeanFactoryAware接口，则调用setBeanFactory(BeanFactory)</li>
<li>如果这个Bean关联了BeanPostProcessor接口，将会调用<code>postProcessBeforeInitialization(Object obj, String s)</code>方法，BeanPostProcessor经常被用作是Bean内容的更改，并且由于这个是在Bean初始化结束时调用那个的方法，也可以被应用于内存或缓存技术；</li>
<li>如果Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。</li>
<li>如果这个Bean关联了BeanPostProcessor接口，将会调用<code>postProcessAfterInitialization(Object obj, String s)</code>方法；</li>
<li>当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用那个其实现的destroy()方法；</li>
<li>最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。</li>
</ol>
<h3 id="SpringMVC的流程"><a href="#SpringMVC的流程" class="headerlink" title="SpringMVC的流程"></a>SpringMVC的流程</h3><p>MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p>
<p><img src="https://camo.githubusercontent.com/0fd35900c32b252a18ff38855ae52192f90f8884f1622bb5f92578fe68c6cb2f/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f64653664326232313366313132323937323938663365323233626630386632382e706e67" alt="img"></p>
<ol>
<li>客户端（浏览器）发送请求，直接请求到 <code>DispatcherServlet</code>。</li>
<li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。</li>
<li>解析到对应的 <code>Handler</code>（也就是我们说的 <code>Controller</code> 控制器）后，开始由 <code>HandlerAdapter</code> 适配器处理。</li>
<li><code>HandlerAdapter</code> 会根据 <code>Handler</code>来调用真正的处理器开处理请求，并处理相应的业务逻辑。</li>
<li>处理器处理完业务后，会返回一个 <code>ModelAndView</code> 对象，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li>
<li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li>
<li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li>
<li>把 <code>View</code> 返回给请求者（浏览器）</li>
</ol>
<h3 id="Spring框架中用到了哪些设计模式"><a href="#Spring框架中用到了哪些设计模式" class="headerlink" title="Spring框架中用到了哪些设计模式"></a>Spring框架中用到了哪些设计模式</h3><ul>
<li><p><strong>工厂设计模式 :</strong> Spring使⽤⼯⼚模式通过<code>BeanFactory</code>，<code>ApplicationContext</code>创建Bean对象。</p>
</li>
<li><p><strong>代理设计模式：</strong>SpringAOP功能的实现</p>
</li>
<li><p><strong>单例设计模式：</strong>Spring中的Bean默认是单例的。</p>
<p>…</p>
</li>
</ul>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="简单介绍一下redis"><a href="#简单介绍一下redis" class="headerlink" title="简单介绍一下redis"></a>简单介绍一下redis</h3><p>简单来说，redis就是一个数据库，不过与传统数据库不同的是redis的数据是存储在内存中的，所以读写速度非常快，因此redis被广泛应用于缓存方向，redis提供了多种数据类型来支持不同的业务场景。</p>
<p><strong>缓存数据的处理流程是怎样的：</strong></p>
<ol>
<li>如果用户请求的数据在缓存中就直接返回。</li>
<li>缓存中不存在的话就看数据库中是否存在。</li>
<li>数据库中存在的话就更新缓存中的数据。</li>
<li>数据库中不存在的话就返回空数据。</li>
</ol>
<h3 id="redis常见数据结构"><a href="#redis常见数据结构" class="headerlink" title="redis常见数据结构"></a>redis常见数据结构</h3><p><strong>String</strong></p>
<p><strong>介绍</strong> ：string 数据结构是简单的 key-value 类型。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)。</p>
<p><strong>应用场景：</strong> 一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。</p>
<p><strong>list</strong></p>
<p>Redis 的 list 的实现为一个 <strong>双向链表</strong>，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p>
<p><strong>应用场景</strong>:发布与订阅或者说消息队列、慢查询。</p>
<p><strong>hash：</strong></p>
<p>hash 是一个 string 类型的 field 和 value 的映射表，<strong>特别适合用于存储对象</strong>，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。</p>
<p><strong>应用场景:</strong> 系统中对象数据的存储。</p>
<p><strong>set</strong></p>
<p>Redis 中的 set 类型是一种无序集合，集合中的元素没有先后顺序。 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作</p>
<p><strong>sorted set</strong></p>
<p>和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。</p>
<h3 id="为什么要用redis缓存"><a href="#为什么要用redis缓存" class="headerlink" title="为什么要用redis缓存"></a>为什么要用redis缓存</h3><p><strong>高性能:</strong></p>
<p>假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，因为是从硬盘中读取的，将用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变之后，同步改变缓存中相应的数据即可。</p>
<p><strong>高并发：</strong></p>
<p>直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。</p>
<h3 id="redis和memcached"><a href="#redis和memcached" class="headerlink" title="redis和memcached"></a>redis和memcached</h3><p><strong>共同点</strong> ：</p>
<ol>
<li>都是基于内存的数据库，一般都用来当做缓存使用。</li>
<li>都有过期策略。</li>
<li>两者的性能都非常高。</li>
</ol>
<p><strong>区别</strong> ：</p>
<ol>
<li><strong>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</strong>。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。</li>
<li><strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memecache 把数据全部存在内存之中。</strong></li>
<li><strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</li>
<li><strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></li>
<li><strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。</strong></li>
<li><strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</strong> （Redis 6.0 引入了多线程 IO ）</li>
</ol>
<h3 id="Redis给缓存数据设置过期时间"><a href="#Redis给缓存数据设置过期时间" class="headerlink" title="Redis给缓存数据设置过期时间"></a>Redis给缓存数据设置过期时间</h3><p>⼀般情况下，我们设置保存的缓存数据的时候都会设置⼀个过期时间。为什么呢？</p>
<p> 因为内存是有限的，如果缓存中的所有数据都是⼀直保存的话，分分钟直接OOM。Redis ⾃带了给缓存数据设置过期时间的功能，比如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exp key 60 # 数据在 60s 后过期</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; setex key 60 value # 数据在 60s 后过期 (setex:[set] + [ex]pire) </span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key # 查看数据还有多久过期</span><br><span class="line">(integer) 56</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Redis中除了字符串类型有⾃⼰独有设置过期时间的命令<code>setex</code>外，其他方法都要依靠<code>expire</code>命令来设置过期时间。<code>persist</code>命令可以移除一个键的过期时间。</p>
</blockquote>
<p><strong>过期时间除了有助于缓解内存的消耗，还有什么其他⽤么？</strong></p>
<p>很多时候，我们的业务场景就是需要某个数据只在某⼀时间段内存在，⽐如我们的短信验证码可能只在1分钟内有效，⽤户登录的 token 可能只在 1 天内有效。如果使⽤传统的数据库来处理的话，⼀般都是⾃⼰判断过期，这样更麻烦并且性能要差很多。</p>
<h3 id="Redis如何判断数据是否过期"><a href="#Redis如何判断数据是否过期" class="headerlink" title="Redis如何判断数据是否过期"></a>Redis如何判断数据是否过期</h3><p>Redis 通过⼀个叫做过期字典（可以看作是hash表）来保存数据过期的时间。过期字典的键指向Redis数据库中的某个key(键)，过期字典的值是⼀个long long类型的整数，这个整数保存了key所指向的数据库键的过期时间（毫秒精度的UNIX时间戳）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20211020193524.png" alt=""></p>
<h3 id="redis过期数据的删除策略"><a href="#redis过期数据的删除策略" class="headerlink" title="redis过期数据的删除策略"></a>redis过期数据的删除策略</h3><p>如果假设你设置了⼀批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进⾏删除的呢？</p>
<p><strong>常用的过期数据的删除策略就两个</strong></p>
<ol>
<li><strong>惰性删除</strong> ：只会在取出key的时候才对数据进⾏过期检查。这样对CPU最友好，但是可能会造成太多过期 key 没有被删除。</li>
<li><strong>定期删除</strong> ： 每隔⼀段时间抽取⼀批 key 执⾏删除过期key操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</li>
</ol>
<p><strong>redis采用定期删除+惰性删除</strong>策略</p>
<h3 id="redis内存淘汰机制"><a href="#redis内存淘汰机制" class="headerlink" title="redis内存淘汰机制"></a>redis内存淘汰机制</h3><blockquote>
<p>相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</p>
</blockquote>
<p>Redis 提供 6 种数据淘汰策略：</p>
<ol>
<li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集中挑选将要过期的数据淘汰</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集中任意选择数据淘汰</li>
<li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（最常用的）</li>
<li><strong>allkeys-random</strong>：从数据集中任意选择数据淘汰</li>
<li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。</li>
</ol>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。</p>
<h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。</p>
<p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p>
<p>加入布隆过滤器之后的缓存处理流程图如下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210914095535.png" alt=""></p>
<p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p>
<p><em>为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！</em></p>
<p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p>
<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>
</ol>
<p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p>
<ol>
<li>对给定元素再次进行相同的哈希计算；</li>
<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>
</ol>
<p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong></p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>实际上，缓存雪崩描述的就是这样一个简单的场景：<strong>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</strong> 这就好比雪崩一样</p>
<p>举个例子：系统的缓存模块出了问题比如宕机导致不可用。造成系统的所有访问，都要走数据库。</p>
<p>还有一种缓存雪崩的场景是：<strong>有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上</strong></p>
<p><strong>有哪些解决办法？</strong></p>
<p><strong>针对 Redis 服务不可用的情况：</strong></p>
<ol>
<li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li>
<li>限流，避免同时处理大量的请求。</li>
</ol>
<p><strong>针对热点缓存失效的情况：</strong></p>
<ol>
<li>设置不同的失效时间比如随机设置缓存的失效时间。</li>
<li>缓存永不失效。</li>
</ol>
<h3 id="redis的持久化"><a href="#redis的持久化" class="headerlink" title="redis的持久化"></a>redis的持久化</h3><p>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持两种不同的持久化操作。<strong>Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）</strong>。</p>
<p><strong>快照（snapshotting）持久化（RDB）</strong></p>
<p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p>
<p><strong>AOF（append-only file）持久化</strong></p>
<p>与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 <code>server.aof_buf</code> 中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件。</p>
<p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 <code>appendonly.aof</code>。</p>
<p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span><br><span class="line">appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘</span><br><span class="line">appendfsync no        #让操作系统决定何时进行同步</span><br></pre></td></tr></table></figure>

<p>为了兼顾数据和写入性能，用户可以考虑 <code>appendfsync everysec</code> 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p>
<h3 id="如何保证缓存与数据库双写时的一致性"><a href="#如何保证缓存与数据库双写时的一致性" class="headerlink" title="如何保证缓存与数据库双写时的一致性"></a>如何保证缓存与数据库双写时的一致性</h3><p>对 <strong>Cache Aside Pattern（旁路缓存模式）</strong></p>
<p>Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。</p>
<p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：</p>
<ol>
<li><strong>增加 cache 更新重试机制（常用）</strong>： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。</li>
</ol>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h3><p><strong>MyISAM和InnoDB区别：</strong></p>
<p>MyISAM是MySQL的默认数据库引擎(5.5之前),当前的默认存储引擎为InnoDB</p>
<p><strong>1. 是否支持行级锁</strong></p>
<p>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</p>
<p><strong>2.是否支持事务</strong></p>
<p>MyISAM 不提供事务支持。</p>
<p>InnoDB 提供事务支持，具有提交(commit)和回滚(rollback)事务的能力。</p>
<p><strong>3.是否支持外键</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p><strong>4.是否支持数据库异常崩溃后的安全恢复</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code> 。</p>
<blockquote>
<p><strong>表级锁和行级锁对比：</strong></p>
<ul>
<li><strong>表级锁：</strong> MySQL 中锁定 <strong>粒度最大</strong> 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。</li>
<li><strong>行级锁：</strong> MySQL 中锁定 <strong>粒度最小</strong> 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li>
</ul>
</blockquote>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>MySQL索引使⽤的数据结构主要有<strong>BTree索引</strong> 和 <strong>哈希索引</strong> 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝⼤多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最  快；其余⼤部分场景，建议选择BTree索引。</p>
<p>MySQL的BTree索引使⽤的是B+树</p>
<p><strong>InnoDB</strong> 其数据⽂件本身就是索引⽂件。树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据⽂件本身就是主索引。⽽其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值⽽不是地址。在根据主索引搜索时，直接找到key所 在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再⾛⼀遍主索引。 因此，在设计表的时候，不建议使⽤过⻓的字段作为主键，也不建议使⽤⾮单调的字段作为主键，这样会造成主索引频繁分裂。</p>
<h3 id="MySQL的事务"><a href="#MySQL的事务" class="headerlink" title="MySQL的事务"></a>MySQL的事务</h3><p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p>
<p><strong>什么是数据库事务的作用：</strong>数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：<strong>要么全部执行成功,要么全部不执行</strong> 。</p>
<p><img src="https://camo.githubusercontent.com/d9c8448f21fb27f4565e846dc1b63077c01f3e27e03764940f4e1b8ec4731514/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f323032302d31322f3634302d32303230313230373136303535343637372e706e67" alt="img"></p>
<p><strong>事务的ACID特性：</strong></p>
<ol>
<li><strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li>
<li><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性</strong>（<code>Durability</code>）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<blockquote>
<p><strong>数据事务的实现原理呢？</strong></p>
<p>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</p>
<p>MySQL InnoDB 引擎通过 <strong>锁机制</strong>、<strong>MVCC</strong> 等手段来保证事务的隔离性（ 默认支持的隔离级别是 <strong><code>REPEATABLE-READ</code></strong> ）。</p>
<p>保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。</p>
</blockquote>
<p><strong>并发事务带来的问题：</strong></p>
<ul>
<li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li>
<li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。</li>
<li><strong>不可重复读（Unrepeatable read）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li>
<li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<h3 id="事务隔离级别有哪些"><a href="#事务隔离级别有哪些" class="headerlink" title="事务隔离级别有哪些"></a>事务隔离级别有哪些</h3><ul>
<li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li>
<li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li>
<li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li>
<li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li>
</ul>
<blockquote>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong></p>
</blockquote>
<h3 id="大表优化"><a href="#大表优化" class="headerlink" title="大表优化"></a>大表优化</h3><p>当MySQL单表记录数过⼤时，数据库的CRUD性能会明显下降，⼀些常⻅的优化措施如下：</p>
<p><strong>限定数据的范围</strong></p>
<p>务必禁⽌不带任何限制数据范围条件的查询语句。⽐如：我们当⽤户在查询订单历史的时候，我们可以控制在⼀个⽉的范围内；</p>
<p><strong>读/写分离</strong></p>
<p>经典的数据库拆分⽅案，主库负责写，从库负责读；</p>
<p><strong>垂直分区</strong></p>
<p>垂直拆分是指数据表列的拆分，把⼀张列⽐较多的表拆分为多张表。 如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20211020203359.png" alt=""></p>
<ul>
<li><strong>垂直拆分的优点：</strong> 可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</li>
<li><strong>垂直拆分的缺点：</strong>主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应⽤层进⾏Join来解决。此外，垂直分区会让事务变得更加复杂；</li>
</ul>
<p><strong>水平分区：</strong>持数据表结构不变，通过某种策略存储数据分⽚。这样每⼀⽚数据分散到不同的表或者库中， 达到了分布式的⽬的。 ⽔平拆分可以⽀撑⾮常⼤的数据量。</p>
<blockquote>
<p>⽔平拆分可以⽀持⾮常⼤的数据量。需要注意的⼀点是：分表仅仅是解决了单⼀表数据过⼤的问题，但由于表的数据还是在同⼀台机器上，其实对于提升MySQL并发能⼒没有什么意义，所以⽔平拆分最好分库 。</p>
</blockquote>
<h3 id="一条SQL执行的很慢有哪些原因"><a href="#一条SQL执行的很慢有哪些原因" class="headerlink" title="一条SQL执行的很慢有哪些原因"></a>一条SQL执行的很慢有哪些原因</h3><p>一个 SQL 执行的很慢，我们要分两种情况讨论：</p>
<p>1、大多数情况下很正常，偶尔很慢，则有如下原因</p>
<p>(1)、数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。</p>
<p>(2)、执行的时候，遇到锁，如表锁、行锁。</p>
<p>2、这条 SQL 语句一直执行的很慢，则有如下原因。</p>
<p>(1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。</p>
<p>(2)、数据库选错了索引。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Java中的异常体系"><a href="#Java中的异常体系" class="headerlink" title="Java中的异常体系"></a>Java中的异常体系</h3><p>Java标准裤内建了一些通用的异常，这些类以Throwable为顶层父类，Throwable又派生出Error类和Exception类。</p>
<p><strong>Error</strong>：Error类以及他的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理。</p>
<p><strong>Exception</strong>：Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210908191952.png" alt=""></p>
<p><strong>根据Javac对异常的处理要求，将异常类分为2类</strong></p>
<p><strong>非检查异常</strong>（unckecked exception）：Error 和 RuntimeException 以及他们的子类。javac在编译时，不会提示和发现这样的异常，不要求在程序处理这些异常。所以如果愿意，我们可以编写代码处理（使用try…catch…finally）这样的异常，也可以不处理。对于这些异常，我们应该修正代码，而不是去通过异常处理器处理 。这样的异常发生的原因多半是代码写的有问题。如除0错误ArithmeticException，错误的强制类型转换错误ClassCastException，数组索引越界ArrayIndexOutOfBoundsException，使用了空对象NullPointerException等等。 </p>
<p><strong>检查异常</strong>（checked exception）：除了Error 和 RuntimeException的其它异常。javac强制要求程序员为这样的异常做预备处理工作（使用try…catch…finally或者throws）。在方法中要么用try-catch语句捕获它并处理，要么用throws子句声明抛出它，否则编译不会通过。这样的异常一般是由程序的运行环境导致的。因为程序可能被运行在各种未知的环境下，而程序员无法干预用户如何使用他编写的程序，于是程序员就应该为这样的异常时刻准备着。如SQLException , IOException,ClassNotFoundException 等。</p>
<p>需要明确的是：检查和非检查是对于javac来说的，这样就很好理解和区分了</p>
<p><strong>多个异常的捕获顺序</strong></p>
<p>对于try..catch捕获异常的形式来说，对于异常的捕获，可以有多个catch。对于try里面发生的异常，他会根据发生的异常和catch里面的进行从上往下匹配，当它匹配某一个catch块的时候，他就直接进入到这个catch块里面去了，后面在再有catch块的话，它不做任何处理，直接跳过去，全部忽略掉。如果有finally的话进入到finally里面继续执行。换句话说，如果有匹配的catch，它就会忽略掉这个catch后面所有的catch。</p>
<p><strong>在写异常处理的时候，一定要把异常范围小的放在前面，范围大的放在后面</strong>，Exception这个异常的根类一定要放在最后一个catch里面，如果放在前面或者中间，任何异常都会和Exception匹配的，就会报已捕获到…异常的错误。 </p>
<p><strong>throws和throw</strong></p>
<p><strong>Throw</strong>：<strong>作用在方法内</strong>，表示抛出具体异常，由方法体内的语句处理。具体向外抛出的动作，所以它抛出的是一个异常实体类。若执行了throw一定是抛出了某种异常。</p>
<p><strong>throws</strong>：作用在<strong>方法的声明上</strong>，表示如果抛出异常，则由该方法的调用者来进行异常处理。（自身不处理异常）</p>
<p>主要的声明这个方法会抛出会抛出某种类型的异常，让它的使用者知道捕获异常的类型。出现异常是一种可能性，但不一定会发生异常。</p>
<h3 id="BIO，NIO，AIO"><a href="#BIO，NIO，AIO" class="headerlink" title="BIO，NIO，AIO"></a>BIO，NIO，AIO</h3><p><strong>同步与异步</strong></p>
<ul>
<li><strong>同步：</strong> 同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回。</li>
<li><strong>异步：</strong> 异步就是发起一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他的请求，被调用者通常依靠事件，回调等机制来通知调用者其返回结果。</li>
</ul>
<p>同步和异步的区别最大在于异步的话调用者不需要等待处理结果，被调用者会通过回调等机制来通知调用者其返回结果。</p>
<p><strong>阻塞和非阻塞</strong></p>
<ul>
<li><strong>阻塞：</strong> 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。</li>
<li><strong>非阻塞：</strong> 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。</li>
</ul>
<p><strong>BIO:</strong><code>同步阻塞</code>，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不作任何事情会造成不必要的线程开销。</p>
<p><strong>NIO</strong>：<code>同步非阻塞</code>，服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求会被注册到多路复用器（selector）上，多路复用器轮询到有 I/O 请求就会进行处理,通过轮询代替了始终保持一个连接。</p>
<blockquote>
<p>客户端发送一个请求，并建立一个连接，服务端接收到了。如果服务端没有数据，就告知客户端“没有数据”；如果有数据，则返回数据。客户端接到了服务端回复的“没有数据”就断开连接，过了一段时间后，客户端重新问服务端是否有数据。服务器重复以上步骤。</p>
</blockquote>
<blockquote>
<p>Selector： 多路复用器，轮询检查多个Channel 的状态，判断注册事件是否发生，即判断Channel 是否处于可读或可写状态。使用前需要将Channel 注册到Selector，注册后会得到一个SelectionKey，通过SelectionKey 获取Channel 和Selector 相关信息。<br>Channel： 双向通道，替换了BIO 中的Stream 流，不能直接访问数据，要通过Buffer 来读写数据，也可以和其他Channel 交互。<br>Buffer： 缓冲区，本质是一块可读写数据的内存，用来简化数据读写</p>
</blockquote>
<p><strong>AIO：</strong><code>异步非阻塞</code>，AIO 引入了异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。</p>
<blockquote>
<p>客户端向服务端请求数据。服务端若有，则返回数据；若无，则告诉客户端“没有数据”。客户端收到“没有数据”的回复后，就做自己的其他事情。服务端有了数据之后，就主动通知客户端，并把数据返回去</p>
</blockquote>
<blockquote>
<p>BIO 方式适用于<code>连接数比较小且固定</code>的架构</p>
<p>NIO 方式适用于<code>连接数目多且连接比较短</code>的架构，比如聊天服务器，弹幕系统</p>
<p>AIO 方式适用于<code>连接数目多且连接比较长</code>的架构，比如相册服务器</p>
</blockquote>
<h4 id="NIO-和-BIO-对比"><a href="#NIO-和-BIO-对比" class="headerlink" title="NIO 和 BIO 对比"></a>NIO 和 BIO 对比</h4><ol>
<li><p>BIO 以流的方式处理数据，而 NIO 以块的方式处理数据，块 I/O 的效率比流 I/O 高很多。</p>
</li>
<li><p>BIO 是阻塞的，而 NIO 是非阻塞的。</p>
</li>
<li><p>BIO 基于字节流和字符流进行操作，而 NIO 基于 Channel（通道）和 Buffer（缓冲区）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector（选择器）用于监听多个通道事件（比如连接请求，数据到达等），因此<code>使用单个线程就可以监听多个客户端通道</code>。</p>
</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag"># 多线程</a>
          
            <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag"># 计算机网络</a>
          
            <a href="/tags/redis/" rel="tag"># redis</a>
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/MySQL/" rel="tag"># MySQL</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/10/14/DiskGenius%E7%A3%81%E7%9B%98%E5%88%92%E5%88%86/" rel="next" title="DiskGenius磁盘划分">
                <i class="fa fa-chevron-left"></i> DiskGenius磁盘划分
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
     <div id="gitalk-container"></div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/bear.png"
                alt="摸鱼选手Wei" />
            
              <p class="site-author-name" itemprop="name">摸鱼选手Wei</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/CloudMadao" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          
		  
		  

  <div class="links-of-blogroll motion-element links-of-blogroll-block">
   <div class="links-of-blogroll-title">
     <!-- modify icon to fire by szw -->
     <i class="fa fa-history fa-" aria-hidden="true"></i>
     近期文章
   </div>
   <ul class="links-of-blogroll-list">
     
     
       <li>
         <a href="/2021/10/18/Java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/" title="Java面试八股" target="_blank">Java面试八股</a>
       </li>
     
       <li>
         <a href="/2021/10/14/DiskGenius%E7%A3%81%E7%9B%98%E5%88%92%E5%88%86/" title="DiskGenius磁盘划分" target="_blank">DiskGenius磁盘划分</a>
       </li>
     
       <li>
         <a href="/2021/10/13/EndNote%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/" title="EndNote使用指北" target="_blank">EndNote使用指北</a>
       </li>
     
       <li>
         <a href="/2021/09/10/java%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/" title="java面试笔记" target="_blank">java面试笔记</a>
       </li>
     
       <li>
         <a href="/2020/05/29/%E8%AE%B0%E4%B8%80%E6%AC%A1CentOs7%E4%B8%8A%E5%AE%89%E8%A3%85Oracle%E7%9A%84%E8%B8%A9%E5%9D%91%E8%BF%87%E7%A8%8B/" title="记一次CentOs7上安装Oracle的踩坑过程" target="_blank">记一次CentOs7上安装Oracle的踩坑过程</a>
       </li>
     
   </ul>
  </div>
 
  
           
         
         
<div style="">
  <canvas id="canvas" style="width:60%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
</div>
<script>
(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();
</script>
        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java面试八股"><span class="nav-number">1.</span> <span class="nav-text">Java面试八股</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap"><span class="nav-number">2.</span> <span class="nav-text">HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-1"><span class="nav-number">2.1.</span> <span class="nav-text">HashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap的长度为什么是2的幂次"><span class="nav-number">2.2.</span> <span class="nav-text">HashMap的长度为什么是2的幂次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap线程不安全在哪"><span class="nav-number">2.3.</span> <span class="nav-text">HashMap线程不安全在哪</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap和TreeMap"><span class="nav-number">2.4.</span> <span class="nav-text">HashMap和TreeMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap和HashSet"><span class="nav-number">2.5.</span> <span class="nav-text">HashMap和HashSet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合的选用"><span class="nav-number">2.6.</span> <span class="nav-text">集合的选用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程"><span class="nav-number">3.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程与进程"><span class="nav-number">3.1.</span> <span class="nav-text">线程与进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#程序计数器为什么私有"><span class="nav-number">3.1.1.</span> <span class="nav-text">程序计数器为什么私有</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟机栈和本地方法栈为什么私有"><span class="nav-number">3.1.2.</span> <span class="nav-text">虚拟机栈和本地方法栈为什么私有</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆和方法区"><span class="nav-number">3.1.3.</span> <span class="nav-text">堆和方法区</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程的生命周期"><span class="nav-number">3.2.</span> <span class="nav-text">线程的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多线程中的上下文切换"><span class="nav-number">3.3.</span> <span class="nav-text">多线程中的上下文切换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁"><span class="nav-number">3.4.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#如何避免死锁"><span class="nav-number">3.4.1.</span> <span class="nav-text">如何避免死锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep-方法和wait-方法区别和共同点"><span class="nav-number">3.5.</span> <span class="nav-text">sleep()方法和wait()方法区别和共同点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调用start-时会执行run-为什么不直接执行run"><span class="nav-number">3.6.</span> <span class="nav-text">调用start()时会执行run(),为什么不直接执行run()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized关键字"><span class="nav-number">3.7.</span> <span class="nav-text">synchronized关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized关键字的使用"><span class="nav-number">3.7.1.</span> <span class="nav-text">synchronized关键字的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized关键字和volatile关键字的区别"><span class="nav-number">3.7.2.</span> <span class="nav-text">synchronized关键字和volatile关键字的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized关键字和Lock的区别"><span class="nav-number">3.7.3.</span> <span class="nav-text">synchronized关键字和Lock的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池"><span class="nav-number">3.8.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用线程池的好处："><span class="nav-number">3.8.1.</span> <span class="nav-text">使用线程池的好处：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何创建线程池"><span class="nav-number">3.8.2.</span> <span class="nav-text">如何创建线程池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程池都有哪些工作队列"><span class="nav-number">3.8.3.</span> <span class="nav-text">线程池都有哪些工作队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadPoolExecutor构造函数参数"><span class="nav-number">3.8.4.</span> <span class="nav-text">ThreadPoolExecutor构造函数参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多线程开发带来的问题与解决办法"><span class="nav-number">3.9.</span> <span class="nav-text">多线程开发带来的问题与解决办法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程安全问题："><span class="nav-number">3.9.1.</span> <span class="nav-text">线程安全问题：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#性能问题"><span class="nav-number">3.9.2.</span> <span class="nav-text">性能问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重入锁"><span class="nav-number">3.10.</span> <span class="nav-text">重入锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS-AbstractQueuedSynchronizer"><span class="nav-number">3.11.</span> <span class="nav-text">AQS(AbstractQueuedSynchronizer)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AQS原理概览"><span class="nav-number">3.11.1.</span> <span class="nav-text">AQS原理概览</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单例模式"><span class="nav-number">3.12.</span> <span class="nav-text">单例模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#双重检查锁实现单例：-使用了synchronized和volatile关键字-线程安全"><span class="nav-number">3.12.1.</span> <span class="nav-text">双重检查锁实现单例：(使用了synchronized和volatile关键字)-线程安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态内部类实现单例-懒加载-线程安全"><span class="nav-number">3.12.2.</span> <span class="nav-text">静态内部类实现单例(懒加载)-线程安全</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-IP"><span class="nav-number">4.</span> <span class="nav-text">TCP&#x2F;IP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#三次握手的过程"><span class="nav-number">4.1.</span> <span class="nav-text">三次握手的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么TCP客户端最后还要发送一次确认呢"><span class="nav-number">4.1.1.</span> <span class="nav-text">为什么TCP客户端最后还要发送一次确认呢?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四次挥手的过程"><span class="nav-number">4.2.</span> <span class="nav-text">四次挥手的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么建立连接是三次握手，释放连接确实四次挥手？"><span class="nav-number">4.2.1.</span> <span class="nav-text">为什么建立连接是三次握手，释放连接确实四次挥手？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三次握手过程中可以携带数据嘛"><span class="nav-number">4.3.</span> <span class="nav-text">三次握手过程中可以携带数据嘛</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如果已经建立连接，但是客户端出现故障-TCP的保活机制-keapalive长连接"><span class="nav-number">4.4.</span> <span class="nav-text">如果已经建立连接，但是客户端出现故障(TCP的保活机制)(keapalive长连接)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP的重传机制"><span class="nav-number">4.5.</span> <span class="nav-text">TCP的重传机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP的流量控制"><span class="nav-number">4.6.</span> <span class="nav-text">TCP的流量控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#滑动窗口"><span class="nav-number">4.6.1.</span> <span class="nav-text">滑动窗口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拥塞控制"><span class="nav-number">4.7.</span> <span class="nav-text">拥塞控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP的可靠性"><span class="nav-number">4.8.</span> <span class="nav-text">TCP的可靠性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP和UDP的区别"><span class="nav-number">4.9.</span> <span class="nav-text">TCP和UDP的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP和UDP的应用"><span class="nav-number">4.9.1.</span> <span class="nav-text">TCP和UDP的应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在浏览器输入url地址到显示主页的过程"><span class="nav-number">4.10.</span> <span class="nav-text">在浏览器输入url地址到显示主页的过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP"><span class="nav-number">5.</span> <span class="nav-text">HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP是无状态的协议-如何保存用户状态"><span class="nav-number">5.1.</span> <span class="nav-text">HTTP是无状态的协议,如何保存用户状态?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cookie的作用是什么-和Session有什么区别？"><span class="nav-number">5.2.</span> <span class="nav-text">Cookie的作用是什么?和Session有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP和HTTPS的区别"><span class="nav-number">5.3.</span> <span class="nav-text">HTTP和HTTPS的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在浏览器输入url地址到显示主页的过程-1"><span class="nav-number">5.4.</span> <span class="nav-text">在浏览器输入url地址到显示主页的过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM"><span class="nav-number">6.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM-新生代和老年代都使用什么GC算法"><span class="nav-number">6.1.</span> <span class="nav-text">JVM 新生代和老年代都使用什么GC算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#新生代和老年代的区别"><span class="nav-number">6.1.1.</span> <span class="nav-text">新生代和老年代的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可达性算法分析"><span class="nav-number">6.1.2.</span> <span class="nav-text">可达性算法分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#强引用、软引用、弱引用、虚引用"><span class="nav-number">6.2.</span> <span class="nav-text">强引用、软引用、弱引用、虚引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#强引用"><span class="nav-number">6.2.1.</span> <span class="nav-text">强引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#软引用"><span class="nav-number">6.2.2.</span> <span class="nav-text">软引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#弱引用"><span class="nav-number">6.2.3.</span> <span class="nav-text">弱引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚引用"><span class="nav-number">6.2.4.</span> <span class="nav-text">虚引用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM垃圾收集器"><span class="nav-number">6.3.</span> <span class="nav-text">JVM垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CMS-Concurrent-Mark-Sweep-回收器："><span class="nav-number">6.3.1.</span> <span class="nav-text">CMS(Concurrent Mark Sweep)回收器：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#G1收集器"><span class="nav-number">6.3.2.</span> <span class="nav-text">G1收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他收集器"><span class="nav-number">6.3.3.</span> <span class="nav-text">其他收集器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM-GC调优"><span class="nav-number">6.4.</span> <span class="nav-text">JVM GC调优</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Minor-GC和Major-GC频繁"><span class="nav-number">6.4.1.</span> <span class="nav-text">Minor GC和Major GC频繁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类加载机制"><span class="nav-number">6.5.</span> <span class="nav-text">类加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#知道哪些类加载器"><span class="nav-number">6.5.1.</span> <span class="nav-text">知道哪些类加载器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#双亲委派模型"><span class="nav-number">6.5.2.</span> <span class="nav-text">双亲委派模型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring"><span class="nav-number">7.</span> <span class="nav-text">Spring</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IOC"><span class="nav-number">7.1.</span> <span class="nav-text">IOC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-AOP和AspectJ-AOP的区别"><span class="nav-number">7.2.</span> <span class="nav-text">Spring AOP和AspectJ AOP的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring中Bean的作用域"><span class="nav-number">7.3.</span> <span class="nav-text">Spring中Bean的作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Component和-Bean的区别是什么"><span class="nav-number">7.4.</span> <span class="nav-text">@Component和@Bean的区别是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bean的生命周期"><span class="nav-number">7.5.</span> <span class="nav-text">Bean的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringMVC的流程"><span class="nav-number">7.6.</span> <span class="nav-text">SpringMVC的流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring框架中用到了哪些设计模式"><span class="nav-number">7.7.</span> <span class="nav-text">Spring框架中用到了哪些设计模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis"><span class="nav-number">8.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简单介绍一下redis"><span class="nav-number">8.1.</span> <span class="nav-text">简单介绍一下redis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis常见数据结构"><span class="nav-number">8.2.</span> <span class="nav-text">redis常见数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要用redis缓存"><span class="nav-number">8.3.</span> <span class="nav-text">为什么要用redis缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis和memcached"><span class="nav-number">8.4.</span> <span class="nav-text">redis和memcached</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis给缓存数据设置过期时间"><span class="nav-number">8.5.</span> <span class="nav-text">Redis给缓存数据设置过期时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis如何判断数据是否过期"><span class="nav-number">8.6.</span> <span class="nav-text">Redis如何判断数据是否过期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis过期数据的删除策略"><span class="nav-number">8.7.</span> <span class="nav-text">redis过期数据的删除策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis内存淘汰机制"><span class="nav-number">8.8.</span> <span class="nav-text">redis内存淘汰机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存穿透"><span class="nav-number">8.9.</span> <span class="nav-text">缓存穿透</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#布隆过滤器"><span class="nav-number">8.9.1.</span> <span class="nav-text">布隆过滤器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存雪崩"><span class="nav-number">8.10.</span> <span class="nav-text">缓存雪崩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis的持久化"><span class="nav-number">8.11.</span> <span class="nav-text">redis的持久化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何保证缓存与数据库双写时的一致性"><span class="nav-number">8.12.</span> <span class="nav-text">如何保证缓存与数据库双写时的一致性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL"><span class="nav-number">9.</span> <span class="nav-text">MySQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL存储引擎"><span class="nav-number">9.1.</span> <span class="nav-text">MySQL存储引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引"><span class="nav-number">9.2.</span> <span class="nav-text">索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL的事务"><span class="nav-number">9.3.</span> <span class="nav-text">MySQL的事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事务隔离级别有哪些"><span class="nav-number">9.4.</span> <span class="nav-text">事务隔离级别有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#大表优化"><span class="nav-number">9.5.</span> <span class="nav-text">大表优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一条SQL执行的很慢有哪些原因"><span class="nav-number">9.6.</span> <span class="nav-text">一条SQL执行的很慢有哪些原因</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他"><span class="nav-number">10.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java中的异常体系"><span class="nav-number">10.1.</span> <span class="nav-text">Java中的异常体系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BIO，NIO，AIO"><span class="nav-number">10.2.</span> <span class="nav-text">BIO，NIO，AIO</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#NIO-和-BIO-对比"><span class="nav-number">10.2.1.</span> <span class="nav-text">NIO 和 BIO 对比</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
          


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">摸鱼选手Wei</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        
<div class="busuanzi-count">
 <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
	<script src="/js/md5.min.js"></script>
    <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: '189bc28497572ad87947',
          clientSecret: '084a899efcea3646e7ee9ba066db2f077b3b403a',
          repo: 'Blog-Comments',
          owner: 'CloudMadao',
          admin: ['CloudMadao'],
          id: decodeURI(location.pathname),
          distractionFreeMode: 'false'
        })
        gitalk.render('gitalk-container')           
    </script>

  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
