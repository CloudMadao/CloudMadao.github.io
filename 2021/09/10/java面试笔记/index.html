<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="Zfds7O_oYzbVPUTriZY6nqorXSh6sLoYR_zd0WKwBzQ" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Comic Sans MS:300,300italic,400,400italic,700,700italic|Lato:300,300italic,400,400italic,700,700italic|Consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/horse.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/horse.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/horse.png?v=5.1.4">


  <link rel="mask-icon" href="/images/horse.png?v=5.1.4" color="#222">





  <meta name="keywords" content="java,多线程,计算机网络,redis," />










<meta name="description" content="Java面试笔记 来个公司收了我吧">
<meta property="og:type" content="article">
<meta property="og:title" content="java面试笔记">
<meta property="og:url" content="https://cloudmadao.github.io/2021/09/10/java%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Madao&#39;s Personal Website">
<meta property="og:description" content="Java面试笔记 来个公司收了我吧">
<meta property="og:image" content="https://img.php.cn/upload/article/000/000/028/5c73a16ef1c04585.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210907203427.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210907203502.jpg">
<meta property="og:image" content="https://camo.githubusercontent.com/0fd35900c32b252a18ff38855ae52192f90f8884f1622bb5f92578fe68c6cb2f/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f64653664326232313366313132323937323938663365323233626630386632382e706e67">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210908191952.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210911092310.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909160042.png">
<meta property="og:image" content="https://camo.githubusercontent.com/02e863f3d5de3c34484f6162c1d0b3bf8912dbd70ac0a672bb99724f1f47f2d8/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f4a6176612532302545372541382538422545352542412538462545352539312539382545352542462538352545352541342538372545462542432539412545352542392542362545352538462539312545372539462541352545382541462538362545372542332542422545372542422539462545362538302542422545372542422539332f434c482e706e67">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20200409195521.jfif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20200409212059.jfif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909091033.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909091602.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909103101.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909103156.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909151522.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909152412.png">
<meta property="og:image" content="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/01d330d8-2710-4fad-a91c-7bbbfaaefc0e.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909213741.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909213810.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210910143806.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210911100540.png">
<meta property="og:image" content="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/6eb9b856.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210910164815.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210910165114.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210914095535.png">
<meta property="og:image" content="https://camo.githubusercontent.com/d9c8448f21fb27f4565e846dc1b63077c01f3e27e03764940f4e1b8ec4731514/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f323032302d31322f3634302d32303230313230373136303535343637372e706e67">
<meta property="article:published_time" content="2021-09-10T02:49:05.000Z">
<meta property="article:modified_time" content="2021-09-14T02:00:11.188Z">
<meta property="article:author" content="摸鱼选手Wei">
<meta property="article:tag" content="java">
<meta property="article:tag" content="多线程">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.php.cn/upload/article/000/000/028/5c73a16ef1c04585.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://CloudMadao.github.io/2021/09/10/java面试笔记/"/>





  <title>java面试笔记 | Madao's Personal Website</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Madao's Personal Website</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">今天 <s>摸鱼</s> 学习了吗</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://CloudMadao.github.io/2021/09/10/java%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="摸鱼选手Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/bear.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Madao's Personal Website">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">java面试笔记</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-09-10T10:49:05+08:00">
                2021-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="Java面试笔记"><a href="#Java面试笔记" class="headerlink" title="Java面试笔记"></a>Java面试笔记</h3><blockquote>
<p>来个公司收了我吧</p>
</blockquote>
<a id="more"></a>

<h3 id="面向对象与面向过程的区别"><a href="#面向对象与面向过程的区别" class="headerlink" title="面向对象与面向过程的区别"></a>面向对象与面向过程的区别</h3><p>面向过程是让计算机有步骤地顺序做一件事，是过程化思维，在开发大型项目时，软件复用和维护困难，<strong>模块之间耦合严重。</strong>面向对象可以拆解问题的复杂度，<strong>对现实事物进行抽象并映射为开发对象</strong>，更接近人的思维。</p>
<p>面向过程代码松散，强调流程化解决问题，面向对象代码强调高内聚、低耦合，先抽象模型定义共性行为，再解决实际问题。</p>
<h4 id="C-和Java"><a href="#C-和Java" class="headerlink" title="C++和Java"></a>C++和Java</h4><ol>
<li>C++可以继承多个类，Java只能单继承，但是可以实现多个接口</li>
<li>Java又自动内存管理机制，不需要程序员手动释放无用内存</li>
<li>Java不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java和C++都是强类型语言，都存在类的概念，并且都有private，protected，public等访问限定符。</li>
</ol>
<h3 id="面向对象的特点"><a href="#面向对象的特点" class="headerlink" title="面向对象的特点"></a>面向对象的特点</h3><p>封装，继承，多态</p>
<p><strong>封装：</strong>就是把对象的属性和操作封装为一个独立的整体，并尽可能隐藏对象的内部实现细节，并且可以只让可信的类或对象访问自身的数据和方法。</p>
<p><strong>继承：</strong>子类继承父类的特征和行为，使得子类具有父类相同的行为，如果父类中拥有被private修饰属性，则子类不能继承。Java只支持单继承，即一个子类只允许有一个父类，但可以实现多级继承。通过继承，提高了代码的复用性。</p>
<p>继承的实现方法有实现继承和接口继承，实现继承指直接使用基类的方法和属性，接口继承时子类需要实现父类的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;继承链中的优先级调用</span><br><span class="line">this.show(O);super.show(O);this.show((super)O);super.show((super)O)</span><br><span class="line">&#x2F;&#x2F;如果(super)O重写了this的方法，则会覆盖。</span><br></pre></td></tr></table></figure>

<p><strong>多态：</strong>一个类实例的相同方法，在不同情形下有不同的表现形式，只有在运行时才知道引用变量指向的具体对象。多态消除了类型之间的耦合关系，实现低耦合。</p>
<p>在Java中可以<strong>通过继承和接口两种方式实现多态</strong>。多态的<strong>实现需要进行继承、重写、向上转型</strong>，在多态中必须存在继承关系的子类和父类，子类需要对父类中的某些方法进行重写，向上转型即在多态中父类的引用指向子类，如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; a =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>注意：向上转型之后，子类的特有方法就不能再被调用了。</p>
<h3 id="Java中子类的初始化顺序"><a href="#Java中子类的初始化顺序" class="headerlink" title="Java中子类的初始化顺序"></a>Java中子类的初始化顺序</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">父类的静态变量和代码块</span><br><span class="line">子类的静态变量和代码块</span><br><span class="line">父类的实例变量，普通语句块</span><br><span class="line">父类的构造函数</span><br><span class="line">子类的实例变量，普通语句块</span><br><span class="line">子类的构造函数</span><br></pre></td></tr></table></figure>

<h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><ol>
<li><p>一个类可以实现多个接口，但是只能继承一个类</p>
</li>
<li><p>接口的成员只能是public(JDK8中允许default修饰定义默认方法)，抽象类无所谓。</p>
</li>
<li><p>接口中的字段只能是static final类型，抽象类无所谓</p>
</li>
<li><p>接口用于让不相关的类实现同一方法和需要多重继承的时候，</p>
<p>例如：Plane和Bird类都有fly(),应该把fly定义为接口，因为除了fly外，bird和plane基本没有其他相同特征。</p>
</li>
</ol>
<h3 id="重写和重载"><a href="#重写和重载" class="headerlink" title="重写和重载"></a>重写和重载</h3><p><strong>重写(override): **是子类对父类</strong>允许访问的方法**的实现过程进行重新编写，其返回值和形参都不能改变</p>
<p>重写规则：1. 被final修饰的方法不能被重写； 2. 构造方法不能被重写；3. 访问权限不能比父类中被重写的方法访问权限更低;<code>public&gt;protected&gt;(default)&gt;private</code></p>
<p><strong>重载(overload):</strong>在一个类中，方法名相同，而参数不同称为方法的重载。</p>
<p>重载的规则：1. 被重载的方法可以改变返回类型；2. 被重载的方法可以改变访问修饰符；<strong>3.被重载的方法必须改变参数列表。</strong></p>
<p>JVM在重载方法中选择合适方法的顺序为：1. 精确匹配；2. 基本数据类型转为更大的表示范围；3. 自动拆箱装箱；4. 子类向上转型；5. 可变参数</p>
<h3 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h3><p>在Java中，每个数据类型都有一个对应的包装类(char的包装类为Character)</p>
<p>自动装箱，指将基本数据类型包装为一个包装类类型，如向泛型为<code>Inetger</code>的类型添加int元素</p>
<p>自动拆箱，即将一个包装类的对象转换为一个基本数据类型</p>
<p>注意：比较两个包装类数值时需要使用<code>equal</code>s而不是<code>==</code>；</p>
<h3 id="Java如何实现平台无关性"><a href="#Java如何实现平台无关性" class="headerlink" title="Java如何实现平台无关性"></a>Java如何实现平台无关性</h3><p>java可以一次编写，到处运行，Java编译器可生成与计算机体系结构无关的字节码指令，字节码文件不仅可以轻易的在任何机器上执行，还可以动态的转换为本地机器代码，转换由JVM实现，屏蔽了不同操作系统之间的差异。</p>
<h3 id="Java中Class类的作用"><a href="#Java中Class类的作用" class="headerlink" title="Java中Class类的作用"></a>Java中Class类的作用</h3><p>在java运行时，系统会为所有对象维护一个运行时类型标识，这个信息会跟踪每个对象所属的类，虚拟机利用运行时类信息选择要执行的正确方法，保存这些信息的类就是Class，这是一个泛型类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名<span class="class">.<span class="keyword">class</span>；对象的<span class="title">getclass</span>方法；<span class="title">Class</span>.<span class="title">forName</span>(类的全限定名)</span></span><br></pre></td></tr></table></figure>

<h3 id="fail-fast和fail-safe"><a href="#fail-fast和fail-safe" class="headerlink" title="fail-fast和fail-safe"></a>fail-fast和fail-safe</h3><p><strong>fail-fast(快速失败机制)：</strong>是java集合的一种错误检测机制，当<strong>多个线程对部分集合进行结构上的改变操作</strong>时可能会发生fail-fast，抛出ConcurrentModificationException异常。如当在迭代集合的过程中，集合在结构上发生了改变。</p>
<p>:warning:fail-fast不能保证不同步的情况下一定会抛出异常，只能尽力去抛出异常</p>
<p><strong>fail-safe(安全失败)：</strong>采用fail-safe的集合容器，在遍历是不是直接在集合内容上访问，而是先复制原有集合的内容，然后在拷贝的集合上进行遍历操作，由于是对拷贝的集合遍历，<strong>对原集合的修改并不会被迭代器检测到</strong>抛出异常。缺点是迭代器也不能访问到修改后的内容。(java.util.concurrent)</p>
<h3 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h3><p>Object类中的<strong>Clone()</strong>方法用于拷贝对象，默认Clone()方法是浅拷贝。</p>
<p><strong>浅拷贝：</strong>只复制当前对象的基本数据类型和引用变量，没有复制引用对象指向的实际对象，对克隆对象的修改可能影响原对象，不安全。</p>
<blockquote>
<p>对于引用类型，比如数组或者类对象，因为引用类型是引用传递，所以浅拷贝只是把内存地址赋值给了成员变量，它们指向了同一内存空间。改变其中一个，会对另外一个也产生影响。</p>
</blockquote>
<p><strong>深拷贝：</strong>完全拷贝基本数据类型和引用类型，安全，但是较浅拷贝速度慢且开销大</p>
<blockquote>
<p>深拷贝，在拷贝引用类型成员变量时，为引用类型的数据成员另辟了一个独立的内存空间，实现真正内容上的拷贝。</p>
</blockquote>
<p>对于有多层对象的，每个对象都需要实现Cloneable,并重写clone()方法，进而实现对象的串行层层拷贝。</p>
<p><strong>实现对象拷贝的类，需要实现Cloneable接口，并覆写clone()方法</strong>。</p>
<h3 id="数组和链表"><a href="#数组和链表" class="headerlink" title="数组和链表"></a>数组和链表</h3><p>数组可以随机访问其中元素，查询快，增删慢(需要移动后面所有元素)；链表删除快，查询需要遍历整个链表。</p>
<p>数组需要连续的内存空间，而链表的空间可以不连续。</p>
<p>数组的扩容需要分配一块更大的空间再迁移数据，而链表可以动态扩容。</p>
<h3 id="ArrayList和LinkedList"><a href="#ArrayList和LinkedList" class="headerlink" title="ArrayList和LinkedList"></a>ArrayList和LinkedList</h3><p>ArrayList基于数组实现，LinkedList基于双向链表设计，两者都可以非空，重复，有序，且线程不安全。</p>
<p>LinkedList因为基于双向链表，所以获取元素较ArrayList要慢 (遍历整个链表O(N))</p>
<p>LinkedList做插入删除操作的时候慢在寻址，快在操作只需要更改前后Node的引用地址</p>
<p>ArrayList快在寻址，慢在数组元素的批量copy</p>
<blockquote>
<p>当要插入和删除的元素在前半段或者非常靠前的位置的时候，LinkedList的效率大大快过ArrayList，但是越往后ArrayList要Copy的元素越来越少，操作速度必然追上或者超过LinkedList</p>
</blockquote>
<blockquote>
<p>LinkedList在查找元素的时候，若index小于size的一半从头开始遍历链表，当index在链表的后半部时，从尾部遍历链表</p>
</blockquote>
<p>ArrayList中的所有方法都是不同步的，所以在并发下 <strong>必然出现线程安全问题</strong>，vector是ArrayList的线程安全版本，其默认2倍扩容。</p>
<p>ArrayList调用grow方法判断是否需要多次扩容，每次默认扩容为原容器容量右移一位，即相当于原容器的1.5倍。</p>
<h3 id="List和Set"><a href="#List和Set" class="headerlink" title="List和Set"></a>List和Set</h3><p><img src="https://img.php.cn/upload/article/000/000/028/5c73a16ef1c04585.jpg" alt="img"></p>
<p>List和Set都是继承的Collection接口</p>
<p><strong>List：</strong>有序，可重复；<strong>Set：</strong>无序，不可重复，重复元素会被覆盖掉</p>
<p>List可以通过迭代器和下标遍历，Set只能通过迭代器遍历</p>
<p>HashSet通过 HashMap实现，HashMap的Key即HashSet的值，可以存在null值，线程不安全</p>
<p>TreeSet通过TreeMap实现</p>
<p>ArrayList和LinkedList见上述。</p>
<h4 id="HashSet如何实现添加元素时保证元素不重复"><a href="#HashSet如何实现添加元素时保证元素不重复" class="headerlink" title="HashSet如何实现添加元素时保证元素不重复"></a>HashSet如何实现添加元素时保证元素不重复</h4><p>如果不存在元素和传入对象的Hash值相等，表示该对象不存在，存。</p>
<p>如果存在元素和传入对象的Hash值相等，若equals判读相等，不存，若equals判断不等，存</p>
<h4 id="关于HashMap"><a href="#关于HashMap" class="headerlink" title="关于HashMap"></a>关于HashMap</h4><p>HashMap在底层数据结构上采用了数组+链表+红黑树的结构，通过散列映射来存储键值对数据，因为在查询上使用散列码，所以查询上速度比较快。HashMap最多允许一对键值对的key为null，多个键值对的value为null。无序，且非线程安全。(ConcurrentHashMap线程安全)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; 默认的table 初始容量（<span class="number">16</span>）</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>：默认的负载因子</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>: 链表长度大于该参数转红黑树</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>: 当树的节点数小于等于该参数转成链表</span><br></pre></td></tr></table></figure>

<p><strong>HashMap的动态扩容：</strong>假设hashmap的table长度是m，键值对为n，table中每个链表长度为n/m,为了使查找成本尽可能小需要m尽可能大，可以使用resize实现，hashMap默认负载因子0.75f，即当容量达到3/4时进行扩容，负载因子越大，能容纳的键值对越多，但是查找的代价也会相应增大。</p>
<p><strong>hash():</strong>如果key为null，返回0，否则将hashcode方法的返回值高低16位异或（ h ^ (h &gt;&gt;&gt; 16) ）,<strong>让尽可能多的位参与运算，使结果的0,1分布更加均匀,降低Hash冲突概率</strong> （右位移16位正好是32bit的一半，高半区和低半区异或加大低位的随机性，而且混合后的低位参杂了高位的部分特征，变相保留了高位的信息）</p>
<p><strong>Hash冲突：</strong>hash冲突指hash方法出来key的hash值是相同的</p>
<h5 id="Hash冲突的解决办法："><a href="#Hash冲突的解决办法：" class="headerlink" title="Hash冲突的解决办法："></a>Hash冲突的解决办法：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开放地址</span><br><span class="line">建立公共溢出区</span><br><span class="line">再哈希：发生Hash冲突的时候再进行一次Hash，缺点是每次冲突都要再Hash，时间成本增加</span><br><span class="line">拉链法：将Hash冲突的同义词存储在同一个线性链表中 缺点是需要额外的空间</span><br></pre></td></tr></table></figure>

<h5 id="为什么HsahMap的数组长度要取2的整数幂"><a href="#为什么HsahMap的数组长度要取2的整数幂" class="headerlink" title="为什么HsahMap的数组长度要取2的整数幂"></a>为什么HsahMap的数组长度要取2的整数幂</h5><ol>
<li>扩容，大小指定为2的幂次，当哈希桶扩大为2倍时只需要进行左移操作，位操作的速度比较快</li>
<li>减少Hash冲突：2的幂次Length-1值后面的二进制位全为1，这种情况下，index=key值的Hashcode&amp;(Length-1),index结果等同与hashcode后几位的值，只要Hashcode本身分布均匀，Hash算法的结果就是均匀的。</li>
</ol>
<h3 id="二叉查找树，AVL树，B树，红黑树"><a href="#二叉查找树，AVL树，B树，红黑树" class="headerlink" title="二叉查找树，AVL树，B树，红黑树"></a>二叉查找树，AVL树，B树，红黑树</h3><p><strong>二叉查找树(BST)：</strong>左节点小于根节点，右节点大于根节点(O(logN)),在极端情况下会变成线性链表结构O(N)，为解决这个出现了AVL树</p>
<p><strong>平衡二叉树(AVL)：</strong>是一种自平衡的树，除了二叉树的特征外，规定左子树和右子树高度差不超过1（保证不会成为线性链表），但是由于要维持自身平衡，所以插入删除节点的时候需要对节点进行频繁旋转。</p>
<p><strong>B树(也叫B-树)：</strong>是一种多路平衡查找树</p>
<ol>
<li>其所有的叶子节点处于同一层，每个节点中的元素从小到大排序，可以看成矮胖版的AVL树</li>
</ol>
<p><strong>B+树：</strong>B+树每个非叶子结点存放的元素只用于索引作用，所有数据保存在叶子结点。</p>
<p><strong>红黑树：</strong>一种自平衡的二叉查找树</p>
<img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210907203427.jpg" style="zoom:80%;" />

<ol>
<li>每个节点或是黑色或是红色</li>
<li>根节点是黑色</li>
<li>每个叶子节点为黑色(叶子节点指为空的叶子节点)</li>
<li>如果一个节点为红色，则子节点必须是黑色</li>
<li>从一个节点到该节点的子孙节点所有路径上包含相同数目的黑节点</li>
</ol>
<blockquote>
<p>红黑树相较于AVL树牺牲了严格的高度平衡的条件，只要求部分达到平衡要求，由于红黑树的设计，任何不平衡都会在3次旋转内解决，相较于BST，红黑树可以确保树的最长路径不大于两倍最短路径的长度，即查找效果是有最低保证的，即O(logN)</p>
</blockquote>
<p><strong>红黑树旋转(左旋右旋)：</strong></p>
<p>对x进行左旋，意味着，将“x的右孩子”设为“x的父亲节点”；即，将 x变成了一个左节点(x成了为z的左孩子)！。 因此，<strong>左旋中的“左”，意味着“被旋转的节点将变成一个左节点”</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210907203502.jpg" alt=""></p>
<p><strong>红黑树插入：</strong></p>
<p>将红黑树当作一颗二叉查找树，插入节点</p>
<p>将节点着色为红色（将插入的节点着色为红色，不会违背”特性(5)”！少违背一条特性，就意味着我们需要处理的情况越少。）</p>
<p>通过旋转着色生成新的红黑树</p>
<h3 id="String、StringBuilder、StringBuffer"><a href="#String、StringBuilder、StringBuffer" class="headerlink" title="String、StringBuilder、StringBuffer"></a>String、StringBuilder、StringBuffer</h3><ol>
<li><strong>可变性：</strong>只有String不可变</li>
</ol>
<blockquote>
<p>因为String被声明为final，所以不可以被继承，<strong>对于String对象的任何修改，其实都是在创建一个新的String对象再引用该对象，只是修改了变量引用的对象，没有修改原本String对象本身</strong>。</p>
<p>因为String的不可变：可以用做HashMap的Key，并且线程安全</p>
</blockquote>
<ol start="2">
<li><strong>安全性：</strong>只有StringBuilder线程不安全</li>
</ol>
<blockquote>
<p>因为StringBuilder在append操作时并未使用线程同步，而StringBuffer几乎大部分方法都使用了synchronized关键字进行方法级别的同步处理。</p>
</blockquote>
<p><strong>字符串的拼接</strong></p>
<ol>
<li><p>直接使用+的话，底层使用StringBuilder实现，在循环中若使用+拼接，相当于不断创建新的StringBuilder对象再转换为String对象，效率差。</p>
</li>
<li><p>使用String的concat方法，效率稍高与直接使用+</p>
</li>
<li><p>使用StringBuilder和StringBuffer的append方法，StringBuilder效率高，但是线程不安全；StrinBuffer使用synchronized保证线程安全，但是效率低一些</p>
</li>
</ol>
<blockquote>
<p>常量和常量拼接，结果仍然是常量，结果在常量池；只要有变量参与结果就是变量，存在堆中。</p>
</blockquote>
<h3 id="finally，finalize，final"><a href="#finally，finalize，final" class="headerlink" title="finally，finalize，final"></a>finally，finalize，final</h3><p><strong>finalize()：</strong> 在垃圾回收器(GC)准备释放对象占用的内存时，首先调用finalize(),并且在下一次垃圾回收动作发生，才会真正回收该对象占用的内存，一个对象的finalize()方法只会调用一次，而且finalize()被调用不意味着gc会回收该对象。</p>
<p><strong>finally：</strong>作为异常处理的一部分，只能用在try-catch语句中，finally的语句不论是否抛出异常都一定会被执行</p>
<blockquote>
<p>try语句执行之前的抛出异常或返回时finally不会被执行</p>
<p>try语句中System.exit（0）终止虚拟局运行时不会执行finally</p>
<p>try或者catch语句执行时被打断(如断电死机)，finally语句不会被执行</p>
<p>try-catch中有return时会先执行finally，若finally也有return则返回finally的return</p>
</blockquote>
<h3 id="final，Static，Static-final"><a href="#final，Static，Static-final" class="headerlink" title="final，Static，Static final"></a>final，Static，Static final</h3><p><strong>final：</strong></p>
<ol>
<li>final类不能被继承，类中的所有方法默认是final的</li>
<li>final方法可以被继承，但不能被子类覆盖</li>
<li>final成员变量只能赋值一次，赋值之后不能再改变</li>
<li>final不能修饰构造方法</li>
<li>private类型的方法默认是final类型的</li>
<li>final可以先声明，不给初始值，但是final在使用之前必须被初始化。</li>
</ol>
<p><strong>static final/final static：</strong></p>
<p>用来修饰成员变量和成员方法，可以理解为全局变量(final static和static final没有任何区别)</p>
<ol>
<li><p>对于变量，表示一旦赋值就不可修改，可以通过类名访问</p>
</li>
<li><p>对于方法，表示不可覆盖，可以通过类名直接访问</p>
</li>
</ol>
<p><strong>Static: ** 被Static修饰的成员变量和成员方法 **独立于该类的任何对象</strong>，即不依赖类的特定实例，只要这个类被加载，虚拟机就能根据类名在 <strong>运行时数据区的方法区找到</strong>，因此Static对象可以在它的任何对象创建之前访问。<strong>Public</strong>修饰的<strong>Static</strong>成员变量和成员方法本质是全局变量和全局方法。</p>
<h4 id="Static可以被继承嘛"><a href="#Static可以被继承嘛" class="headerlink" title="Static可以被继承嘛"></a>Static可以被继承嘛</h4><p>static修饰可以被继承，<strong>但不能被重写</strong>，静态方法在编译时绑定，方法重写是运行时绑定</p>
<h4 id="是否可以从一个static方法内部访问该类的非static方法"><a href="#是否可以从一个static方法内部访问该类的非static方法" class="headerlink" title="是否可以从一个static方法内部访问该类的非static方法"></a>是否可以从一个static方法内部访问该类的非static方法</h4><p><strong>不可以，</strong>因为非Static方法需要和对象关联在一起，必须创建一个对象才可以在该对象上进行方法的调用，在static方法被调用时，可能还没有创建任何实例对象。</p>
<h4 id="静态变量和实例变量的区别"><a href="#静态变量和实例变量的区别" class="headerlink" title="静态变量和实例变量的区别"></a>静态变量和实例变量的区别</h4><p>静态变量需要static修饰</p>
<p>实例对象属于 <strong>某个对象的属性</strong>，必须创建实例对象才会被分配空间使用这个实例变量。</p>
<p>静态变量属于类，又叫类变量，<strong>程序加载类的字节码文件时静态变量就会被分配空间被使用</strong></p>
<h3 id="Java的运行时数据区"><a href="#Java的运行时数据区" class="headerlink" title="Java的运行时数据区"></a>Java的运行时数据区</h3><ol>
<li>程序计数器：一块较小的内存空间，可以看作当前线程所执行字节码的行号指示器，是唯一虚拟机没有规定内存溢出情况的区域。</li>
<li>JVM栈：为虚拟机执行Java服务，每当有一个新线程创建时就会分配一个栈空间，线程结束后栈空间被回收，栈空间与线程拥有相同的生命周期。当线程请求的栈深度大于虚拟机允许的深度时抛出StackOverflowError，如果jvm栈容量可以动态扩展，栈扩展无法申请到足够内存时抛出：OutOfMemoryError</li>
<li>本地方法栈：与Jvm栈类似，调用本地方法时JVM栈保持不变，动态链接并直接调用本地方法。</li>
<li>堆：JVM管理内存中最大的一块，<strong>被所有线程共享，在虚拟机启动时创建。</strong>Java中几乎所有的实例都在堆分配内存。堆在物理上可以处于不连续的空间，逻辑上应该连续。</li>
<li>方法区：用于存储被虚拟机加载的常量、静态变量、类型信息、即时编译器编译后的代码缓存等数据，可以固定大小，也可以扩展，<strong>还可以不实现垃圾回收。</strong></li>
</ol>
<h4 id="运行时常量池的作用"><a href="#运行时常量池的作用" class="headerlink" title="运行时常量池的作用"></a>运行时常量池的作用</h4><p>运行时常量池 <strong>是运行时数据区中方法区的一部分</strong>，受方法区内存限制，无法再申请内存时抛出OutOfMemoryError</p>
<p>Class文件中出了有类的版本、字段、方法、接口等描述信息外<strong>，还有一项是常量池表</strong>，<strong>用于存放编译器生成的各种字面量与符号引用</strong>，这部分内容在 **类加载之存放到运行时常量池</p>
<h4 id="常量池的好处"><a href="#常量池的好处" class="headerlink" title="常量池的好处"></a>常量池的好处</h4><p>常量池是为了避免频繁创建和销毁对象而影响系统系能，实现了对象的共享</p>
<ol>
<li>节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。</li>
<li>节省运行时间：比较字符串时 ==比equals要快。</li>
</ol>
<h3 id="什么是直接内存"><a href="#什么是直接内存" class="headerlink" title="什么是直接内存"></a>什么是直接内存</h3><p>直接内存，又称为堆外内存，NIO的Buffer提供了一个可以不经过JVM内存直接访问系统物理内存的类：<strong>DirectBuffer</strong>，DirectBuffer与普通的ByteBuffer不同，其直接分配在物理内存中，并不占用堆空间，其可以申请的最大内存受操作系统的限制，<strong>直接内存读写比普通Buffer快，但是创建销毁要比普通Buffer慢。</strong></p>
<p><strong>使用堆外内存的原因：</strong></p>
<ol>
<li>对垃圾回收停顿改善：使用堆外内存时可以保持较小的堆内内存规模，从而在GC时减少回收停顿对系统的影响</li>
<li>提升程序I/O操作的性能：通常再I/O通信中，通常会存在堆内内存和堆外内存的拷贝操作。</li>
</ol>
<h3 id="内存溢出-OOM"><a href="#内存溢出-OOM" class="headerlink" title="内存溢出(OOM)"></a>内存溢出(OOM)</h3><p><strong>内存溢出和内存泄露的区别：</strong></p>
<p>内存溢出OutOfMemory，指程序在申请内存时，没有足够的内存空间供其使用。</p>
<p>内存泄露，是指无用对象(不再使用的对象)持续占有内存或者内存得不到释放，从而导致内存空间的浪费称为内存泄露，内存泄漏最终会导致内存溢出。</p>
<blockquote>
<p><strong>原因场景：</strong>长生命周期的对象持有短生命周期对象的引用时就很可能发生内存泄露，尽管短生命周期的对象已经不在需要，但是因为长生命周期对象持有它的引用而导致不能回收，这就是Java中内存泄露的场景。</p>
</blockquote>
<p><strong>堆OOM：</strong>堆用于存储对象实例，当不断创建对象，并保证GC Roots到对象有可达路径 避免垃圾回收，随着对象数量的增加，总容量触及最大堆容量之后就会OOM，如一直在while循环中创建实例。</p>
<blockquote>
<p><strong>堆OOM的处理：</strong>通过内存映象分析工具对Dump出的堆转存储快照分析，确认是内存泄漏还是内存溢出</p>
<p>若是内存泄漏，通过工具查看泄漏对象到GC Roots的引用链，准确定位产生内存泄漏代码的具体位置</p>
<p>若不是内存泄漏，即内存中的所有对象都必须存活时，应当检查JVM堆参数，判断是否还有向上调整的空间，再检查是否存在某些对象生命周期过长，持有状态时间过长灯情况，尽量降低程序运行时的内存消耗。</p>
</blockquote>
<p><strong>栈OOM：</strong> 若线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverFlowerError，如果JVM栈可以动态扩展，当扩展无法申请到足够的内存时，会出现OOM</p>
<p><strong>方法区OOM</strong>：方法区主要存放类型信息，如类名，访问修饰符，常量值，方法描述等，只要在运行是不断产生大量的类，方法区就会溢出。<strong>如使用JDK反射或这CGLib直接操作字节码在运行时生成大量的类</strong>。</p>
<h3 id="Spring-中Ioc的工厂模式"><a href="#Spring-中Ioc的工厂模式" class="headerlink" title="Spring 中Ioc的工厂模式"></a>Spring 中Ioc的工厂模式</h3><p>IOC指在程序开发过程中，对象实例的创建不再由调用者管理，而是由Spring容器创建，Spring容器会负责控制程序之间的关系，因此，控制权由程序代码转移到了Spring容器，控制权发生了反转，即控制反转。</p>
<blockquote>
<p>在没有使用Spring的时候，对象需要通过<code>new object()</code>来创建，这个对象是主动创建的，创建对象的主动权由自己把控，这样就会使得对象之间的耦合度高，A对象需要使用合作对象B来共同完成一件事，A要使用B，那么A就对B产生了依赖，也就是A和B之间存在一种耦合关系，并且是紧密耦合在一起，而使用了Spring之后就不一样了，创建合作对象B的工作是由Spring来做的，Spring创建好B对象，然后存储到一个容器里面，当A对象需要使用B对象时，Spring就从存放对象的那个容器里面取出A要使用的那个B对象，然后交给A对象使用，至于Spring是如何创建那个对象，以及什么时候创建好对象的，A对象不需要关心这些细节问题。</p>
</blockquote>
<p>IOC最基本的技术就是反射，通过给出的类名来动态的生成对象，可以让对象在生成时才被决定是哪一种对象，降低耦合。</p>
<p>IOC是工厂模式+反射机制，IOC中的工厂模式内部使用反射来创建对象，对象的实例化都交给工厂完成，通过工厂来获取对象。</p>
<h3 id="Spring中Bean的生命周期"><a href="#Spring中Bean的生命周期" class="headerlink" title="Spring中Bean的生命周期"></a>Spring中Bean的生命周期</h3><ol>
<li>实例化一个Bean</li>
<li>按照Spring上下文对实例化的Bean进行配置 （IOC注入）</li>
<li>如果Bean实现了BeanNameAware接口，则调用setBeanName(String)方法，传递的是配置文件中Bean的id</li>
<li>如果实现了BeanFactoryAware接口，则调用setBeanFactory(BeanFactory)</li>
<li>如果这个Bean关联了BeanPostProcessor接口，将会调用<code>postProcessBeforeInitialization(Object obj, String s)</code>方法，BeanPostProcessor经常被用作是Bean内容的更改，并且由于这个是在Bean初始化结束时调用那个的方法，也可以被应用于内存或缓存技术；</li>
<li>如果Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。</li>
<li>如果这个Bean关联了BeanPostProcessor接口，将会调用<code>postProcessAfterInitialization(Object obj, String s)</code>方法；</li>
<li>当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用那个其实现的destroy()方法；</li>
<li>最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。</li>
</ol>
<h3 id="SpringBoot的自动装配"><a href="#SpringBoot的自动装配" class="headerlink" title="SpringBoot的自动装配"></a>SpringBoot的自动装配</h3><p>在SpringBoot启动时加载入口类，通过$@EnableAutoConfiguration$开启自动装配功能，自动装配时会扫描所有jar包类路径下$META-INF/spring.factories$ 中的所有自动配置类，如果符合相应的条件，则使用相应的自动配置类实现自动装配。</p>
<p>自动配置类实现自动装配时，配置类会给容器中添加各种组件，这些组件的属性从对应的$properties$类中获取，而对应的$properties$中的属性和配置文件进行相互绑定。</p>
<blockquote>
<p>SpringBoot中的自动装配技术用到了：</p>
<ol>
<li>Spring 模式注解装配</li>
<li>Spring @Enable 模块装配</li>
<li>Spring 条件装配</li>
<li>Spring 工厂加载机制</li>
</ol>
</blockquote>
<h3 id="Spring中的注解"><a href="#Spring中的注解" class="headerlink" title="Spring中的注解"></a>Spring中的注解</h3><h3 id="SpringMVC流程"><a href="#SpringMVC流程" class="headerlink" title="SpringMVC流程"></a>SpringMVC流程</h3><p>MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p>
<p><img src="https://camo.githubusercontent.com/0fd35900c32b252a18ff38855ae52192f90f8884f1622bb5f92578fe68c6cb2f/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f64653664326232313366313132323937323938663365323233626630386632382e706e67" alt="img"></p>
<ol>
<li>客户端（浏览器）发送请求，直接请求到 <code>DispatcherServlet</code>。</li>
<li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。</li>
<li>解析到对应的 <code>Handler</code>（也就是我们说的 <code>Controller</code> 控制器）后，开始由 <code>HandlerAdapter</code> 适配器处理。</li>
<li><code>HandlerAdapter</code> 会根据 <code>Handler</code>来调用真正的处理器开处理请求，并处理相应的业务逻辑。</li>
<li>处理器处理完业务后，会返回一个 <code>ModelAndView</code> 对象，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li>
<li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li>
<li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li>
<li>把 <code>View</code> 返回给请求者（浏览器）</li>
</ol>
<h3 id="Java中的异常体系"><a href="#Java中的异常体系" class="headerlink" title="Java中的异常体系"></a>Java中的异常体系</h3><p>Java标准裤内建了一些通用的异常，这些类以Throwable为顶层父类，Throwable又派生出Error类和Exception类。</p>
<p><strong>Error</strong>：Error类以及他的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理。</p>
<p><strong>Exception</strong>：Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210908191952.png" alt=""></p>
<p><strong>根据Javac对异常的处理要求，将异常类分为2类</strong></p>
<p><strong>非检查异常</strong>（unckecked exception）：Error 和 RuntimeException 以及他们的子类。javac在编译时，不会提示和发现这样的异常，不要求在程序处理这些异常。所以如果愿意，我们可以编写代码处理（使用try…catch…finally）这样的异常，也可以不处理。对于这些异常，我们应该修正代码，而不是去通过异常处理器处理 。这样的异常发生的原因多半是代码写的有问题。如除0错误ArithmeticException，错误的强制类型转换错误ClassCastException，数组索引越界ArrayIndexOutOfBoundsException，使用了空对象NullPointerException等等。 </p>
<p><strong>检查异常</strong>（checked exception）：除了Error 和 RuntimeException的其它异常。javac强制要求程序员为这样的异常做预备处理工作（使用try…catch…finally或者throws）。在方法中要么用try-catch语句捕获它并处理，要么用throws子句声明抛出它，否则编译不会通过。这样的异常一般是由程序的运行环境导致的。因为程序可能被运行在各种未知的环境下，而程序员无法干预用户如何使用他编写的程序，于是程序员就应该为这样的异常时刻准备着。如SQLException , IOException,ClassNotFoundException 等。</p>
<p>需要明确的是：检查和非检查是对于javac来说的，这样就很好理解和区分了</p>
<p><strong>多个异常的捕获顺序</strong></p>
<p>对于try..catch捕获异常的形式来说，对于异常的捕获，可以有多个catch。对于try里面发生的异常，他会根据发生的异常和catch里面的进行从上往下匹配，当它匹配某一个catch块的时候，他就直接进入到这个catch块里面去了，后面在再有catch块的话，它不做任何处理，直接跳过去，全部忽略掉。如果有finally的话进入到finally里面继续执行。换句话说，如果有匹配的catch，它就会忽略掉这个catch后面所有的catch。</p>
<p><strong>在写异常处理的时候，一定要把异常范围小的放在前面，范围大的放在后面</strong>，Exception这个异常的根类一定要放在最后一个catch里面，如果放在前面或者中间，任何异常都会和Exception匹配的，就会报已捕获到…异常的错误。 </p>
<p><strong>throws和throw</strong></p>
<p><strong>Throw</strong>：<strong>作用在方法内</strong>，表示抛出具体异常，由方法体内的语句处理。具体向外抛出的动作，所以它抛出的是一个异常实体类。若执行了throw一定是抛出了某种异常。</p>
<p><strong>throws</strong>：作用在<strong>方法的声明上</strong>，表示如果抛出异常，则由该方法的调用者来进行异常处理。（自身不处理异常）</p>
<p>主要的声明这个方法会抛出会抛出某种类型的异常，让它的使用者知道捕获异常的类型。出现异常是一种可能性，但不一定会发生异常。</p>
<h3 id="BIO，NIO，AIO"><a href="#BIO，NIO，AIO" class="headerlink" title="BIO，NIO，AIO"></a>BIO，NIO，AIO</h3><p><strong>同步与异步</strong></p>
<ul>
<li><strong>同步：</strong> 同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回。</li>
<li><strong>异步：</strong> 异步就是发起一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他的请求，被调用者通常依靠事件，回调等机制来通知调用者其返回结果。</li>
</ul>
<p>同步和异步的区别最大在于异步的话调用者不需要等待处理结果，被调用者会通过回调等机制来通知调用者其返回结果。</p>
<p><strong>阻塞和非阻塞</strong></p>
<ul>
<li><strong>阻塞：</strong> 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。</li>
<li><strong>非阻塞：</strong> 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。</li>
</ul>
<p><strong>BIO:</strong><code>同步阻塞</code>，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不作任何事情会造成不必要的线程开销。</p>
<p><strong>NIO</strong>：<code>同步非阻塞</code>，服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求会被注册到多路复用器（selector）上，多路复用器轮询到有 I/O 请求就会进行处理,通过轮询代替了始终保持一个连接。</p>
<blockquote>
<p>客户端发送一个请求，并建立一个连接，服务端接收到了。如果服务端没有数据，就告知客户端“没有数据”；如果有数据，则返回数据。客户端接到了服务端回复的“没有数据”就断开连接，过了一段时间后，客户端重新问服务端是否有数据。服务器重复以上步骤。</p>
</blockquote>
<blockquote>
<p>Selector： 多路复用器，轮询检查多个Channel 的状态，判断注册事件是否发生，即判断Channel 是否处于可读或可写状态。使用前需要将Channel 注册到Selector，注册后会得到一个SelectionKey，通过SelectionKey 获取Channel 和Selector 相关信息。<br>Channel： 双向通道，替换了BIO 中的Stream 流，不能直接访问数据，要通过Buffer 来读写数据，也可以和其他Channel 交互。<br>Buffer： 缓冲区，本质是一块可读写数据的内存，用来简化数据读写</p>
</blockquote>
<p><strong>AIO：</strong><code>异步非阻塞</code>，AIO 引入了异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。</p>
<blockquote>
<p>客户端向服务端请求数据。服务端若有，则返回数据；若无，则告诉客户端“没有数据”。客户端收到“没有数据”的回复后，就做自己的其他事情。服务端有了数据之后，就主动通知客户端，并把数据返回去</p>
</blockquote>
<blockquote>
<p>BIO 方式适用于<code>连接数比较小且固定</code>的架构</p>
<p>NIO 方式适用于<code>连接数目多且连接比较短</code>的架构，比如聊天服务器，弹幕系统</p>
<p>AIO 方式适用于<code>连接数目多且连接比较长</code>的架构，比如相册服务器</p>
</blockquote>
<h4 id="NIO-和-BIO-对比"><a href="#NIO-和-BIO-对比" class="headerlink" title="NIO 和 BIO 对比"></a>NIO 和 BIO 对比</h4><ol>
<li><p>BIO 以流的方式处理数据，而 NIO 以块的方式处理数据，块 I/O 的效率比流 I/O 高很多。ew 一个 Thread，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p><strong>总结： 调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p>
</li>
<li><p>BIO 是阻塞的，而 NIO 是非阻塞的。</p>
</li>
<li><p>BIO 基于字节流和字符流进行操作，而 NIO 基于 Channel（通道）和 Buffer（缓冲区）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector（选择器）用于监听多个通道事件（比如连接请求，数据到达等），因此<code>使用单个线程就可以监听多个客户端通道</code>。</p>
</li>
</ol>
<h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><p><strong>进程</strong>：在操作系统中能够独立运行，并且作为资源分配的基本单位。它表示运行中的程序。系统运行一个程序就是一个进程从创建、运行到消亡的过程。</p>
<p><strong>线程</strong>：是一个比进程更小的执行单位，能够完成进程中的一个功能，也被称为轻量级进程。一个进程在其执行的过程中可以产生多个线程。</p>
<p>线程与进程不同的是：同类的多个线程<strong>共享进程的堆和方法区资源</strong>，但<strong>每个线程有自己的程序计数器、虚拟机栈和本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多。</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210911092310.png" alt=""></p>
<blockquote>
<p>为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的</p>
</blockquote>
<h3 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h3><p><strong>线程的状态：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909160042.png" alt=""></p>
<p><strong>线程的生命周期包含5个阶段，包括：新建、就绪、运行、阻塞、销毁。</strong></p>
<ul>
<li>新建：就是刚使用new方法，new出来的线程；</li>
<li>就绪：就是调用的线程的start()方法后，这时候线程处于等待CPU分配资源阶段，谁先抢的CPU资源，谁开始执行;</li>
<li>运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run方法定义了线程的操作和功能;</li>
<li>阻塞：在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态，比如sleep()、wait()之后线程就处于了阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用notify或者notifyAll()方法。唤醒的线程不会立刻执行run方法，它们要再次等待CPU分配资源进入运行状态;</li>
<li>销毁：如果线程正常执行完毕后或线程被提前强制性的终止或出现异常导致结束，那么线程就要被销毁，释放资源;</li>
</ul>
<h3 id="sleep-方法和wait-方法区别和共同点"><a href="#sleep-方法和wait-方法区别和共同点" class="headerlink" title="sleep()方法和wait()方法区别和共同点"></a>sleep()方法和wait()方法区别和共同点</h3><p><strong>共同点：</strong>两者都可以暂停线程的执行，都会让线程进入等待状态。</p>
<p><strong>不同点：</strong></p>
<ul>
<li>sleep()方法没有释放锁，而 wait()方法释放了锁。</li>
<li>sleep()方法属于Thread类的静态方法，作用于当前线程；而wait()方法是Object类的实例方法，作用于对象本身。</li>
<li>执行sleep()方法后，可以通过超时或者调用interrupt()方法唤醒休眠中的线程；执行wait()方法后，通过调用notify()或notifyAll()方法唤醒等待线程。</li>
</ul>
<h3 id="调用start-时会执行run-为什么不直接执行run"><a href="#调用start-时会执行run-为什么不直接执行run" class="headerlink" title="调用start()时会执行run(),为什么不直接执行run()"></a>调用start()时会执行run(),为什么不直接执行run()</h3><p>ew 一个 Thread，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p><strong>总结： 调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p>
<h3 id="多线程开发带来的问题-与解决方法："><a href="#多线程开发带来的问题-与解决方法：" class="headerlink" title="多线程开发带来的问题,与解决方法："></a>多线程开发带来的问题,与解决方法：</h3><h4 id="线程安全问题："><a href="#线程安全问题：" class="headerlink" title="线程安全问题："></a>线程安全问题：</h4><p>线程安全问题指的是在某一线程从开始访问到结束<strong>访问某一数据期间，该数据被其他的线程所修改</strong>，那么对于当前线程而言，该线程就发生了线程安全问题，表现形式为数据的缺失，数据不一致等。</p>
<p><strong>线程安全问题发生的条件</strong></p>
<p>1）多线程环境下，即存在包括自己在内存在有多个线程。</p>
<p>2）多线程环境下<strong>存在共享资源</strong>，且<strong>多线程操作该共享资源。</strong></p>
<p>3）多个线程必须对该共享资源有非原子性操作</p>
<p><strong>线程安全的解决思路：</strong></p>
<p>1）<strong>尽量不使用共享变量</strong>，将不必要的共享变量变成局部变量来使用。</p>
<p>2）<strong>使用synchronized关键字同步代码块</strong>，或者使用jdk包中提供的Lock为操作进行<strong>加锁</strong>。</p>
<p>3）<strong>使用ThreadLocal为每一个线程建立一个变量的副本，各个线程间独立操作，互不影响。</strong></p>
<h4 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h4><p>线程的生命周期开销是非常大的，<strong>一个线程的创建到销毁都会占用大量的内存</strong>。同时如果不合理的创建了多个线程，cup的处理器数量小于了线程数量，那么将会有很多的线程被闲置，闲置的线程将会占用大量的内存，为垃圾回收带来很大压力，同时cup在分配线程时还会消耗其性能。</p>
<p><strong>解决思路：</strong>利用线程池<strong>，模拟一个池，预先创建有限合理个数的线程放入池中，当需要执行任务时从池中取出空闲的先去执行任务，执行完成后将线程归还到池中，这样就</strong>减少了线程的频繁创建和销毁，节省内存开销**和减小了垃圾回收的压力。同时因为任务到来时本身线程已经存在，减少了创建线程时间，提高了执行效率，而且合理的创建线程池数量还会使各个线程都处于忙碌状态，提高任务执行效率，线程池还提供了拒绝策略，当任务数量到达某一临界区时，线程池将拒绝任务的进入，保持现有任务的顺利执行，减少池的压力。</p>
<h4 id="活跃性问题"><a href="#活跃性问题" class="headerlink" title="活跃性问题"></a>活跃性问题</h4><p>1）<strong>死锁</strong>，假如线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。多个线程环形占用资源也是一样的会产生死锁问题。</p>
<blockquote>
<p>死锁必须具备以下四个条件：</p>
<ol>
<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
</blockquote>
<p><strong>解决方法：</strong></p>
<ul>
<li>避免一个线程同时获取多个锁</li>
<li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</li>
<li>尝试使用定时锁，使用 lock.tryLock(timeout) 来代替使用内部锁机制。</li>
</ul>
<p>想要避免死锁，可以<strong>使用无锁函数</strong>（cas）<strong>或者使用重入锁（ReentrantLock），通过重入锁使线程中断或限时等待可以有效的规避死锁问题</strong>。</p>
<p>2) <strong>饥饿</strong>，饥饿<strong>指的是某一线程或多个线程因为某些原因一直获取不到资源，导致程序一直无法执行</strong>。如某一线程优先级太低导致一直分配不到资源，或者是某一线程一直占着某种资源不放，导致该线程无法执行等。</p>
<p><strong>解决方法：</strong>可以设置合适的线程优先级来尽量避免饥饿的产生。</p>
<p>3）<strong>活锁</strong>，每个线程都想把资源让给对方，可能会产生一直将资源让来让去，导致资源在两个线程间跳动而无法使某一线程真正的到资源并执行，这就是活锁的问题。</p>
<h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>阻塞是用来形容多线程的问题，<strong>几个线程之间共享临界区资源，那么当一个线程占用了临界区资源后，所有需要使用该资源的线程都需要进入该临界区等待，等待会导致线程挂起，一直不能工作，这种情况就是阻塞</strong>，<strong>如果某一线程一直都不释放资源，将会导致其他所有等待在这个临界区的线程都不能工作</strong>。</p>
<p><strong>解决方法：</strong>可以通过减少锁持有时间，读写锁分离，减小锁的粒度，锁分离，锁粗化等方式来优化锁的性能</p>
<h3 id="synchronized和Lock的区别："><a href="#synchronized和Lock的区别：" class="headerlink" title="synchronized和Lock的区别："></a>synchronized和Lock的区别：</h3><ol>
<li><strong>Lock是一个接口，而synchronized是Java中的关键字</strong>，synchronized是内置的语言实现；</li>
<li>synchronized在发生异常时，<strong>会自动释放线程占有的锁</strong>，因此不会导致死锁现象发生；而Lock在发生异常时，如果<strong>没有主动通过unLock()去释放锁，则很可能造成死锁现象</strong>，因此使用Lock时需要在finally块中释放锁；</li>
<li>Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</li>
<li>通过Lock可以知道有没有成功获取锁（tryLock()方法：如果获取锁成功，则返回true），而synchronized却无法办到。</li>
<li>Lock可以提高多个线程进行读操作的效率。在性能上来说，如果<strong>竞争资源不激烈，两者的性能是差不多的</strong>，而当<strong>竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized</strong>。</li>
</ol>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="使用线程池的好处："><a href="#使用线程池的好处：" class="headerlink" title="使用线程池的好处："></a>使用线程池的好处：</h4><ol>
<li>降低资源消耗。通过重复利用已创建的线程，降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控</li>
</ol>
<h4 id="说说几种常见线程池和适用场景"><a href="#说说几种常见线程池和适用场景" class="headerlink" title="说说几种常见线程池和适用场景"></a>说说几种常见线程池和适用场景</h4><ol>
<li><p><strong>FixedThreadPool</strong>：可重用固定线程数的线程池（<strong>适用于负载比较重的服务器</strong>）</p>
<p>FixedThreadPool使用无界队列LinkedBlockingQueue作为线程池的工作队列</p>
<p>该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</p>
</li>
<li><p><strong>SingleThreadExecutor：</strong>只会创建一个线程执行任务。（适用于需要保证顺序执行各个任务；并且在任意时间点，<strong>没有多线程活动的场景</strong>。）</p>
<p>SingleThreadExecutorl也使用无界队列LinkedBlockingQueue作为工作队列</p>
<p>若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</p>
</li>
<li><p><strong>CachedThreadPool：</strong> <strong>是一个会根据需要调整线程数量的线程池</strong>。（大小无界，适用于执行很多的短期异步任务的小程序，或负载较轻的服务器）</p>
<ul>
<li>CachedThreadPool使用没有容量的SynchronousQueue作为线程池的工作队列，但CachedThreadPool的maximumPool是无界的。</li>
<li>线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>
</ul>
</li>
</ol>
<h4 id="线程池都有哪些工作队列"><a href="#线程池都有哪些工作队列" class="headerlink" title="线程池都有哪些工作队列"></a>线程池都有哪些工作队列</h4><ul>
<li><strong>ArrayBlockingQueue</strong>：是一个<strong>基于数组结构的有界阻塞队列</strong>，此队列按FIFO（先进先出）原则对元素进行排序。</li>
<li><strong>LinkedBlockingQueue</strong>：是一个<strong>基于链表结构的阻塞队列</strong>，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</li>
<li><strong>SynchronousQueue</strong>：是一个<strong>不存储元素的阻塞队列</strong>。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</li>
<li><strong>PriorityBlockingQueue</strong>：一个<strong>具有优先级的无限阻塞队列</strong>。</li>
</ul>
<h4 id="创建线程的几种方式"><a href="#创建线程的几种方式" class="headerlink" title="创建线程的几种方式"></a>创建线程的几种方式</h4><ul>
<li><p>继承$Thread$类</p>
</li>
<li><p>实现$Runnaable$接口</p>
</li>
</ul>
<blockquote>
<p>不管是继承Thread还是实现Runnable接口，多线程代码都是通过运行Thread的start()方法来运行的。</p>
</blockquote>
<ul>
<li>实现$callable$接口</li>
</ul>
<blockquote>
<p>与Runnable接口不同的是，Callable接口提供了一个call() 方法作为线程执行体，call()方法可以有返回值、可以声明抛出异常</p>
</blockquote>
<ul>
<li>使用Executor框架来创建线程池</li>
</ul>
<h4 id="线程池的执行流程"><a href="#线程池的执行流程" class="headerlink" title="线程池的执行流程"></a>线程池的执行流程</h4><p>任务被提交到线程池，会先判断当前线程数量是否小于corePoolSize，如果小于则创建线程来执行提交的任务，否则将任务放入workQueue队列，如果workQueue满了，则判断当前线程数量是否小于maximumPoolSize,如果小于则创建线程执行任务，否则就会调用handler，以表示线程池拒绝接收任务。</p>
<blockquote>
<p>corePoolSize：线程池的基本大小</p>
<p>maximumPoolSize:最大线程数</p>
<p>workQueue：用于保存等待执行任务的阻塞队列</p>
<p>handler：拒绝策略</p>
</blockquote>
<h3 id="AQS-AbstractQueuedSynchronizer"><a href="#AQS-AbstractQueuedSynchronizer" class="headerlink" title="AQS(AbstractQueuedSynchronizer)"></a>AQS(AbstractQueuedSynchronizer)</h3><p>AQS 就是一个抽象类，主要用来构建锁和同步器。</p>
<p>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 <strong>CLH 队列锁</strong>实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<p><img src="https://camo.githubusercontent.com/02e863f3d5de3c34484f6162c1d0b3bf8912dbd70ac0a672bb99724f1f47f2d8/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f4a6176612532302545372541382538422545352542412538462545352539312539382545352542462538352545352541342538372545462542432539412545352542392542362545352538462539312545372539462541352545382541462538362545372542332542422545372542422539462545362538302542422545372542422539332f434c482e706e67" alt="enter image description here"></p>
<p>AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。</p>
<h4 id="AQS对资源的共享方式"><a href="#AQS对资源的共享方式" class="headerlink" title="AQS对资源的共享方式"></a>AQS对资源的共享方式</h4><p>AQS 定义两种资源共享方式：<strong>Exclusive</strong>（独占），<strong>Share</strong>（共享）</p>
<p><strong>独占：</strong></p>
<p>只有一个线程能执行，又可分为公平锁和非公平锁</p>
<ul>
<li><strong>公平锁</strong> ：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li><strong>非公平锁</strong> ：当线程要获取锁时，先通过两次 CAS 操作去抢锁，如果没抢到，当前线程再加入到队列中等待唤醒。</li>
</ul>
<p><strong>公平锁和非公平锁只有两处不同：</strong></p>
<ol>
<li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li>
<li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 <code>tryAcquire</code> 方法，在 <code>tryAcquire</code> 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li>
</ol>
<p>公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。</p>
<blockquote>
<p>非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p>
</blockquote>
<h3 id="TCP三次握手与四次挥手"><a href="#TCP三次握手与四次挥手" class="headerlink" title="TCP三次握手与四次挥手"></a>TCP三次握手与四次挥手</h3><h4 id="三次握手的过程"><a href="#三次握手的过程" class="headerlink" title="三次握手的过程"></a>三次握手的过程</h4><p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20200409195521.jfif" alt=""></p>
<ol>
<li><p>TCP服务器进程先创建<code>传输控制块TCB</code>，时刻准备接受客户进程的连接请求，此时服务器进入<code>LISTEN</code>状态。</p>
</li>
<li><p><strong>第一次握手</strong>： TCP客户进程也是先创建<code>TCB</code>,然后向服务器发出请求报文，此时报文中的<code>同部位SYN=1</code>（SYN，同步序列编号），同时选择一个初始序列号<code>seq=x</code>，此时TCP客户端进入<code>SYN-SENT(同步已发送)</code>状态。</p>
</li>
<li><p><strong>第二次握手：</strong> TCP服务器收到请求后，如果同意连接，则发出确认报文。<code>确认报文中应该ACK=1，SYN=1,确认号是ack=x+1</code>,同时为自己初始化一个序列号seq=y，此时TCP服务器进程进入<code>SYN-RCVD(同步收到)</code>状态。</p>
</li>
<li><p><strong>第三次握手：</strong> TCP客户进程收到确认后，还要向服务器给出确认。确认报文的<code>ACK=1,确认号ack=y+1</code>，自己序列号为：seq=x+1,此时，TCP连接已经建立，<strong>客户端</strong> 进入<code>ESTABLISHED(已建立连接)</code>状态，当 <strong>服务器</strong>收到客户端的确认后也进入**<code>ESTABLISHED</code>状态，双方可以开始通信。</p>
</li>
</ol>
<h4 id="为什么TCP客户端最后还要发送一次确认呢"><a href="#为什么TCP客户端最后还要发送一次确认呢" class="headerlink" title="为什么TCP客户端最后还要发送一次确认呢?"></a>为什么TCP客户端最后还要发送一次确认呢?</h4><p> 一句话，<strong>主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误</strong>。<br> 如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p>
<p> 如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p>
<h4 id="四次挥手的过程"><a href="#四次挥手的过程" class="headerlink" title="四次挥手的过程"></a>四次挥手的过程</h4><p>   <img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20200409212059.jfif" alt=""></p>
<ol>
<li><p>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部<code>FIN=1,序列号seq=u</code>(其值为之前传过来的数据最后一个字节的序号+1)，此时，<strong>客户端</strong>进入<code>FIN-WATI=1(终止等待1)</code>状态。</p>
</li>
<li><p>服务器收到连接释放报文，发出确认报文，<code>ACK=1,ack=u+1</code>,并且带上自身序列号<code>seq=v</code> ,此时，<strong>服务端</strong>进入<code>CLOSE-WATI(等待关闭)</code>状态。</p>
<blockquote>
<p>此时处于半关闭状态,即客户端已无数据需要发送，但服务器若是发送数据，客户端依然需要接收</p>
</blockquote>
</li>
<li><p>客户端收到服务器的确认请求，此时，客户端进入<code>FIN-WAIT-2(终止等待2)</code>状态，等待服务器发送连接释放报文。</p>
</li>
<li><p>服务器将最后的数据发送完毕之后，向客户端发送连接释放报文,<code>FIN=1,ack=u+1</code>，由于在半关闭状态，服务 器可能又发送了一些数据，因此假定此时的<code>序列号seq=w</code>,此时，服务器进入<code>LAST-ACK(最后确认)</code>状态。</p>
</li>
<li><p>客户端收到服务器的连接释放报文之后，必须发出确认<code>ACK=1,ack=w+1，seq=u+1</code>，此时客户端进入<code>TIME-WAIT(时间等待)</code>状态。</p>
<p>服务器只要收到了客户端发出的确认，立即进入<code>CLOSE</code>状态，同样，撤掉TCB后结束的此次连接(<code>可见，服务器结束TCP要早于客户端</code>)。</p>
<blockquote>
<p>此时TCP连接还未释放，必须经过2*MSL(<em>最长报文段寿命</em>)时间，客户端撤销相应TCB后，才进入<em>CLOSED</em>状态</p>
</blockquote>
</li>
</ol>
<h4 id="为什么建立连接是三次握手，释放连接确实四次挥手？"><a href="#为什么建立连接是三次握手，释放连接确实四次挥手？" class="headerlink" title="为什么建立连接是三次握手，释放连接确实四次挥手？"></a>为什么建立连接是三次握手，释放连接确实四次挥手？</h4><p>   建立连接时，服务器在LISTEN状态下，收到建立连接请求的 <em>SYN</em> 报文之后，把ACK和SYN放在一个报文发送给客户端。</p>
<p>   而在关闭连接时，服务器收到 <em>FIN</em>报文时，仅仅表示客户端不在发送数据但任能接收数据，因此客户端既可以立即关闭，也可以在发送一些数据给客户端之后，此时会先发送确认报文告知客户端已经准备关闭连接，当服务器数据发送完成之后，再发送 <em>FIN报文</em>给客户端。因此，服务端的ACK和FIN会分开发送，从而导致了四次挥手。</p>
<h4 id="三次握手过程中可以携带数据嘛"><a href="#三次握手过程中可以携带数据嘛" class="headerlink" title="三次握手过程中可以携带数据嘛"></a>三次握手过程中可以携带数据嘛</h4><p><strong>在第三次握手的时候可以携带数据</strong>，但是第一次、第二次握手不可以携带数据一个简单的原因就是会让服务器更加容易受到攻击，对于第三次的话，此时客户端已经处于ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据。</p>
<blockquote>
<p>假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。</p>
</blockquote>
<h3 id="如果已经建立连接，但是客户端出现故障-TCP的保活机制-keapalive长连接"><a href="#如果已经建立连接，但是客户端出现故障-TCP的保活机制-keapalive长连接" class="headerlink" title="如果已经建立连接，但是客户端出现故障(TCP的保活机制)(keapalive长连接)"></a>如果已经建立连接，但是客户端出现故障(TCP的保活机制)(keapalive长连接)</h3><p>TCP有一个机制是保活机制，工作原理为：当一个TCP 连接建立之后，启用TCP Keepalive 的一端便会启动一个计时器，当这个计时器数值到达0 内（7200s)，连接没有任何动作,，一个TCP 探测包便会被发出。这个TCP 探测包是一个纯ACK 包，客户主机必须处于以下4 个状态之一：</p>
<ol>
<li>客户主机依然正常运行，并从服务器可达。客户的TCP 响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。</li>
<li>客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP 都没有响应。服务端将不能收到对探测的响应，并在75 秒后超时。服务器总共发送9 个这样的探测，每个间隔75 秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。</li>
<li>客户主机崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，但是由于没有该连接的有效信息，会产生一个RST报文，这样很快就发现TCP连接已经被重置。</li>
</ol>
<blockquote>
<p>保活机制需要消耗额外的宽带和流量。</p>
</blockquote>
<h3 id="TCP的重传机制"><a href="#TCP的重传机制" class="headerlink" title="TCP的重传机制"></a>TCP的重传机制</h3><p>TCP实现可靠传输的方式之一，是通过序列号与确认应答。</p>
<p>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。万一数据在传输过程中丢失了呢？所以 TCP 针对数据包丢失的情况，会用<strong>重传机制</strong>解决。</p>
<p><strong>超时重传</strong></p>
<p>在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据，也就是我们常说的<strong>超时重传</strong>。</p>
<p><strong>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值,每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。</strong></p>
<blockquote>
<p>TCP 会在以下两种情况发生超时重传：</p>
<ul>
<li>数据包丢失</li>
<li>确认应答丢失</li>
</ul>
</blockquote>
<p><strong>快速重传</strong></p>
<p>快速重传机制<strong>不以时间为驱动，而是以数据驱动重传</strong>。快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</p>
<img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909091033.png" style="zoom: 80%;" />

<p>在上图，发送方发出了 1，2，3，4，5 份数据：</p>
<ul>
<li>第一份 Seq1 先送到了，于是就 Ack 回 2；</li>
<li>结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；</li>
<li>后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；</li>
<li><strong>发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。</strong></li>
<li>最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。</li>
</ul>
<blockquote>
<p>因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的,所以快速重传临着另外一个问题。就是<strong>重传的时候，是重传之前的一个，还是重传所有的问题。</strong></p>
</blockquote>
<p><strong>SACK方法(选择性确认)</strong></p>
<p>这种方式需要在 TCP 头部「选项」字段里加一个 <code>SACK</code> 的东西，它<strong>可以将缓存的地图发送给发送方</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong></p>
<p>如下图，发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 <code>SACK</code> 信息发现只有 <code>200~299</code> 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909091602.png" alt=""></p>
<p><strong>Duplicate SACK</strong></p>
<p>Duplicate SACK 又称 <code>D-SACK</code>，其主要<strong>使用了 SACK 来告诉「发送方」有哪些数据被重复接收了</strong></p>
<blockquote>
<ol>
<li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li>
<li>可以知道是不是「发送方」的数据包被网络延迟了;</li>
<li>可以知道网络中是不是把「发送方」的数据包给复制了;</li>
</ol>
</blockquote>
<h3 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h3><p>流量控制是为了控制发送方发送速率，让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。<br>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为0，则发送方不能发送数据。</p>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p><strong>为什么需要滑动窗口：</strong>按数据包进行确认应答的传输方式有一个缺点：数据包的<strong>往返时间越长，通信的效率就越低</strong>。</p>
<p>为解决这个问题，TCP 引入了<strong>窗口</strong>这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。</p>
<p>那么有了窗口，就可以指定窗口大小，窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。</p>
<p>TCP 头里有一个字段叫 <code>Window</code>，也就是窗口大小。</p>
<p><strong>这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来</strong></p>
<p>发送方的滑动窗口</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909103101.png" alt=""></p>
<blockquote>
<ul>
<li>#1 是已发送并收到 ACK确认的数据：1~31 字节</li>
<li>#2 是已发送但未收到 ACK确认的数据：32~45 字节</li>
<li>#3 是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51字节</li>
<li>#4 是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后</li>
</ul>
</blockquote>
<p>接收方的滑动窗口</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909103156.png" alt=""></p>
<blockquote>
<ul>
<li>#1 + #2 是已成功接收并确认的数据（等待应用进程读取）；</li>
<li>#3 是未收到数据但可以接收的数据；</li>
<li>#4 未收到数据并不可以接收的数据</li>
</ul>
</blockquote>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大…</p>
<p>于是，就有了<strong>拥塞控制</strong>，控制的目的就是<strong>避免「发送方」的数据填满整个网络。</strong></p>
<blockquote>
<p><strong>此处引入一个拥塞窗口：</strong><br><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</p>
<p>加入了拥塞窗口的概念后，此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。</p>
</blockquote>
<p><strong>如何判断当前网络是否出现了拥塞</strong></p>
<p>其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是<strong>发生了超时重传，就会认为网络出现了用拥塞。</strong></p>
<p><strong>拥塞控制有哪些控制算法：</strong></p>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>拥塞发生</li>
<li>快速恢复</li>
</ul>
<p><strong>慢启动</strong></p>
<p>慢启动的意思就是一点一点的提高发送数据包的数量，</p>
<p>慢启动的算法记住一个规则就行：<strong>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。</strong></p>
<p>这里假定拥塞窗口 <code>cwnd</code> 和发送窗口 <code>swnd</code> 相等，下面举个栗子：</p>
<ul>
<li>连接建立完成后，一开始初始化 <code>cwnd = 1</code>，表示可以传一个 <code>MSS</code> 大小的数据。</li>
<li>当收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2 个</li>
<li>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以比之前多发2 个，所以这一次能够发送 4 个</li>
<li>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以比之前多发 4 个，所以这一次能够发送 8 个。</li>
</ul>
<blockquote>
<p>慢启动算法，发包的个数是<strong>指数性的增长</strong></p>
</blockquote>
<p>存在一个慢启动门限(ssthresh)状态变量(一般是65535字节)</p>
<ul>
<li>当 <code>cwnd</code> &lt; <code>ssthresh</code> 时，使用慢启动算法。</li>
<li>当 <code>cwnd</code> &gt;= <code>ssthresh</code> 时，就会使用「拥塞避免算法」。</li>
</ul>
<p><strong>拥塞避免</strong></p>
<p>进入拥塞避免算法后，它的规则是：<strong>每当收到一个 ACK 时，cwnd 增加 1/cwnd。</strong></p>
<blockquote>
<ul>
<li>当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 <code>MSS</code> 大小的数据，变成了<strong>线性增长。</strong></li>
</ul>
</blockquote>
<p><strong>拥塞发生</strong></p>
<p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：超时重传；快速重传</p>
<p><strong>超时重传的拥塞发生算法：</strong>当发生了超时重传，则就会使用拥塞发生算法。</p>
<p>这个时候，ssthresh 和 cwnd 的值会发生变化：</p>
<ul>
<li><code>ssthresh</code> 设为 <code>cwnd/2</code>，</li>
<li><code>cwnd</code> 重置为 <code>1</code></li>
</ul>
<blockquote>
<p>接着，就重新开始慢启动，慢启动是会突然减少数据流的。这种方式太激进了，反应也很强烈，会造成网络卡顿。</p>
</blockquote>
<p><strong>快速重传的拥塞发生算法：</strong>当发生快速重传的时候，则使用快速重传的拥塞发生算法</p>
<ul>
<li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li>
<li><code>ssthresh = cwnd</code>;</li>
<li>进入快速恢复算法</li>
</ul>
<p><strong>快速恢复算法</strong></p>
<p>快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 <code>RTO</code> 超时那么强烈。</p>
<ul>
<li>拥塞窗口 <code>cwnd = ssthresh + 3</code> （ 3 的意思是确认有 3 个数据包被收到了）；</li>
<li>重传丢失的数据包；</li>
<li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li>
<li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909151522.png" alt=""></p>
<h3 id="TCP的可靠性"><a href="#TCP的可靠性" class="headerlink" title="TCP的可靠性"></a>TCP的可靠性</h3><p><strong>1. 校验和</strong></p>
<p><strong>计算方式：</strong>检验和是存在于各种报文中的一个字段，它存在的目的是验证报文在网络传输过程中的完整性。因此，在报文的发送端，会根据报文中的首部或数据来计算一个检验和，然后一旦接收端接受到相应报文，接收端也会对报文的首部或数据进行一次检验和计算，如果接收端算出来的检验和和发送端发送的不一样，那么接收端认为报文在传输过程中出了错，于是就丢掉该报文。</p>
<blockquote>
<p>在数据传输的过程中，将发送的数据段都当做一个16 位的整数。将这些整数加起来。并且前面的进位不能丢弃，补在后面，最后取反，得到校验和</p>
</blockquote>
<blockquote>
<p>接收方和发送方校验和比对一致，数据也不一定传输成功。</p>
</blockquote>
<p><strong>2.序列号和确认应答</strong></p>
<p><strong>序列号</strong>：TCP 传输时<strong>将每个字节的数据都进行了编号</strong>，这就是序列号。序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是TCP 传输可靠性的保证之一。</p>
<p><strong>确认应答：</strong>TCP 传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK 报文。这个<strong>ACK 报文当中带有对应的确认序列号</strong>，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。</p>
<p><strong>3. 连接管理：</strong>即TCP建立连接时的三次握手与四次挥手</p>
<p><strong>4. 重传机制</strong>；<strong>5. 流量控制</strong>；<strong>6.拥塞控制</strong></p>
<h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><ol>
<li>TCP 面向连接（如打电话要先拨号建立连接）;UDP 是无连接的，即发送数据之前不需要建立连接</li>
<li>TCP 提供可靠的服务。也就是说，通过TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP 尽最大努力交付，即不保证可靠交付</li>
<li>TCP 面向字节流，实际上是TCP 把数据看成一连串无结构的字节流;UDP 是面向报文的，UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP 电话，实时视频会议等），并且UDP 速度更快</li>
<li>每一条TCP 连接只能是点到点的;UDP 支持一对一，一对多，多对一和多对多的交互通信</li>
<li>TCP 首部开销20 字节;UDP 的首部开销小，只有8 个字节</li>
<li>TCP 的逻辑通信信道是全双工的可靠信道，UDP 则是不可靠信道</li>
</ol>
<h4 id="TCP和UDP的应用"><a href="#TCP和UDP的应用" class="headerlink" title="TCP和UDP的应用"></a>TCP和UDP的应用</h4><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909152412.png" style="zoom:50%;" />

<h3 id="在浏览器输入url地址到显示主页的过程"><a href="#在浏览器输入url地址到显示主页的过程" class="headerlink" title="在浏览器输入url地址到显示主页的过程"></a>在浏览器输入url地址到显示主页的过程</h3><ol>
<li>DNS解析：获取域名对应IP</li>
<li>建立TCP连接</li>
<li>发生HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>结束连接</li>
</ol>
<h3 id="JVM-新生代和老年代都使用什么GC算法"><a href="#JVM-新生代和老年代都使用什么GC算法" class="headerlink" title="JVM 新生代和老年代都使用什么GC算法"></a>JVM 新生代和老年代都使用什么GC算法</h3><h4 id="新生代和老年代的区别"><a href="#新生代和老年代的区别" class="headerlink" title="新生代和老年代的区别"></a>新生代和老年代的区别</h4><p><img src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/01d330d8-2710-4fad-a91c-7bbbfaaefc0e.png" alt="img">新生代和老年代是针对于分代收集算法来定义的，新生代又分为Eden 和Survivor 两个区。加上老年代就这三个区。数据会首先分配到Eden 区当中（当然也有特殊情况，<strong>如果是大对象那么会直接放入到老年代</strong>（大对象是指需要大量连续内存空间的java 对象）。），<strong>当Eden没有足够空间的时候就会触发jvm 发起一次Minor GC</strong>。如果对象经过一次Minor GC 还存活，并且又能被Survivor 空间接受，那么将被移动到Survivor 空间当中。并将其年龄设为1，对象在Survivor 每熬过一次Minor GC，年龄就加1，当年龄达到一定的程度（默认为15）时，就会被晋升到老年代中了，当然晋升老年代的年龄是可以设置的。如果老年代满了就执行：Full GC 因为不经常执行，因此采用了Mark-Compact 算法清理。</p>
<p><strong>新生代回收</strong>的判断条件是新生代内存不足时候。新生代主要是用来存放新生的对象，会频繁创建对象，所有垃圾收集会频繁进行回收。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。</p>
<p><strong>新生代使用的算法：复制（Copy）算法</strong><br>将可用内存容量划分为大小相等的两块，每次只用其中一块。当这块内存用完了，就将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。(From到to；to到from)</p>
<blockquote>
<p>优点：不会产生大量不连续的内存空间</p>
<p>缺点：效率也不是很高，需要占用双倍内存空间</p>
</blockquote>
<p><strong>老年代回收的判断条件</strong></p>
<ol>
<li><p><strong>System.gc()方法的调用</strong>，在代码中调用System.gc()方法会<strong>建议</strong>JVM 进行Full GC，在大多数情况下会增加Full GC的次数，导致系统性能下降，一般不建议手动进行此方法的调用。</p>
</li>
<li><p><strong>老年代空间不足</strong>：在Survivor 区域的对象满足晋升到老年代的条件时，晋升进入老年代的对象大小大于老年代的可用内存，这个时候会触发Full GC。</p>
</li>
<li><p><strong>Metaspace 区内存达到阈值：</strong>Metaspace 使用的是本地内存，而不是堆内存，也就是说在默认情况下Metaspace<br>的大小只与本地内存大小有关（约为20.8MB），超过这个值就会引发Full GC，这个值不是固定的，是会随着JVM 的运行进行动态调整的。</p>
</li>
<li><p><strong>堆中产生大对象超过阈值：</strong>大对象或者长期存活的对象进入老年代，典型的大对象就是很长的字符串或者数组，它们在被创建后会直接进入老年代，在要放置的时候JVM 如果发现老年代的空间不足时，会触发GC。</p>
</li>
<li><p><strong>老年代连续空间不足：</strong>JVM 如果判断老年代没有做足够的连续空间来放置大对象，那么就会引起Full GC</p>
</li>
<li><p><strong>统计得到的Minor GC 晋升到旧生代的平均大小大于老年代的剩余空间</strong></p>
<blockquote>
<p>新生代晋升的另外一种情况是如果JVM 发现Survivor 区域中的相同年龄的对象占到所有对象的一半以上时，就会将大于这个年龄的对象移动到老年代，在这批对象在统计后发现可以晋升到老年代，但是发现老年代没有足够的空间来放置这些对象，这就会引起Full GC</p>
</blockquote>
</li>
</ol>
<p><strong>老年代使用的算法</strong></p>
<p><strong>标记清除：</strong></p>
<p>标记清除算法是最基础的回收算法，分为标记和清除两个部分：首先标记出所有需要回收的对象，这一过程<strong>在可达性分析过程中进行</strong>。在标记完之后统一回收所有被标记的对象。</p>
<img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909213741.png" style="zoom:80%;" />

<blockquote>
<p><strong>优点</strong>：速度较快</p>
<p><strong>缺点：</strong>会造成内存碎片，导致在程序运行过程中需要分配较大对象的时候，无法找到足够的连续内存而不得不提前触发一次垃圾收集动作。</p>
</blockquote>
<p><strong>标记整理：</strong></p>
<p>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210909213810.png" style="zoom:80%;" />

<blockquote>
<p><strong>优点：</strong>没有内存碎片<br><strong>缺点：</strong>速度慢</p>
</blockquote>
<p><strong>分代垃圾回收：</strong>根据各个年代的特点采取最适当的收集算法</p>
<p>在新生代中，每次垃圾收集时候都发现有大批对象死去，只有少量存活，那就选用复制算法。只需要付出少量存活对象的复制成本就可以完成收集。<br> 老年代中因为对象存活率高、没有额外空间对他进行分配担保，就必须用标记-清除或者标记-整理。</p>
<h3 id="JVM垃圾收集器"><a href="#JVM垃圾收集器" class="headerlink" title="JVM垃圾收集器"></a>JVM垃圾收集器</h3><h4 id="CMS-Concurrent-Mark-Sweep-回收器："><a href="#CMS-Concurrent-Mark-Sweep-回收器：" class="headerlink" title="CMS(Concurrent Mark Sweep)回收器："></a>CMS(Concurrent Mark Sweep)回收器：</h4><p>CMS收集器是一种<strong>以获取最短回收停顿时间为目标的收集器</strong>，是HotSpot虚拟机第一款真正意义上的并发收集器，第一次实现了垃圾收集线程和用户线程基本上同时工作</p>
<p>CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，整个过程分为四个步骤：</p>
<ol>
<li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li>
<li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>
<li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li>
<li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210910143806.png" alt=""></p>
<blockquote>
<p><strong>缺点：</strong></p>
<ol>
<li><p>对 CPU 资源敏感；</p>
</li>
<li><p>无法处理浮动垃圾，CMS 在并发清理阶段线程还在运行， 伴随着程序的运行自然也会产生新的垃圾，这一部分垃圾产生在标记过程之后，CMS 无法再当次过程中处理，所以只有等到下次gc 时候在清理掉。</p>
</li>
<li><p>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</p>
</li>
</ol>
</blockquote>
<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p><strong>G1 (Garbage-First)</strong> 是一款<strong>面向服务器的垃圾收集器</strong>,主要针对配备多颗处理器及大容量内存的机器. 以<strong>极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p>
<p>G1 可面向<strong>堆任何部分</strong>来组成回收集进行回收，<strong>衡量标准不再是分代</strong>，而是哪块内存中存放的垃圾数量最多，回收受益最大。</p>
<p><strong>G1的特点：</strong></p>
<ol>
<li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li>
<li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li>
<li><strong>空间整合</strong>：与 CMS 的“标记-清理”算法不同，G1 从<strong>整体来看是基于“标记-整理”算法</strong>实现的收集器；从<strong>局部上来看是基于“标记-复制”</strong>算法实现的。</li>
<li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li>
</ol>
<p><strong>G1运作步骤：</strong></p>
<ol>
<li><strong>初始标记：</strong>标记GC Roots 能直接关联到的对象</li>
<li><strong>并发标记：</strong>从GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆的对象图</li>
<li><strong>最终标记：</strong>对用户线程做短暂暂停，处理并发阶段结束后仍遗留下来的少量SATB 记录</li>
<li><strong>筛选回收：</strong>对各Region 的回收价值排序，根据用户期望停顿时间制定回收计划。必须暂停用户线程，由多条收集线程并行完成。</li>
</ol>
<blockquote>
<p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>
</blockquote>
<h4 id="其他收集器"><a href="#其他收集器" class="headerlink" title="其他收集器"></a>其他收集器</h4><p><strong>Serial收集器:</strong> 单线程收集器，收集垃圾时，<strong>必须暂停其他所有的工作线程</strong>（stop the world），<strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p>
<p><strong>ParNew 收集器：</strong>其实就<strong>是 Serial 收集器的多线程版本</strong>，除了使用多线程进行垃圾收集外，其余行为和 Serial 收集器完全一样。(只有Serial和ParNew可以和CMS配合工作)</p>
<p><strong>Parallel Scavenge收集器：</strong>新生代收集器，基于复制算法，是可并行的多线程收集器，与ParNew 类似。特点是它的<br>关注点与其他收集器不同，Parallel Scavenge 的目标是达到一个可控制的吞吐量，所谓吞吐量就是处理器用于运行用户代码的时间与处理器消耗总时间的比值</p>
<p><strong>Serial Old</strong>:Serial 收集器的老年代版本，它同样是一个单线程收集器,采用标记-整理算法</p>
<p><strong>Parnew Old:</strong>Parallel Scavenge 收集器的老年代版本**。使用多线程和“标记-整理”算法</p>
<h3 id="JVM-GC调优"><a href="#JVM-GC调优" class="headerlink" title="JVM GC调优"></a>JVM GC调优</h3><p><strong>参数基本策略：</strong></p>
<p>各分区的大小对GC的性能影响很大。如何将各分区调整到合适的大小，分析活跃数据的大小是很好的切入点。</p>
<p><strong>活跃数据的大小</strong>是指，应用程序稳定运行时长期存活对象在堆中占用的空间大小，也就是Full GC后堆中老年代占用空间的大小。可以通过GC日志中Full GC之后老年代数据大小得出</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210911100540.png" alt=""></p>
<p>例如，根据GC日志获得老年代的活跃数据大小为300M，那么各分区大小可以设为：</p>
<blockquote>
<p>总堆：1200MB = 300MB × 4* 新生代：450MB = 300MB × 1.5* 老年代： 750MB = 1200MB - 450MB*</p>
</blockquote>
<p><strong>这部分设置仅仅是堆大小的初始值，后面的优化中，可能会调整这些值，具体情况取决于应用程序的特性和需求。</strong></p>
<p>GC优化一般步骤可以概括为：确定目标、优化参数、验收结果。</p>
<p><strong>确定目标：</strong>低延迟还是高吞吐量</p>
<p><strong>优化参数：</strong>结合需求选用合适的GC回收器、重新设置内存比例、调整JVM参数</p>
<h4 id="Minor-GC和Major-GC频繁"><a href="#Minor-GC和Major-GC频繁" class="headerlink" title="Minor GC和Major GC频繁"></a>Minor GC和Major GC频繁</h4><p><strong>优化</strong></p>
<p>首先优化Minor GC频繁问题。通常情况下，由于新生代空间较小，Eden区很快被填满，就会导致频繁Minor GC，因此可以通过增大新生代空间来降低Minor GC的频率。例如在相同的内存分配率的前提下，新生代中的Eden区增加一倍，Minor GC的次数就会减少一半。</p>
<p><strong>扩容Eden区虽然可以减少Minor GC的次数，但会增加单次Minor GC时间么</strong>？我们结合下面情况来分析，单次Minor GC时间主要受哪些因素影响？是否和新生代大小存在线性关系？ 首先，单次Minor GC时间由以下两部分组成：T1（扫描新生代）和 T2（复制存活对象到Survivor区）如下图。（注：这里为了简化问题，我们认为T1只扫描新生代判断对象是否存活的时间，其实该阶段还需要扫描部分老年代）</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/6eb9b856.png" alt="img"></p>
<ul>
<li>扩容前：新生代容量为R ，假设对象A的存活时间为750ms，Minor GC间隔500ms，那么本次Minor GC时间= T1（扫描新生代R）+T2（复制对象A到S）。</li>
<li>扩容后：新生代容量为2R ，对象A的生命周期为750ms，那么Minor GC间隔增加为1000ms，此时Minor GC对象A已不再存活，不需要把它复制到Survivor区，那么本次GC时间 = 2 × T1（扫描新生代R），没有T2复制时间。</li>
</ul>
<p>可见，扩容后，Minor GC时增加了T1（扫描时间），但省去T2（复制对象）的时间，更重要的是对于虚拟机来说，复制对象的成本要远高于扫描成本，所以，单次<strong>Minor GC时间更多取决于GC后存活对象的数量，而非Eden区的大小</strong>。因此<strong>如果堆中短期对象很多，那么扩容新生代，单次Minor GC时间不会显著增加</strong>。下面需要确认下服务中对象的生命周期分布情况：<strong>对象生命周期的分布情况：如果应用存在大量的短期对象，应该选择较大的年轻代；如果存在相对较多的持久对象，老年代应该适当增大。</strong></p>
<h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210910164815.png" alt=""></p>
<p>类加载过程的第一步，主要完成下面 3 件事情：</p>
<ol>
<li>通过全类名获取定义此类的二进制字节流</li>
<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口</li>
</ol>
<p><strong>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 <code>loadClass()</code> 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建</strong></p>
<h4 id="知道哪些类加载器"><a href="#知道哪些类加载器" class="headerlink" title="知道哪些类加载器"></a>知道哪些类加载器</h4><p>JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>：</p>
<ol>
<li><strong>BootstrapClassLoader(启动类加载器)</strong> ：最顶层的加载类，由 C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的 jar 包和类或者被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</li>
<li><strong>ExtensionClassLoader(扩展类加载器)</strong> ：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的 jar 包。</li>
<li><strong>AppClassLoader(应用程序类加载器)</strong> ：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</li>
</ol>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>每一个类都有一个对应它的类加载器。系统中的 ClassLoader 在协同工作的时候会默认使用 <strong>双亲委派模型</strong> 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派给父类加载器的 <code>loadClass()</code> 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器。</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210910165114.png" alt=""></p>
<blockquote>
<p><code>AppClassLoader</code>的父类加载器为<code>ExtClassLoader</code>， <code>ExtClassLoader</code>的父类加载器为 null，<strong>null 并不代表<code>ExtClassLoader</code>没有父类加载器，而是 <code>BootstrapClassLoader</code></strong> </p>
</blockquote>
<p><strong>双亲委派模型的好处</strong></p>
<p>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现多个不同的 <code>Object</code> 类。</p>
<p><strong>如果不想使用双亲委派模型</strong></p>
<p>为了避免双亲委派模型，可以自定义一个类加载器，然后重载loadClass()</p>
<p><strong>如何自定义类加载器</strong></p>
<p>除了BootStrapClassLoader,其他类加载器均由Java实现，且全部继承自Java.lang.ClassLoader，如果要自定义类加载器，需要继承ClassLoader。</p>
<h3 id="简单介绍一下redis"><a href="#简单介绍一下redis" class="headerlink" title="简单介绍一下redis"></a>简单介绍一下redis</h3><p>简单来说，redis就是一个数据库，不过与传统数据库不同的是redis的数据是存储在内存中的，所以读写速度非常快，因此redis被广泛应用于缓存方向，redis提供了多种数据类型来支持不同的业务场景。</p>
<p><strong>缓存数据的处理流程是怎样的：</strong></p>
<ol>
<li>如果用户请求的数据在缓存中就直接返回。</li>
<li>缓存中不存在的话就看数据库中是否存在。</li>
<li>数据库中存在的话就更新缓存中的数据。</li>
<li>数据库中不存在的话就返回空数据。</li>
</ol>
<h3 id="redis常见数据结构"><a href="#redis常见数据结构" class="headerlink" title="redis常见数据结构"></a>redis常见数据结构</h3><p><strong>String</strong></p>
<p><strong>介绍</strong> ：string 数据结构是简单的 key-value 类型。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)。</p>
<p><strong>应用场景：</strong> 一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。</p>
<p><strong>list</strong></p>
<p>Redis 的 list 的实现为一个 <strong>双向链表</strong>，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p>
<p><strong>应用场景</strong>:发布与订阅或者说消息队列、慢查询。</p>
<p><strong>hash：</strong></p>
<p>hash 是一个 string 类型的 field 和 value 的映射表，<strong>特别适合用于存储对象</strong>，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。</p>
<p><strong>应用场景:</strong> 系统中对象数据的存储。</p>
<p><strong>set</strong></p>
<p>Redis 中的 set 类型是一种无序集合，集合中的元素没有先后顺序。 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作</p>
<p><strong>sorted set</strong></p>
<p>和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。</p>
<h3 id="为什么要用redis缓存"><a href="#为什么要用redis缓存" class="headerlink" title="为什么要用redis缓存"></a>为什么要用redis缓存</h3><p><strong>高性能:</strong></p>
<p>假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，因为是从硬盘中读取的，将用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变之后，同步改变缓存中相应的数据即可。</p>
<p><strong>高并发：</strong></p>
<p>直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。</p>
<h3 id="redis和memcached"><a href="#redis和memcached" class="headerlink" title="redis和memcached"></a>redis和memcached</h3><p><strong>共同点</strong> ：</p>
<ol>
<li>都是基于内存的数据库，一般都用来当做缓存使用。</li>
<li>都有过期策略。</li>
<li>两者的性能都非常高。</li>
</ol>
<p><strong>区别</strong> ：</p>
<ol>
<li><strong>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</strong>。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。</li>
<li><strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memecache 把数据全部存在内存之中。</strong></li>
<li><strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</li>
<li><strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></li>
<li><strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。</strong></li>
<li><strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</strong> （Redis 6.0 引入了多线程 IO ）</li>
</ol>
<h3 id="redis内存淘汰机制"><a href="#redis内存淘汰机制" class="headerlink" title="redis内存淘汰机制"></a>redis内存淘汰机制</h3><blockquote>
<p>相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</p>
</blockquote>
<p>Redis 提供 6 种数据淘汰策略：</p>
<ol>
<li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集中挑选将要过期的数据淘汰</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集中任意选择数据淘汰</li>
<li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（最常用的）</li>
<li><strong>allkeys-random</strong>：从数据集中任意选择数据淘汰</li>
<li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。</li>
</ol>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。</p>
<h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。</p>
<p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p>
<p>加入布隆过滤器之后的缓存处理流程图如下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsuanPic/Pic/pic/20210914095535.png" alt=""></p>
<p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p>
<p><em>为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！</em></p>
<p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p>
<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>
</ol>
<p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p>
<ol>
<li>对给定元素再次进行相同的哈希计算；</li>
<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>
</ol>
<p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong></p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>实际上，缓存雪崩描述的就是这样一个简单的场景：<strong>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</strong> 这就好比雪崩一样</p>
<p>举个例子：系统的缓存模块出了问题比如宕机导致不可用。造成系统的所有访问，都要走数据库。</p>
<p>还有一种缓存雪崩的场景是：<strong>有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上</strong></p>
<p><strong>有哪些解决办法？</strong></p>
<p><strong>针对 Redis 服务不可用的情况：</strong></p>
<ol>
<li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li>
<li>限流，避免同时处理大量的请求。</li>
</ol>
<p><strong>针对热点缓存失效的情况：</strong></p>
<ol>
<li>设置不同的失效时间比如随机设置缓存的失效时间。</li>
<li>缓存永不失效。</li>
</ol>
<h3 id="redis的持久化"><a href="#redis的持久化" class="headerlink" title="redis的持久化"></a>redis的持久化</h3><p>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持两种不同的持久化操作。<strong>Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）</strong>。</p>
<p><strong>快照（snapshotting）持久化（RDB）</strong></p>
<p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p>
<p><strong>AOF（append-only file）持久化</strong></p>
<p>与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 <code>server.aof_buf</code> 中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件。</p>
<p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 <code>appendonly.aof</code>。</p>
<p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span><br><span class="line">appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘</span><br><span class="line">appendfsync no        #让操作系统决定何时进行同步</span><br></pre></td></tr></table></figure>

<p>为了兼顾数据和写入性能，用户可以考虑 <code>appendfsync everysec</code> 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p>
<h3 id="如何保证缓存与数据库双写时的一致性"><a href="#如何保证缓存与数据库双写时的一致性" class="headerlink" title="如何保证缓存与数据库双写时的一致性"></a>如何保证缓存与数据库双写时的一致性</h3><p>对 <strong>Cache Aside Pattern（旁路缓存模式）</strong></p>
<p>Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。</p>
<p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：</p>
<ol>
<li><strong>增加 cache 更新重试机制（常用）</strong>： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。</li>
</ol>
<h3 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h3><p><strong>MyISAM和InnoDB区别：</strong></p>
<p>MyISAM是MySQL的默认数据库引擎(5.5之前),当前的默认存储引擎为InnoDB</p>
<p><strong>1. 是否支持行级锁</strong></p>
<p>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</p>
<p><strong>2.是否支持事务</strong></p>
<p>MyISAM 不提供事务支持。</p>
<p>InnoDB 提供事务支持，具有提交(commit)和回滚(rollback)事务的能力。</p>
<p><strong>3.是否支持外键</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p><strong>4.是否支持数据库异常崩溃后的安全恢复</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code> 。</p>
<blockquote>
<p><strong>表级锁和行级锁对比：</strong></p>
<ul>
<li><strong>表级锁：</strong> MySQL 中锁定 <strong>粒度最大</strong> 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。</li>
<li><strong>行级锁：</strong> MySQL 中锁定 <strong>粒度最小</strong> 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li>
</ul>
</blockquote>
<h3 id="MySQL的事务"><a href="#MySQL的事务" class="headerlink" title="MySQL的事务"></a>MySQL的事务</h3><p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p>
<p><strong>什么是数据库事务的作用：</strong>数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：<strong>要么全部执行成功,要么全部不执行</strong> 。</p>
<p><img src="https://camo.githubusercontent.com/d9c8448f21fb27f4565e846dc1b63077c01f3e27e03764940f4e1b8ec4731514/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f323032302d31322f3634302d32303230313230373136303535343637372e706e67" alt="img"></p>
<p><strong>事务的ACID特性：</strong></p>
<ol>
<li><strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li>
<li><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性</strong>（<code>Durability</code>）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<blockquote>
<p><strong>数据事务的实现原理呢？</strong></p>
<p>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</p>
<p>MySQL InnoDB 引擎通过 <strong>锁机制</strong>、<strong>MVCC</strong> 等手段来保证事务的隔离性（ 默认支持的隔离级别是 <strong><code>REPEATABLE-READ</code></strong> ）。</p>
<p>保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。</p>
</blockquote>
<p><strong>并发事务带来的问题：</strong></p>
<ul>
<li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li>
<li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。</li>
<li><strong>不可重复读（Unrepeatable read）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li>
<li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<h3 id="事务隔离级别有哪些"><a href="#事务隔离级别有哪些" class="headerlink" title="事务隔离级别有哪些"></a>事务隔离级别有哪些</h3><ul>
<li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li>
<li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li>
<li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li>
<li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li>
</ul>
<blockquote>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong></p>
</blockquote>
<h3 id="一条SQL执行的很慢有哪些原因"><a href="#一条SQL执行的很慢有哪些原因" class="headerlink" title="一条SQL执行的很慢有哪些原因"></a>一条SQL执行的很慢有哪些原因</h3><p>一个 SQL 执行的很慢，我们要分两种情况讨论：</p>
<p>1、大多数情况下很正常，偶尔很慢，则有如下原因</p>
<p>(1)、数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。</p>
<p>(2)、执行的时候，遇到锁，如表锁、行锁。</p>
<p>2、这条 SQL 语句一直执行的很慢，则有如下原因。</p>
<p>(1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。</p>
<p>(2)、数据库选错了索引。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
            <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag"># 多线程</a>
          
            <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag"># 计算机网络</a>
          
            <a href="/tags/redis/" rel="tag"># redis</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/05/29/%E8%AE%B0%E4%B8%80%E6%AC%A1CentOs7%E4%B8%8A%E5%AE%89%E8%A3%85Oracle%E7%9A%84%E8%B8%A9%E5%9D%91%E8%BF%87%E7%A8%8B/" rel="next" title="记一次CentOs7上安装Oracle的踩坑过程">
                <i class="fa fa-chevron-left"></i> 记一次CentOs7上安装Oracle的踩坑过程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/10/12/DiskGenius%E7%A3%81%E7%9B%98%E5%88%92%E5%88%86/" rel="prev" title="DiskGenius磁盘划分">
                DiskGenius磁盘划分 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
     <div id="gitalk-container"></div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/bear.png"
                alt="摸鱼选手Wei" />
            
              <p class="site-author-name" itemprop="name">摸鱼选手Wei</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/CloudMadao" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          
		  
		  

  <div class="links-of-blogroll motion-element links-of-blogroll-block">
   <div class="links-of-blogroll-title">
     <!-- modify icon to fire by szw -->
     <i class="fa fa-history fa-" aria-hidden="true"></i>
     近期文章
   </div>
   <ul class="links-of-blogroll-list">
     
     
       <li>
         <a href="/2021/10/12/DiskGenius%E7%A3%81%E7%9B%98%E5%88%92%E5%88%86/" title="DiskGenius磁盘划分" target="_blank">DiskGenius磁盘划分</a>
       </li>
     
       <li>
         <a href="/2021/09/10/java%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/" title="java面试笔记" target="_blank">java面试笔记</a>
       </li>
     
       <li>
         <a href="/2020/05/29/%E8%AE%B0%E4%B8%80%E6%AC%A1CentOs7%E4%B8%8A%E5%AE%89%E8%A3%85Oracle%E7%9A%84%E8%B8%A9%E5%9D%91%E8%BF%87%E7%A8%8B/" title="记一次CentOs7上安装Oracle的踩坑过程" target="_blank">记一次CentOs7上安装Oracle的踩坑过程</a>
       </li>
     
       <li>
         <a href="/2020/05/07/Hexo-NexT%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" title="Hexo+NexT搭建个人博客" target="_blank">Hexo+NexT搭建个人博客</a>
       </li>
     
   </ul>
  </div>
 
  
           
         
         
<div style="">
  <canvas id="canvas" style="width:60%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
</div>
<script>
(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();
</script>
        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java面试笔记"><span class="nav-number">1.</span> <span class="nav-text">Java面试笔记</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象与面向过程的区别"><span class="nav-number">2.</span> <span class="nav-text">面向对象与面向过程的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#C-和Java"><span class="nav-number">2.1.</span> <span class="nav-text">C++和Java</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象的特点"><span class="nav-number">3.</span> <span class="nav-text">面向对象的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java中子类的初始化顺序"><span class="nav-number">4.</span> <span class="nav-text">Java中子类的初始化顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象类和接口的区别"><span class="nav-number">5.</span> <span class="nav-text">抽象类和接口的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重写和重载"><span class="nav-number">6.</span> <span class="nav-text">重写和重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动装箱与拆箱"><span class="nav-number">7.</span> <span class="nav-text">自动装箱与拆箱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java如何实现平台无关性"><span class="nav-number">8.</span> <span class="nav-text">Java如何实现平台无关性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java中Class类的作用"><span class="nav-number">9.</span> <span class="nav-text">Java中Class类的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fail-fast和fail-safe"><span class="nav-number">10.</span> <span class="nav-text">fail-fast和fail-safe</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浅拷贝与深拷贝"><span class="nav-number">11.</span> <span class="nav-text">浅拷贝与深拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组和链表"><span class="nav-number">12.</span> <span class="nav-text">数组和链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList和LinkedList"><span class="nav-number">13.</span> <span class="nav-text">ArrayList和LinkedList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List和Set"><span class="nav-number">14.</span> <span class="nav-text">List和Set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HashSet如何实现添加元素时保证元素不重复"><span class="nav-number">14.1.</span> <span class="nav-text">HashSet如何实现添加元素时保证元素不重复</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关于HashMap"><span class="nav-number">14.2.</span> <span class="nav-text">关于HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Hash冲突的解决办法："><span class="nav-number">14.2.1.</span> <span class="nav-text">Hash冲突的解决办法：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么HsahMap的数组长度要取2的整数幂"><span class="nav-number">14.2.2.</span> <span class="nav-text">为什么HsahMap的数组长度要取2的整数幂</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉查找树，AVL树，B树，红黑树"><span class="nav-number">15.</span> <span class="nav-text">二叉查找树，AVL树，B树，红黑树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String、StringBuilder、StringBuffer"><span class="nav-number">16.</span> <span class="nav-text">String、StringBuilder、StringBuffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#finally，finalize，final"><span class="nav-number">17.</span> <span class="nav-text">finally，finalize，final</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final，Static，Static-final"><span class="nav-number">18.</span> <span class="nav-text">final，Static，Static final</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Static可以被继承嘛"><span class="nav-number">18.1.</span> <span class="nav-text">Static可以被继承嘛</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#是否可以从一个static方法内部访问该类的非static方法"><span class="nav-number">18.2.</span> <span class="nav-text">是否可以从一个static方法内部访问该类的非static方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态变量和实例变量的区别"><span class="nav-number">18.3.</span> <span class="nav-text">静态变量和实例变量的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java的运行时数据区"><span class="nav-number">19.</span> <span class="nav-text">Java的运行时数据区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#运行时常量池的作用"><span class="nav-number">19.1.</span> <span class="nav-text">运行时常量池的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常量池的好处"><span class="nav-number">19.2.</span> <span class="nav-text">常量池的好处</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是直接内存"><span class="nav-number">20.</span> <span class="nav-text">什么是直接内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存溢出-OOM"><span class="nav-number">21.</span> <span class="nav-text">内存溢出(OOM)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-中Ioc的工厂模式"><span class="nav-number">22.</span> <span class="nav-text">Spring 中Ioc的工厂模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring中Bean的生命周期"><span class="nav-number">23.</span> <span class="nav-text">Spring中Bean的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringBoot的自动装配"><span class="nav-number">24.</span> <span class="nav-text">SpringBoot的自动装配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring中的注解"><span class="nav-number">25.</span> <span class="nav-text">Spring中的注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringMVC流程"><span class="nav-number">26.</span> <span class="nav-text">SpringMVC流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java中的异常体系"><span class="nav-number">27.</span> <span class="nav-text">Java中的异常体系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BIO，NIO，AIO"><span class="nav-number">28.</span> <span class="nav-text">BIO，NIO，AIO</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#NIO-和-BIO-对比"><span class="nav-number">28.1.</span> <span class="nav-text">NIO 和 BIO 对比</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程和进程"><span class="nav-number">29.</span> <span class="nav-text">线程和进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程的生命周期和状态"><span class="nav-number">30.</span> <span class="nav-text">线程的生命周期和状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep-方法和wait-方法区别和共同点"><span class="nav-number">31.</span> <span class="nav-text">sleep()方法和wait()方法区别和共同点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调用start-时会执行run-为什么不直接执行run"><span class="nav-number">32.</span> <span class="nav-text">调用start()时会执行run(),为什么不直接执行run()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多线程开发带来的问题-与解决方法："><span class="nav-number">33.</span> <span class="nav-text">多线程开发带来的问题,与解决方法：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程安全问题："><span class="nav-number">33.1.</span> <span class="nav-text">线程安全问题：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#性能问题"><span class="nav-number">33.2.</span> <span class="nav-text">性能问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#活跃性问题"><span class="nav-number">33.3.</span> <span class="nav-text">活跃性问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#阻塞"><span class="nav-number">33.4.</span> <span class="nav-text">阻塞</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized和Lock的区别："><span class="nav-number">34.</span> <span class="nav-text">synchronized和Lock的区别：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池"><span class="nav-number">35.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用线程池的好处："><span class="nav-number">35.1.</span> <span class="nav-text">使用线程池的好处：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#说说几种常见线程池和适用场景"><span class="nav-number">35.2.</span> <span class="nav-text">说说几种常见线程池和适用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程池都有哪些工作队列"><span class="nav-number">35.3.</span> <span class="nav-text">线程池都有哪些工作队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建线程的几种方式"><span class="nav-number">35.4.</span> <span class="nav-text">创建线程的几种方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程池的执行流程"><span class="nav-number">35.5.</span> <span class="nav-text">线程池的执行流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS-AbstractQueuedSynchronizer"><span class="nav-number">36.</span> <span class="nav-text">AQS(AbstractQueuedSynchronizer)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AQS对资源的共享方式"><span class="nav-number">36.1.</span> <span class="nav-text">AQS对资源的共享方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP三次握手与四次挥手"><span class="nav-number">37.</span> <span class="nav-text">TCP三次握手与四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#三次握手的过程"><span class="nav-number">37.1.</span> <span class="nav-text">三次握手的过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么TCP客户端最后还要发送一次确认呢"><span class="nav-number">37.2.</span> <span class="nav-text">为什么TCP客户端最后还要发送一次确认呢?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四次挥手的过程"><span class="nav-number">37.3.</span> <span class="nav-text">四次挥手的过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么建立连接是三次握手，释放连接确实四次挥手？"><span class="nav-number">37.4.</span> <span class="nav-text">为什么建立连接是三次握手，释放连接确实四次挥手？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三次握手过程中可以携带数据嘛"><span class="nav-number">37.5.</span> <span class="nav-text">三次握手过程中可以携带数据嘛</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如果已经建立连接，但是客户端出现故障-TCP的保活机制-keapalive长连接"><span class="nav-number">38.</span> <span class="nav-text">如果已经建立连接，但是客户端出现故障(TCP的保活机制)(keapalive长连接)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP的重传机制"><span class="nav-number">39.</span> <span class="nav-text">TCP的重传机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP的流量控制"><span class="nav-number">40.</span> <span class="nav-text">TCP的流量控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#滑动窗口"><span class="nav-number">40.1.</span> <span class="nav-text">滑动窗口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拥塞控制"><span class="nav-number">41.</span> <span class="nav-text">拥塞控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP的可靠性"><span class="nav-number">42.</span> <span class="nav-text">TCP的可靠性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP和UDP的区别"><span class="nav-number">43.</span> <span class="nav-text">TCP和UDP的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP和UDP的应用"><span class="nav-number">43.1.</span> <span class="nav-text">TCP和UDP的应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在浏览器输入url地址到显示主页的过程"><span class="nav-number">44.</span> <span class="nav-text">在浏览器输入url地址到显示主页的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM-新生代和老年代都使用什么GC算法"><span class="nav-number">45.</span> <span class="nav-text">JVM 新生代和老年代都使用什么GC算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#新生代和老年代的区别"><span class="nav-number">45.1.</span> <span class="nav-text">新生代和老年代的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM垃圾收集器"><span class="nav-number">46.</span> <span class="nav-text">JVM垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CMS-Concurrent-Mark-Sweep-回收器："><span class="nav-number">46.1.</span> <span class="nav-text">CMS(Concurrent Mark Sweep)回收器：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#G1收集器"><span class="nav-number">46.2.</span> <span class="nav-text">G1收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他收集器"><span class="nav-number">46.3.</span> <span class="nav-text">其他收集器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM-GC调优"><span class="nav-number">47.</span> <span class="nav-text">JVM GC调优</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Minor-GC和Major-GC频繁"><span class="nav-number">47.1.</span> <span class="nav-text">Minor GC和Major GC频繁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类加载机制"><span class="nav-number">48.</span> <span class="nav-text">类加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#知道哪些类加载器"><span class="nav-number">48.1.</span> <span class="nav-text">知道哪些类加载器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#双亲委派模型"><span class="nav-number">48.2.</span> <span class="nav-text">双亲委派模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简单介绍一下redis"><span class="nav-number">49.</span> <span class="nav-text">简单介绍一下redis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis常见数据结构"><span class="nav-number">50.</span> <span class="nav-text">redis常见数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要用redis缓存"><span class="nav-number">51.</span> <span class="nav-text">为什么要用redis缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis和memcached"><span class="nav-number">52.</span> <span class="nav-text">redis和memcached</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis内存淘汰机制"><span class="nav-number">53.</span> <span class="nav-text">redis内存淘汰机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存穿透"><span class="nav-number">54.</span> <span class="nav-text">缓存穿透</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#布隆过滤器"><span class="nav-number">54.1.</span> <span class="nav-text">布隆过滤器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存雪崩"><span class="nav-number">55.</span> <span class="nav-text">缓存雪崩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis的持久化"><span class="nav-number">56.</span> <span class="nav-text">redis的持久化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何保证缓存与数据库双写时的一致性"><span class="nav-number">57.</span> <span class="nav-text">如何保证缓存与数据库双写时的一致性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL存储引擎"><span class="nav-number">58.</span> <span class="nav-text">MySQL存储引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL的事务"><span class="nav-number">59.</span> <span class="nav-text">MySQL的事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事务隔离级别有哪些"><span class="nav-number">60.</span> <span class="nav-text">事务隔离级别有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一条SQL执行的很慢有哪些原因"><span class="nav-number">61.</span> <span class="nav-text">一条SQL执行的很慢有哪些原因</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
          


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">摸鱼选手Wei</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        
<div class="busuanzi-count">
 <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
	<script src="/js/md5.min.js"></script>
    <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: '189bc28497572ad87947',
          clientSecret: '084a899efcea3646e7ee9ba066db2f077b3b403a',
          repo: 'Blog-Comments',
          owner: 'CloudMadao',
          admin: ['CloudMadao'],
          id: decodeURI(location.pathname),
          distractionFreeMode: 'false'
        })
        gitalk.render('gitalk-container')           
    </script>

  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
